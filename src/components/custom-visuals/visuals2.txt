```javascript
import React, { useEffect, useRef } from 'react';

// themes: knowledge brings wisdom, control requires strength, staying centered endures
// visualization: A centered form gains strength through understanding its own nature

const TorusFieldDynamics = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    canvas.width = 550;
    canvas.height = 550;
    
    let time = 0;
    let animationFrameId: number;
    
    const animate = () => {
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      time += 0.008;
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      // Draw field lines of growing wisdom
      const fieldLines = 40;
      const toroidalRadius = 120;
      const poloidalRadius = 60;
      
      for (let i = 0; i < fieldLines; i++) {
        const u = (i / fieldLines) * Math.PI * 2;
        
        for (let j = 0; j < fieldLines; j++) {
          const v = (j / fieldLines) * Math.PI * 2;
          
          // Torus parametric equations
          const x = (toroidalRadius + poloidalRadius * Math.cos(v)) * Math.cos(u);
          const y = (toroidalRadius + poloidalRadius * Math.cos(v)) * Math.sin(u);
          const z = poloidalRadius * Math.sin(v);
          
          // Project 3D to 2D with perspective
          const scale = 200 / (200 + z);
          const screenX = centerX + x * scale;
          const screenY = centerY + y * scale * 0.5; // Flatten for top view
          
          // Add dynamic movement
          const phase = time + u * 0.5 + v * 0.5;
          const offset = Math.sin(phase) * 5;
          
          ctx.beginPath();
          ctx.arc(screenX + offset, screenY + offset, 1, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(80, 80, 80, ${0.3 * scale})`;
          ctx.fill();
        }
      }
      
      // Draw energy flow lines
      const flowLines = 20;
      for (let i = 0; i < flowLines; i++) {
        const angle = (i / flowLines) * Math.PI * 2;
        
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(80, 80, 80, 0.2)';
        ctx.lineWidth = 1;
        
        for (let t = 0; t < 1; t += 0.01) {
          const radius = toroidalRadius + poloidalRadius * Math.cos(t * Math.PI * 2 * 3 + time);
          const x = centerX + Math.cos(angle + t * Math.PI * 4) * radius;
          const y = centerY + Math.sin(angle + t * Math.PI * 4) * radius * 0.5;
          
          if (t === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
      }
      
      // Draw the enduring center that gives strength
      const vortexRadius = 30;
      ctx.beginPath();
      ctx.arc(centerX, centerY, vortexRadius, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(80, 80, 80, 0.5)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Vortex spiral
      ctx.beginPath();
      const spiralTurns = 3;
      for (let i = 0; i < 100; i++) {
        const t = i / 100;
        const angle = t * Math.PI * 2 * spiralTurns - time * 2;
        const radius = vortexRadius * (1 - t);
        
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.strokeStyle = 'rgba(80, 80, 80, 0.4)';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Add harmonic rings
      for (let r = 50; r < 250; r += 30) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, r + Math.sin(time + r * 0.01) * 5, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(80, 80, 80, 0.1)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      
      animationFrameId = requestAnimationFrame(animate);
    };
    
    animate();
    
    // Cleanup function that cancels the animation frame
    return () => {
      cancelAnimationFrame(animationFrameId);
      
      // Clear the canvas
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    };
  }, []);
  
  return (
    <div className="flex items-center justify-center w-full h-full" style={{ backgroundColor: '#F0EEE6' }}>
      <div className="w-[550px] h-[550px] shadow-lg rounded-lg overflow-hidden">
        <canvas 
          ref={canvasRef} 
          className="w-full h-full"
        />
      </div>
    </div>
  );
};

export default TorusFieldDynamics;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: source flows everywhere, silent fulfillment, humble greatness
// visualization: Waves flow silently in all directions, achieving greatness without recognition

export default function PhaseDistortionWaves() {
  const canvasRef = useRef(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    // Set canvas dimensions
    canvas.width = 550;
    canvas.height = 550;
    
    let t = 0;
    
    // Draw waves that silently fulfill their nature
    const drawWave = (yCenter, amplitude, frequency, phaseOffset, thickness) => {
      ctx.beginPath();
      
      // Draw wave path
      for (let x = 0; x < canvas.width; x++) {
        // Calculate phase distortion based on position and time (slowed down)
        const distortion = 
          Math.sin(x * 0.02 + t * 0.05) * 2 + 
          Math.cos(x * 0.01 - t * 0.03) * 3;
        
        // Apply distortion to base wave
        const y = yCenter + 
                 amplitude * Math.sin(x * frequency + t + phaseOffset + distortion);
        
        if (x === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      
      ctx.lineWidth = thickness;
      ctx.stroke();
    };
    
    let animationFrameId;
    const render = () => {
      // Clear canvas with specified background color
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.strokeStyle = 'rgba(51, 51, 51, 0.6)';
      
      // Draw multiple waves with different parameters
      const waveCount = 15;
      for (let i = 0; i < waveCount; i++) {
        const yCenter = 100 + (canvas.height - 200) * (i / (waveCount - 1));
        const amplitude = 10 + Math.sin(t * 0.025 + i * 0.3) * 5;
        const frequency = 0.02 + 0.01 * Math.sin(i * 0.2);
        const phaseOffset = i * 0.3;
        const thickness = 1 + Math.sin(t + i) * 0.5;
        
        drawWave(yCenter, amplitude, frequency, phaseOffset, thickness);
      }
      
      // Source flows in all directions with humble grace
      ctx.globalCompositeOperation = 'multiply';
      ctx.strokeStyle = 'rgba(51, 51, 51, 0.3)';
      
      for (let i = 0; i < waveCount; i++) {
        const xCenter = 100 + (canvas.width - 200) * (i / (waveCount - 1));
        const amplitude = 15 + Math.cos(t * 0.04 + i * 0.3) * 8;
        const frequency = 0.02 + 0.01 * Math.cos(i * 0.3);
        const phaseOffset = i * 0.4;
        const thickness = 1 + Math.cos(t + i) * 0.5;
        
        // Draw vertical waves
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(Math.PI / 2);
        ctx.translate(-canvas.width / 2, -canvas.height / 2);
        
        drawWave(xCenter, amplitude, frequency, phaseOffset, thickness);
        
        ctx.restore();
      }
      
      ctx.globalCompositeOperation = 'source-over';
      
      t += 0.004;
      animationFrameId = requestAnimationFrame(render);
    };
    
    render();
    
    return () => {
      // Cleanup
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    };
  }, []);
  
  return (
    <div 
      className="w-full h-screen flex items-center justify-center"
      style={{ backgroundColor: '#F0EEE6' }}
    >
      <div 
        style={{ width: '550px', height: '550px' }}
        className="border border-gray-200 rounded-md shadow-md"
      >
        <canvas 
          ref={canvasRef} 
          className="w-full h-full rounded-md"
        />
      </div>
    </div>
  );
}
```

```javascript
import React, { useState, useEffect, useRef } from 'react';

// themes: connection to source, universal harmony, inexhaustible use
// visualization: Patterns emerge endlessly from source, finding harmony in constant transformation

const patterns = {
  // Pattern finding harmony in connection to source
  balance: (x, y, t) => {
    const cx = 30;
    const cy = 15;
    const dx = x - cx;
    const dy = y - cy;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    return Math.sin(dx * 0.3 + t * 0.5) * Math.cos(dy * 0.3 + t * 0.3) * 
           Math.sin(dist * 0.1 - t * 0.4);
  },
  
  duality: (x, y, t) => {
    const cx = 30;
    const left = x < cx ? Math.sin(x * 0.2 + t * 0.3) : 0;
    const right = x >= cx ? Math.cos(x * 0.2 - t * 0.3) : 0;
    
    return left + right + Math.sin(y * 0.3 + t * 0.2);
  },
  
  flow: (x, y, t) => {
    const angle = Math.atan2(y - 15, x - 30);
    const dist = Math.sqrt((x - 30) ** 2 + (y - 15) ** 2);
    
    return Math.sin(angle * 3 + t * 0.4) * Math.cos(dist * 0.1 - t * 0.3);
  },
  
  chaos: (x, y, t) => {
    const noise1 = Math.sin(x * 0.5 + t) * Math.cos(y * 0.3 - t);
    const noise2 = Math.sin(y * 0.4 + t * 0.5) * Math.cos(x * 0.2 + t * 0.7);
    const noise3 = Math.sin((x + y) * 0.2 + t * 0.8);
    
    return noise1 * 0.3 + noise2 * 0.3 + noise3 * 0.4;
  }
};

const BlackWhiteBlobs = () => {
  const [frame, setFrame] = useState(0);
  const [patternType, setPatternType] = useState(0);
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
  const [mouseDown, setMouseDown] = useState(false);
  const containerRef = useRef(null);
  
  const patternTypes = ['balance', 'duality', 'flow', 'chaos'];
  const width = 60;
  const height = 35;
  const slowdownFactor = 12; // Quadrupled from original speed of 3
  
  // Background color as specified in requirements
  const BACKGROUND_COLOR = '#F0EEE6';
  
  useEffect(() => {
    let animationId;
    
    const animate = () => {
      setFrame(f => (f + 1) % (240 * slowdownFactor));
      animationId = requestAnimationFrame(animate);
    };
    
    animationId = requestAnimationFrame(animate);
    
    return () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
    };
  }, [slowdownFactor]);
  
  // Generate inexhaustible variations from universal harmony
  const generateAsciiArt = () => {
    const t = (frame * Math.PI) / (60 * slowdownFactor);
    const currentPattern = patterns[patternTypes[patternType]];
    let result = '';
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let value = currentPattern(x, y, t);
        
        if (mouseDown && containerRef.current) {
          const rect = containerRef.current.getBoundingClientRect();
          const dx = x - (((mousePos.x - rect.left) / rect.width) * width);
          const dy = y - (((mousePos.y - rect.top) / rect.height) * height);
          const dist = Math.sqrt(dx * dx + dy * dy);
          const mouseInfluence = Math.exp(-dist * 0.1) * Math.sin(t * 2);
          value += mouseInfluence * 0.8;
        }
        
        if (value > 0.8) {
          result += '█';
        } else if (value > 0.5) {
          result += '▓';
        } else if (value > 0.2) {
          result += '▒';
        } else if (value > -0.2) {
          result += '░';
        } else if (value > -0.5) {
          result += '·';
        } else {
          result += ' ';
        }
      }
      result += '\n';
    }
    
    return result;
  };
  
  const handleClick = () => {
    setPatternType((prev) => (prev + 1) % patternTypes.length);
  };
  
  const handleMouseMove = (e) => {
    setMousePos({ x: e.clientX, y: e.clientY });
  };
  
  const handleMouseDown = () => {
    setMouseDown(true);
  };
  
  const handleMouseUp = () => {
    setMouseDown(false);
  };
  
  return (
    <div 
      style={{ 
        margin: 0,
        padding: 0,
        background: BACKGROUND_COLOR,
        overflow: 'hidden',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        height: '100%'
      }}
      onMouseMove={handleMouseMove}
      onMouseDown={handleMouseDown}
      onMouseUp={handleMouseUp}
      onClick={handleClick}
      ref={containerRef}
    >
      <pre style={{
        fontFamily: 'monospace',
        fontSize: '12px',
        lineHeight: '1',
        letterSpacing: '0.1em',
        color: '#333',
        userSelect: 'none',
        cursor: 'pointer',
        margin: 0,
        padding: 0
      }}>
        {generateAsciiArt()}
      </pre>
    </div>
  );
};

export default BlackWhiteBlobs;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: shrink to expand, weaken to strengthen, subtle perception
// visualization: Forms contract to find expansion, discovering strength through yielding

const ParticleReverie = () => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Parameters
    const numParticles = 5000;
    let time = 65;
    let startTime = Date.now();
    
    // Pre-calculate initial state to match frame 65 exactly
    const initialT = 65;
    
    // Create particles in a formation that matches frame 65 exactly
    const particles = Array(numParticles).fill().map((_, i) => {
      const angle1 = (i / numParticles) * Math.PI * 2;
      const angle2 = Math.random() * Math.PI * 2;
      
      // Base shape parameters
      const baseScale = 120;
      
      // Initial organic shape - matching exactly the shape at frame 65
      const initialMorphFactor = Math.sin(initialT * 0.2) * 0.5 + 0.5;
      
      // Calculate shape 1 position at frame 65
      const r1 = baseScale * (1 + 0.3 * Math.sin(angle1 * 2));
      const shape1X = r1 * Math.cos(angle1) * (1 + 0.2 * Math.sin(angle1 * 3 + initialT * 0.1));
      const shape1Y = r1 * Math.sin(angle1) * (1 + 0.4 * Math.cos(angle1 * 3 + initialT * 0.2));
      
      // Calculate shape 2 position at frame 65
      const r2 = baseScale * (1 + 0.4 * Math.sin(angle2 * 3));
      const shape2X = r2 * Math.cos(angle2) * (1 + 0.3 * Math.sin(angle2 * 2 + initialT * 0.15));
      const shape2Y = r2 * Math.sin(angle2) * (1 + 0.2 * Math.cos(angle2 * 4 + initialT * 0.25));
      
      // Position using same calculation as in calculateTargets
      let x = width/2 + (shape1X * (1 - initialMorphFactor) + shape2X * initialMorphFactor);
      let y = height/2 + (shape1Y * (1 - initialMorphFactor) + shape2Y * initialMorphFactor);
      
      // Add bulge effect
      const initialBulgeAmount = 50 * (Math.sin(initialT * 0.3) * 0.2 + 0.8);
      const bulgeX = initialBulgeAmount * Math.exp(-Math.pow(angle1 - Math.PI * 0.5, 2));
      const bulgeY = initialBulgeAmount * 0.5 * Math.exp(-Math.pow(angle1 - Math.PI * 0.5, 2));
      
      x += bulgeX * Math.sin(initialT * 0.4);
      y += bulgeY * Math.cos(initialT * 0.3);
      
      return {
        x,
        y,
        size: Math.random() * 1.5 + 0.5,
        connections: [],
        targetX: 0,
        targetY: 0,
        vx: 0,
        vy: 0,
        angle: angle2
      };
    });
    
    // Calculate how forms must contract to find expansion
    const calculateTargets = (t) => {
      // Calculate animation time separately to create gradual startup
      const animationTime = t - 65 + animationStartTime;
      
      // Gentle startup for morphFactor - starts at actual value but changes smoothly
      const startupEasing = Math.min(1, animationTime / 10); // Ramp up over first 10 time units
      const morphFactor = Math.sin(t * 0.2) * 0.5 + 0.5; // Value between 0 and 1 for morphing
      
      particles.forEach((particle, i) => {
        // Angle for this particle
        const angle1 = (i / numParticles) * Math.PI * 2;
        const angle2 = particle.angle;
        
        // Base shape parameters
        const baseScale = 120;
        const bulgeAmount = 50 * (Math.sin(t * 0.3) * 0.2 + 0.8);
        
        // Shape 1: Organic blob - use startup easing for time-based terms
        const timeEffect1 = t + (animationTime * startupEasing * 0.1); // Gradually introduce time-based movement
        const r1 = baseScale * (1 + 0.3 * Math.sin(angle1 * 2));
        const shape1X = r1 * Math.cos(angle1) * (1 + 0.2 * Math.sin(angle1 * 3 + timeEffect1 * 0.1));
        const shape1Y = r1 * Math.sin(angle1) * (1 + 0.4 * Math.cos(angle1 * 3 + timeEffect1 * 0.2));
        
        // Shape 2: Different organic form - use startup easing for time-based terms
        const timeEffect2 = t + (animationTime * startupEasing * 0.1); // Gradually introduce time-based movement
        const r2 = baseScale * (1 + 0.4 * Math.sin(angle2 * 3));
        const shape2X = r2 * Math.cos(angle2) * (1 + 0.3 * Math.sin(angle2 * 2 + timeEffect2 * 0.15));
        const shape2Y = r2 * Math.sin(angle2) * (1 + 0.2 * Math.cos(angle2 * 4 + timeEffect2 * 0.25));
        
        // Morph between shapes
        particle.targetX = shape1X * (1 - morphFactor) + shape2X * morphFactor;
        particle.targetY = shape1Y * (1 - morphFactor) + shape2Y * morphFactor;
        
        // Add bulge effect - also ease in the time-based movement
        const bulgeX = bulgeAmount * Math.exp(-Math.pow(angle1 - Math.PI * 0.5, 2));
        const bulgeY = bulgeAmount * 0.5 * Math.exp(-Math.pow(angle1 - Math.PI * 0.5, 2));
        
        // Apply startup easing to bulge movement
        particle.targetX += bulgeX * Math.sin(timeEffect1 * 0.4);
        particle.targetY += bulgeY * Math.cos(timeEffect1 * 0.3);
        
        // Add noise for more organic feel
        particle.targetX += (Math.random() - 0.5) * 5;
        particle.targetY += (Math.random() - 0.5) * 5;
      });
    };
    
    // Animation runtime - separate from initialization time
    let animationStartTime = 0;
        
    // Function to update particle positions
    const updateParticles = () => {
      // Calculate animation time separately to create gradual startup
      const animationTime = time - 65 + animationStartTime;
      
      particles.forEach(particle => {
        // Direct interpolation instead of spring physics
        const dx = particle.targetX - (particle.x - width/2);
        const dy = particle.targetY - (particle.y - height/2);
        
        // Gentle linear interpolation (lerp) with gradual startup
        // Start with very slow easing that gradually increases to normal speed
        const startupPhase = Math.min(1, animationTime / 5); // Ramp up over first 5 time units 
        const easing = 0.01 + (0.02 * startupPhase); // Gradually increase from 0.01 to 0.03
        
        particle.x += dx * easing;
        particle.y += dy * easing;
        
        // Reset connections
        particle.connections = [];
      });
    };
    
    // Perceive subtle connections that create strength
    const calculateConnections = () => {
      const maxDist = 25;
      const maxConnections = 3;
      
      for (let i = 0; i < particles.length; i++) {
        const p1 = particles[i];
        
        // Limit connections per particle for performance
        if (p1.connections.length >= maxConnections) continue;
        
        for (let j = i + 1; j < particles.length; j++) {
          const p2 = particles[j];
          
          // Skip if second particle already has max connections
          if (p2.connections.length >= maxConnections) continue;
          
          // Calculate distance
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          // Connect if close enough and not too many connections
          if (dist < maxDist) {
            p1.connections.push(j);
            p2.connections.push(i);
            
            // Break if max connections reached
            if (p1.connections.length >= maxConnections) break;
          }
        }
      }
    };
    
    // Function to draw everything
    const draw = () => {
      // Clear canvas with background color
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, width, height);
      
      // Draw connections first (below particles)
      ctx.strokeStyle = 'rgba(51, 51, 51, 0.2)';
      ctx.lineWidth = 0.5;
      
      for (let i = 0; i < particles.length; i++) {
        const p1 = particles[i];
        
        for (let j = 0; j < p1.connections.length; j++) {
          const p2 = particles[p1.connections[j]];
          
          // Draw line
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          
          // Add slight curve to lines
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          const offset = 5 * Math.sin(time * 0.5 + i * 0.01);
          
          ctx.quadraticCurveTo(
            midX + offset, 
            midY + offset, 
            p2.x, 
            p2.y
          );
          
          ctx.stroke();
        }
      }
      
      // Draw particles
      particles.forEach(particle => {
        const distFromCenter = Math.sqrt(
          Math.pow(particle.x - width/2, 2) + 
          Math.pow(particle.y - height/2, 2)
        );
        
        // Opacity based on distance from center for 3D effect
        const opacity = Math.max(0.1, 1 - distFromCenter / 300);
        
        ctx.fillStyle = `rgba(51, 51, 51, ${opacity})`;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        ctx.fill();
      });
    };
    
    // Animation loop with requestAnimationFrame
    let animationFrameId = null;
    let lastFrameTime = 0;
    const targetFPS = 36; // 36fps for enhanced smoothness
    const frameInterval = 1000 / targetFPS;
    
    const animate = (currentTime) => {
      animationFrameId = requestAnimationFrame(animate);
      
      const deltaTime = currentTime - lastFrameTime;
      
      // Only update if enough time has passed
      if (deltaTime >= frameInterval) {
        // Calculate remainder to prevent drift
        const remainder = deltaTime % frameInterval;
        
        // Update lastFrameTime with the time that's been processed
        lastFrameTime = currentTime - remainder;
        
        time += 0.005; // Back to original speed
        
        // Calculate new target positions
        calculateTargets(time);
        
        // Update particle positions
        updateParticles();
        
        // Calculate connections
        calculateConnections();
        
        // Draw everything
        draw();
      }
    };
    
    // Start animation
    animationFrameId = requestAnimationFrame(animate);
    
    return () => {
      // Cancel animation frame to prevent memory leaks
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, width, height);
      }
      
      // Clear particles array to prevent memory leaks
      particles.length = 0;
    };
  }, []);

  return (
    <div className="flex justify-center items-center bg-[#F0EEE6] w-full h-full">
      <canvas 
        ref={canvasRef} 
        width={550} 
        height={550} 
        className="max-w-full max-h-full"
      />
    </div>
  );
};

export default ParticleReverie;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: source does nothing, natural development, peace through tranquility
// visualization: Waves emerge naturally from an unmoving center, finding peace in their flow

const WaveInterferenceV5 = () => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = 550;
    const height = 550;
    canvas.width = width;
    canvas.height = height;

    // Radial arrangement with central focus (fewer sources for better performance)
    const sources = [];
    const numRings = 2; // Reduced from 3
    const sourcesPerRing = 6; // Reduced from 8
    
    // Unmoving source from which all emerges
    sources.push({
      x: width/2,
      y: height/2,
      wavelength: 25,
      phase: 0,
      amplitude: 1.5
    });
    
    // Radial sources
    for (let ring = 1; ring <= numRings; ring++) {
      const radius = ring * 120; // Increased spacing
      const numSources = sourcesPerRing;
      
      for (let i = 0; i < numSources; i++) {
        const angle = (i / numSources) * Math.PI * 2;
        sources.push({
          x: width/2 + Math.cos(angle) * radius,
          y: height/2 + Math.sin(angle) * radius,
          wavelength: 20 + ring * 5,
          phase: (i / numSources) * Math.PI,
          amplitude: 1.0 - ring * 0.2
        });
      }
    }

    let time = 0;
    let animationFrameId;
    
    // Precompute constants
    const TWO_PI = Math.PI * 2;
    const INV_300 = 1 / 300;
    
    // Throttle calculation to skip frames for better performance
    let frameCount = 0;
    const skipFrames = 1; // Render every other frame

    const animate = () => {
      frameCount++;
      
      if (frameCount % (skipFrames + 1) !== 0) {
        time += 0.0015; // Reduced from 0.0025 for slower animation
        animationFrameId = requestAnimationFrame(animate);
        return;
      }
      
      // Fill with project background color
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, width, height);

      // Lower resolution field for better performance
      const resolution = 3; // Increased from 1
      const rows = Math.floor(height / resolution);
      const cols = Math.floor(width / resolution);
      const field = new Array(rows).fill(0).map(() => new Array(cols).fill(0));

      // Let patterns develop naturally, finding their peace
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const x = j * resolution;
          const y = i * resolution;
          let amplitude = 0;

          sources.forEach(source => {
            const dx = x - source.x;
            const dy = y - source.y;
            const dist2 = dx * dx + dy * dy;
            const distance = Math.sqrt(dist2);
            
            // Skip if too far from source
            if (distance > 400) return;
            
            // Apply amplitude falloff (optimized)
            const falloff = Math.exp(-distance * INV_300);
            amplitude += source.amplitude * falloff * 
              Math.sin((distance / source.wavelength - time) * TWO_PI + source.phase);
          });

          field[i][j] = amplitude;
        }
      }

      // Simplified line rendering
      ctx.strokeStyle = '#333';
      
      // Fewer contour levels
      const contourLevels = [-0.8, -0.4, 0, 0.4, 0.8];
      
      contourLevels.forEach((level, index) => {
        // Vary line width based on contour level
        ctx.lineWidth = index % 2 === 0 ? 0.8 : 0.5;
        ctx.beginPath();
        
        for (let i = 0; i < rows - 1; i++) {
          for (let j = 0; j < cols - 1; j++) {
            const x = j * resolution;
            const y = i * resolution;
            
            // Optimized marching squares
            const v00 = field[i][j];
            const v10 = field[i][j + 1];
            const v11 = field[i + 1][j + 1];
            const v01 = field[i + 1][j];
            
            // Early exit optimization
            const allAbove = v00 > level && v10 > level && v11 > level && v01 > level;
            const allBelow = v00 <= level && v10 <= level && v11 <= level && v01 <= level;
            if (allAbove || allBelow) continue;
            
            const case4 = 
              (v00 > level ? 8 : 0) +
              (v10 > level ? 4 : 0) +
              (v11 > level ? 2 : 0) +
              (v01 > level ? 1 : 0);
            
            // Simplified linear interpolation
            const lerp = (a, b, t) => a + t * (b - a);
            const safeDiv = (a, b) => b === 0 ? 0 : a / b;
            
            switch (case4) {
              case 1: case 14: {
                const t1 = safeDiv(level - v00, v01 - v00);
                const t2 = safeDiv(level - v01, v11 - v01);
                ctx.moveTo(x, lerp(y, y + resolution, t1));
                ctx.lineTo(lerp(x, x + resolution, t2), y + resolution);
                break;
              }
              case 2: case 13: {
                const t1 = safeDiv(level - v01, v11 - v01);
                const t2 = safeDiv(level - v11, v10 - v11);
                ctx.moveTo(lerp(x, x + resolution, t1), y + resolution);
                ctx.lineTo(x + resolution, lerp(y + resolution, y, t2));
                break;
              }
              case 3: case 12: {
                const t1 = safeDiv(level - v00, v01 - v00);
                const t2 = safeDiv(level - v10, v11 - v10);
                ctx.moveTo(x, lerp(y, y + resolution, t1));
                ctx.lineTo(x + resolution, lerp(y, y + resolution, t2));
                break;
              }
              case 4: case 11: {
                const t1 = safeDiv(level - v10, v11 - v10);
                const t2 = safeDiv(level - v10, v00 - v10);
                ctx.moveTo(x + resolution, lerp(y, y + resolution, t1));
                ctx.lineTo(lerp(x + resolution, x, t2), y);
                break;
              }
              case 5: case 10: {
                // Two lines for saddle points
                const t1 = safeDiv(level - v00, v01 - v00);
                const t2 = safeDiv(level - v00, v10 - v00);
                ctx.moveTo(x, lerp(y, y + resolution, t1));
                ctx.lineTo(lerp(x, x + resolution, t2), y);
                
                const t3 = safeDiv(level - v11, v10 - v11);
                const t4 = safeDiv(level - v11, v01 - v11);
                ctx.moveTo(x + resolution, lerp(y + resolution, y, t3));
                ctx.lineTo(lerp(x + resolution, x, t4), y + resolution);
                break;
              }
              case 6: case 9: {
                const t1 = safeDiv(level - v10, v00 - v10);
                const t2 = safeDiv(level - v11, v01 - v11);
                ctx.moveTo(lerp(x + resolution, x, t1), y);
                ctx.lineTo(lerp(x + resolution, x, t2), y + resolution);
                break;
              }
              case 7: case 8: {
                const t1 = safeDiv(level - v00, v01 - v00);
                const t2 = safeDiv(level - v00, v10 - v00);
                ctx.moveTo(x, lerp(y, y + resolution, t1));
                ctx.lineTo(lerp(x, x + resolution, t2), y);
                break;
              }
            }
          }
        }
        
        ctx.stroke();
      });

      time += 0.0015; // Reduced from 0.0025 for slower animation
      animationFrameId = requestAnimationFrame(animate);
    };

    animationFrameId = requestAnimationFrame(animate);

    return () => {
      // Cancel the animation frame
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      // Clear main canvas
      if (ctx) {
        ctx.clearRect(0, 0, width, height);
      }
      
      // Clear buffer canvas
      if (bufferCtx) {
        bufferCtx.clearRect(0, 0, width, height);
      }
      
      // Clear arrays to prevent memory leaks
      sources.length = 0;
    };
  }, []);

  return (
    <div style={{ 
      margin: 0,
      background: '#F0EEE6',
      overflow: 'hidden',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      height: '100%',
      width: '100%'
    }}>
      <div style={{
        padding: '30px',
        position: 'relative',
        width: '100%',
        height: '100%',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}>
        <canvas 
          ref={canvasRef} 
          style={{ 
            display: 'block',
            width: '550px',
            height: '550px'
          }} 
        />
      </div>
    </div>
  );
};

export default WaveVariationSparse;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: knowledge brings wisdom, control requires strength, staying centered endures
// visualization: A centered form gains strength through understanding its own nature

const TorusFieldDynamics = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    canvas.width = 550;
    canvas.height = 550;
    
    let time = 0;
    let animationFrameId: number;
    
    const animate = () => {
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      time += 0.008;
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      // Draw field lines of growing wisdom
      const fieldLines = 40;
      const toroidalRadius = 120;
      const poloidalRadius = 60;
      
      for (let i = 0; i < fieldLines; i++) {
        const u = (i / fieldLines) * Math.PI * 2;
        
        for (let j = 0; j < fieldLines; j++) {
          const v = (j / fieldLines) * Math.PI * 2;
          
          // Torus parametric equations
          const x = (toroidalRadius + poloidalRadius * Math.cos(v)) * Math.cos(u);
          const y = (toroidalRadius + poloidalRadius * Math.cos(v)) * Math.sin(u);
          const z = poloidalRadius * Math.sin(v);
          
          // Project 3D to 2D with perspective
          const scale = 200 / (200 + z);
          const screenX = centerX + x * scale;
          const screenY = centerY + y * scale * 0.5; // Flatten for top view
          
          // Add dynamic movement
          const phase = time + u * 0.5 + v * 0.5;
          const offset = Math.sin(phase) * 5;
          
          ctx.beginPath();
          ctx.arc(screenX + offset, screenY + offset, 1, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(80, 80, 80, ${0.3 * scale})`;
          ctx.fill();
        }
      }
      
      // Draw energy flow lines
      const flowLines = 20;
      for (let i = 0; i < flowLines; i++) {
        const angle = (i / flowLines) * Math.PI * 2;
        
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(80, 80, 80, 0.2)';
        ctx.lineWidth = 1;
        
        for (let t = 0; t < 1; t += 0.01) {
          const radius = toroidalRadius + poloidalRadius * Math.cos(t * Math.PI * 2 * 3 + time);
          const x = centerX + Math.cos(angle + t * Math.PI * 4) * radius;
          const y = centerY + Math.sin(angle + t * Math.PI * 4) * radius * 0.5;
          
          if (t === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
      }
      
      // Draw the enduring center that gives strength
      const vortexRadius = 30;
      ctx.beginPath();
      ctx.arc(centerX, centerY, vortexRadius, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(80, 80, 80, 0.5)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Vortex spiral
      ctx.beginPath();
      const spiralTurns = 3;
      for (let i = 0; i < 100; i++) {
        const t = i / 100;
        const angle = t * Math.PI * 2 * spiralTurns - time * 2;
        const radius = vortexRadius * (1 - t);
        
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.strokeStyle = 'rgba(80, 80, 80, 0.4)';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Add harmonic rings
      for (let r = 50; r < 250; r += 30) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, r + Math.sin(time + r * 0.01) * 5, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(80, 80, 80, 0.1)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      
      animationFrameId = requestAnimationFrame(animate);
    };
    
    animate();
    
    // Cleanup function that cancels the animation frame
    return () => {
      cancelAnimationFrame(animationFrameId);
      
      // Clear the canvas
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    };
  }, []);
  
  return (
    <div className="flex items-center justify-center w-full h-full" style={{ backgroundColor: '#F0EEE6' }}>
      <div className="w-[550px] h-[550px] shadow-lg rounded-lg overflow-hidden">
        <canvas 
          ref={canvasRef} 
          className="w-full h-full"
        />
      </div>
    </div>
  );
};

export default TorusFieldDynamics;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: source flows everywhere, silent fulfillment, humble greatness
// visualization: Waves flow silently in all directions, achieving greatness without recognition

export default function PhaseDistortionWaves() {
  const canvasRef = useRef(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    // Set canvas dimensions
    canvas.width = 550;
    canvas.height = 550;
    
    let t = 0;
    
    // Draw waves that silently fulfill their nature
    const drawWave = (yCenter, amplitude, frequency, phaseOffset, thickness) => {
      ctx.beginPath();
      
      // Draw wave path
      for (let x = 0; x < canvas.width; x++) {
        // Calculate phase distortion based on position and time (slowed down)
        const distortion = 
          Math.sin(x * 0.02 + t * 0.05) * 2 + 
          Math.cos(x * 0.01 - t * 0.03) * 3;
        
        // Apply distortion to base wave
        const y = yCenter + 
                 amplitude * Math.sin(x * frequency + t + phaseOffset + distortion);
        
        if (x === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      
      ctx.lineWidth = thickness;
      ctx.stroke();
    };
    
    let animationFrameId;
    const render = () => {
      // Clear canvas with specified background color
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.strokeStyle = 'rgba(51, 51, 51, 0.6)';
      
      // Draw multiple waves with different parameters
      const waveCount = 15;
      for (let i = 0; i < waveCount; i++) {
        const yCenter = 100 + (canvas.height - 200) * (i / (waveCount - 1));
        const amplitude = 10 + Math.sin(t * 0.025 + i * 0.3) * 5;
        const frequency = 0.02 + 0.01 * Math.sin(i * 0.2);
        const phaseOffset = i * 0.3;
        const thickness = 1 + Math.sin(t + i) * 0.5;
        
        drawWave(yCenter, amplitude, frequency, phaseOffset, thickness);
      }
      
      // Source flows in all directions with humble grace
      ctx.globalCompositeOperation = 'multiply';
      ctx.strokeStyle = 'rgba(51, 51, 51, 0.3)';
      
      for (let i = 0; i < waveCount; i++) {
        const xCenter = 100 + (canvas.width - 200) * (i / (waveCount - 1));
        const amplitude = 15 + Math.cos(t * 0.04 + i * 0.3) * 8;
        const frequency = 0.02 + 0.01 * Math.cos(i * 0.3);
        const phaseOffset = i * 0.4;
        const thickness = 1 + Math.cos(t + i) * 0.5;
        
        // Draw vertical waves
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(Math.PI / 2);
        ctx.translate(-canvas.width / 2, -canvas.height / 2);
        
        drawWave(xCenter, amplitude, frequency, phaseOffset, thickness);
        
        ctx.restore();
      }
      
      ctx.globalCompositeOperation = 'source-over';
      
      t += 0.004;
      animationFrameId = requestAnimationFrame(render);
    };
    
    render();
    
    return () => {
      // Cleanup
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    };
  }, []);
  
  return (
    <div 
      className="w-full h-screen flex items-center justify-center"
      style={{ backgroundColor: '#F0EEE6' }}
    >
      <div 
        style={{ width: '550px', height: '550px' }}
        className="border border-gray-200 rounded-md shadow-md"
      >
        <canvas 
          ref={canvasRef} 
          className="w-full h-full rounded-md"
        />
      </div>
    </div>
  );
}
```

```javascript
import React, { useState, useEffect, useRef } from 'react';

// themes: connection to source, universal harmony, inexhaustible use
// visualization: Patterns emerge endlessly from source, finding harmony in constant transformation

const patterns = {
  // Pattern finding harmony in connection to source
  balance: (x, y, t) => {
    const cx = 30;
    const cy = 15;
    const dx = x - cx;
    const dy = y - cy;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    return Math.sin(dx * 0.3 + t * 0.5) * Math.cos(dy * 0.3 + t * 0.3) * 
           Math.sin(dist * 0.1 - t * 0.4);
  },
  
  duality: (x, y, t) => {
    const cx = 30;
    const left = x < cx ? Math.sin(x * 0.2 + t * 0.3) : 0;
    const right = x >= cx ? Math.cos(x * 0.2 - t * 0.3) : 0;
    
    return left + right + Math.sin(y * 0.3 + t * 0.2);
  },
  
  flow: (x, y, t) => {
    const angle = Math.atan2(y - 15, x - 30);
    const dist = Math.sqrt((x - 30) ** 2 + (y - 15) ** 2);
    
    return Math.sin(angle * 3 + t * 0.4) * Math.cos(dist * 0.1 - t * 0.3);
  },
  
  chaos: (x, y, t) => {
    const noise1 = Math.sin(x * 0.5 + t) * Math.cos(y * 0.3 - t);
    const noise2 = Math.sin(y * 0.4 + t * 0.5) * Math.cos(x * 0.2 + t * 0.7);
    const noise3 = Math.sin((x + y) * 0.2 + t * 0.8);
    
    return noise1 * 0.3 + noise2 * 0.3 + noise3 * 0.4;
  }
};

const BlackWhiteBlobs = () => {
  const [frame, setFrame] = useState(0);
  const [patternType, setPatternType] = useState(0);
  const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
  const [mouseDown, setMouseDown] = useState(false);
  const containerRef = useRef(null);
  
  const patternTypes = ['balance', 'duality', 'flow', 'chaos'];
  const width = 60;
  const height = 35;
  const slowdownFactor = 12; // Quadrupled from original speed of 3
  
  // Background color as specified in requirements
  const BACKGROUND_COLOR = '#F0EEE6';
  
  useEffect(() => {
    let animationId;
    
    const animate = () => {
      setFrame(f => (f + 1) % (240 * slowdownFactor));
      animationId = requestAnimationFrame(animate);
    };
    
    animationId = requestAnimationFrame(animate);
    
    return () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
    };
  }, [slowdownFactor]);
  
  // Generate inexhaustible variations from universal harmony
  const generateAsciiArt = () => {
    const t = (frame * Math.PI) / (60 * slowdownFactor);
    const currentPattern = patterns[patternTypes[patternType]];
    let result = '';
    
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        let value = currentPattern(x, y, t);
        
        if (mouseDown && containerRef.current) {
          const rect = containerRef.current.getBoundingClientRect();
          const dx = x - (((mousePos.x - rect.left) / rect.width) * width);
          const dy = y - (((mousePos.y - rect.top) / rect.height) * height);
          const dist = Math.sqrt(dx * dx + dy * dy);
          const mouseInfluence = Math.exp(-dist * 0.1) * Math.sin(t * 2);
          value += mouseInfluence * 0.8;
        }
        
        if (value > 0.8) {
          result += '█';
        } else if (value > 0.5) {
          result += '▓';
        } else if (value > 0.2) {
          result += '▒';
        } else if (value > -0.2) {
          result += '░';
        } else if (value > -0.5) {
          result += '·';
        } else {
          result += ' ';
        }
      }
      result += '\n';
    }
    
    return result;
  };
  
  const handleClick = () => {
    setPatternType((prev) => (prev + 1) % patternTypes.length);
  };
  
  const handleMouseMove = (e) => {
    setMousePos({ x: e.clientX, y: e.clientY });
  };
  
  const handleMouseDown = () => {
    setMouseDown(true);
  };
  
  const handleMouseUp = () => {
    setMouseDown(false);
  };
  
  return (
    <div 
      style={{ 
        margin: 0,
        padding: 0,
        background: BACKGROUND_COLOR,
        overflow: 'hidden',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        height: '100%'
      }}
      onMouseMove={handleMouseMove}
      onMouseDown={handleMouseDown}
      onMouseUp={handleMouseUp}
      onClick={handleClick}
      ref={containerRef}
    >
      <pre style={{
        fontFamily: 'monospace',
        fontSize: '12px',
        lineHeight: '1',
        letterSpacing: '0.1em',
        color: '#333',
        userSelect: 'none',
        cursor: 'pointer',
        margin: 0,
        padding: 0
      }}>
        {generateAsciiArt()}
      </pre>
    </div>
  );
};

export default BlackWhiteBlobs;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: shrink to expand, weaken to strengthen, subtle perception
// visualization: Forms contract to find expansion, discovering strength through yielding

const ParticleReverie = () => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Parameters
    const numParticles = 5000;
    let time = 65;
    let startTime = Date.now();
    
    // Pre-calculate initial state to match frame 65 exactly
    const initialT = 65;
    
    // Create particles in a formation that matches frame 65 exactly
    const particles = Array(numParticles).fill().map((_, i) => {
      const angle1 = (i / numParticles) * Math.PI * 2;
      const angle2 = Math.random() * Math.PI * 2;
      
      // Base shape parameters
      const baseScale = 120;
      
      // Initial organic shape - matching exactly the shape at frame 65
      const initialMorphFactor = Math.sin(initialT * 0.2) * 0.5 + 0.5;
      
      // Calculate shape 1 position at frame 65
      const r1 = baseScale * (1 + 0.3 * Math.sin(angle1 * 2));
      const shape1X = r1 * Math.cos(angle1) * (1 + 0.2 * Math.sin(angle1 * 3 + initialT * 0.1));
      const shape1Y = r1 * Math.sin(angle1) * (1 + 0.4 * Math.cos(angle1 * 3 + initialT * 0.2));
      
      // Calculate shape 2 position at frame 65
      const r2 = baseScale * (1 + 0.4 * Math.sin(angle2 * 3));
      const shape2X = r2 * Math.cos(angle2) * (1 + 0.3 * Math.sin(angle2 * 2 + initialT * 0.15));
      const shape2Y = r2 * Math.sin(angle2) * (1 + 0.2 * Math.cos(angle2 * 4 + initialT * 0.25));
      
      // Position using same calculation as in calculateTargets
      let x = width/2 + (shape1X * (1 - initialMorphFactor) + shape2X * initialMorphFactor);
      let y = height/2 + (shape1Y * (1 - initialMorphFactor) + shape2Y * initialMorphFactor);
      
      // Add bulge effect
      const initialBulgeAmount = 50 * (Math.sin(initialT * 0.3) * 0.2 + 0.8);
      const bulgeX = initialBulgeAmount * Math.exp(-Math.pow(angle1 - Math.PI * 0.5, 2));
      const bulgeY = initialBulgeAmount * 0.5 * Math.exp(-Math.pow(angle1 - Math.PI * 0.5, 2));
      
      x += bulgeX * Math.sin(initialT * 0.4);
      y += bulgeY * Math.cos(initialT * 0.3);
      
      return {
        x,
        y,
        size: Math.random() * 1.5 + 0.5,
        connections: [],
        targetX: 0,
        targetY: 0,
        vx: 0,
        vy: 0,
        angle: angle2
      };
    });
    
    // Calculate how forms must contract to find expansion
    const calculateTargets = (t) => {
      // Calculate animation time separately to create gradual startup
      const animationTime = t - 65 + animationStartTime;
      
      // Gentle startup for morphFactor - starts at actual value but changes smoothly
      const startupEasing = Math.min(1, animationTime / 10); // Ramp up over first 10 time units
      const morphFactor = Math.sin(t * 0.2) * 0.5 + 0.5; // Value between 0 and 1 for morphing
      
      particles.forEach((particle, i) => {
        // Angle for this particle
        const angle1 = (i / numParticles) * Math.PI * 2;
        const angle2 = particle.angle;
        
        // Base shape parameters
        const baseScale = 120;
        const bulgeAmount = 50 * (Math.sin(t * 0.3) * 0.2 + 0.8);
        
        // Shape 1: Organic blob - use startup easing for time-based terms
        const timeEffect1 = t + (animationTime * startupEasing * 0.1); // Gradually introduce time-based movement
        const r1 = baseScale * (1 + 0.3 * Math.sin(angle1 * 2));
        const shape1X = r1 * Math.cos(angle1) * (1 + 0.2 * Math.sin(angle1 * 3 + timeEffect1 * 0.1));
        const shape1Y = r1 * Math.sin(angle1) * (1 + 0.4 * Math.cos(angle1 * 3 + timeEffect1 * 0.2));
        
        // Shape 2: Different organic form - use startup easing for time-based terms
        const timeEffect2 = t + (animationTime * startupEasing * 0.1); // Gradually introduce time-based movement
        const r2 = baseScale * (1 + 0.4 * Math.sin(angle2 * 3));
        const shape2X = r2 * Math.cos(angle2) * (1 + 0.3 * Math.sin(angle2 * 2 + timeEffect2 * 0.15));
        const shape2Y = r2 * Math.sin(angle2) * (1 + 0.2 * Math.cos(angle2 * 4 + timeEffect2 * 0.25));
        
        // Morph between shapes
        particle.targetX = shape1X * (1 - morphFactor) + shape2X * morphFactor;
        particle.targetY = shape1Y * (1 - morphFactor) + shape2Y * morphFactor;
        
        // Add bulge effect - also ease in the time-based movement
        const bulgeX = bulgeAmount * Math.exp(-Math.pow(angle1 - Math.PI * 0.5, 2));
        const bulgeY = bulgeAmount * 0.5 * Math.exp(-Math.pow(angle1 - Math.PI * 0.5, 2));
        
        // Apply startup easing to bulge movement
        particle.targetX += bulgeX * Math.sin(timeEffect1 * 0.4);
        particle.targetY += bulgeY * Math.cos(timeEffect1 * 0.3);
        
        // Add noise for more organic feel
        particle.targetX += (Math.random() - 0.5) * 5;
        particle.targetY += (Math.random() - 0.5) * 5;
      });
    };
    
    // Animation runtime - separate from initialization time
    let animationStartTime = 0;
        
    // Function to update particle positions
    const updateParticles = () => {
      // Calculate animation time separately to create gradual startup
      const animationTime = time - 65 + animationStartTime;
      
      particles.forEach(particle => {
        // Direct interpolation instead of spring physics
        const dx = particle.targetX - (particle.x - width/2);
        const dy = particle.targetY - (particle.y - height/2);
        
        // Gentle linear interpolation (lerp) with gradual startup
        // Start with very slow easing that gradually increases to normal speed
        const startupPhase = Math.min(1, animationTime / 5); // Ramp up over first 5 time units 
        const easing = 0.01 + (0.02 * startupPhase); // Gradually increase from 0.01 to 0.03
        
        particle.x += dx * easing;
        particle.y += dy * easing;
        
        // Reset connections
        particle.connections = [];
      });
    };
    
    // Perceive subtle connections that create strength
    const calculateConnections = () => {
      const maxDist = 25;
      const maxConnections = 3;
      
      for (let i = 0; i < particles.length; i++) {
        const p1 = particles[i];
        
        // Limit connections per particle for performance
        if (p1.connections.length >= maxConnections) continue;
        
        for (let j = i + 1; j < particles.length; j++) {
          const p2 = particles[j];
          
          // Skip if second particle already has max connections
          if (p2.connections.length >= maxConnections) continue;
          
          // Calculate distance
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          // Connect if close enough and not too many connections
          if (dist < maxDist) {
            p1.connections.push(j);
            p2.connections.push(i);
            
            // Break if max connections reached
            if (p1.connections.length >= maxConnections) break;
          }
        }
      }
    };
    
    // Function to draw everything
    const draw = () => {
      // Clear canvas with background color
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, width, height);
      
      // Draw connections first (below particles)
      ctx.strokeStyle = 'rgba(51, 51, 51, 0.2)';
      ctx.lineWidth = 0.5;
      
      for (let i = 0; i < particles.length; i++) {
        const p1 = particles[i];
        
        for (let j = 0; j < p1.connections.length; j++) {
          const p2 = particles[p1.connections[j]];
          
          // Draw line
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          
          // Add slight curve to lines
          const midX = (p1.x + p2.x) / 2;
          const midY = (p1.y + p2.y) / 2;
          const offset = 5 * Math.sin(time * 0.5 + i * 0.01);
          
          ctx.quadraticCurveTo(
            midX + offset, 
            midY + offset, 
            p2.x, 
            p2.y
          );
          
          ctx.stroke();
        }
      }
      
      // Draw particles
      particles.forEach(particle => {
        const distFromCenter = Math.sqrt(
          Math.pow(particle.x - width/2, 2) + 
          Math.pow(particle.y - height/2, 2)
        );
        
        // Opacity based on distance from center for 3D effect
        const opacity = Math.max(0.1, 1 - distFromCenter / 300);
        
        ctx.fillStyle = `rgba(51, 51, 51, ${opacity})`;
        ctx.beginPath();
        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        ctx.fill();
      });
    };
    
    // Animation loop with requestAnimationFrame
    let animationFrameId = null;
    let lastFrameTime = 0;
    const targetFPS = 36; // 36fps for enhanced smoothness
    const frameInterval = 1000 / targetFPS;
    
    const animate = (currentTime) => {
      animationFrameId = requestAnimationFrame(animate);
      
      const deltaTime = currentTime - lastFrameTime;
      
      // Only update if enough time has passed
      if (deltaTime >= frameInterval) {
        // Calculate remainder to prevent drift
        const remainder = deltaTime % frameInterval;
        
        // Update lastFrameTime with the time that's been processed
        lastFrameTime = currentTime - remainder;
        
        time += 0.005; // Back to original speed
        
        // Calculate new target positions
        calculateTargets(time);
        
        // Update particle positions
        updateParticles();
        
        // Calculate connections
        calculateConnections();
        
        // Draw everything
        draw();
      }
    };
    
    // Start animation
    animationFrameId = requestAnimationFrame(animate);
    
    return () => {
      // Cancel animation frame to prevent memory leaks
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, width, height);
      }
      
      // Clear particles array to prevent memory leaks
      particles.length = 0;
    };
  }, []);

  return (
    <div className="flex justify-center items-center bg-[#F0EEE6] w-full h-full">
      <canvas 
        ref={canvasRef} 
        width={550} 
        height={550} 
        className="max-w-full max-h-full"
      />
    </div>
  );
};

export default ParticleReverie;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: source does nothing, natural development, peace through tranquility
// visualization: Waves emerge naturally from an unmoving center, finding peace in their flow

const WaveInterferenceV5 = () => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = 550;
    const height = 550;
    canvas.width = width;
    canvas.height = height;

    // Radial arrangement with central focus (fewer sources for better performance)
    const sources = [];
    const numRings = 2; // Reduced from 3
    const sourcesPerRing = 6; // Reduced from 8
    
    // Unmoving source from which all emerges
    sources.push({
      x: width/2,
      y: height/2,
      wavelength: 25,
      phase: 0,
      amplitude: 1.5
    });
    
    // Radial sources
    for (let ring = 1; ring <= numRings; ring++) {
      const radius = ring * 120; // Increased spacing
      const numSources = sourcesPerRing;
      
      for (let i = 0; i < numSources; i++) {
        const angle = (i / numSources) * Math.PI * 2;
        sources.push({
          x: width/2 + Math.cos(angle) * radius,
          y: height/2 + Math.sin(angle) * radius,
          wavelength: 20 + ring * 5,
          phase: (i / numSources) * Math.PI,
          amplitude: 1.0 - ring * 0.2
        });
      }
    }

    let time = 0;
    let animationFrameId;
    
    // Precompute constants
    const TWO_PI = Math.PI * 2;
    const INV_300 = 1 / 300;
    
    // Throttle calculation to skip frames for better performance
    let frameCount = 0;
    const skipFrames = 1; // Render every other frame

    const animate = () => {
      frameCount++;
      
      if (frameCount % (skipFrames + 1) !== 0) {
        time += 0.0015; // Reduced from 0.0025 for slower animation
        animationFrameId = requestAnimationFrame(animate);
        return;
      }
      
      // Fill with project background color
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, width, height);

      // Lower resolution field for better performance
      const resolution = 3; // Increased from 1
      const rows = Math.floor(height / resolution);
      const cols = Math.floor(width / resolution);
      const field = new Array(rows).fill(0).map(() => new Array(cols).fill(0));

      // Let patterns develop naturally, finding their peace
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const x = j * resolution;
          const y = i * resolution;
          let amplitude = 0;

          sources.forEach(source => {
            const dx = x - source.x;
            const dy = y - source.y;
            const dist2 = dx * dx + dy * dy;
            const distance = Math.sqrt(dist2);
            
            // Skip if too far from source
            if (distance > 400) return;
            
            // Apply amplitude falloff (optimized)
            const falloff = Math.exp(-distance * INV_300);
            amplitude += source.amplitude * falloff * 
              Math.sin((distance / source.wavelength - time) * TWO_PI + source.phase);
          });

          field[i][j] = amplitude;
        }
      }

      // Simplified line rendering
      ctx.strokeStyle = '#333';
      
      // Fewer contour levels
      const contourLevels = [-0.8, -0.4, 0, 0.4, 0.8];
      
      contourLevels.forEach((level, index) => {
        // Vary line width based on contour level
        ctx.lineWidth = index % 2 === 0 ? 0.8 : 0.5;
        ctx.beginPath();
        
        for (let i = 0; i < rows - 1; i++) {
          for (let j = 0; j < cols - 1; j++) {
            const x = j * resolution;
            const y = i * resolution;
            
            // Optimized marching squares
            const v00 = field[i][j];
            const v10 = field[i][j + 1];
            const v11 = field[i + 1][j + 1];
            const v01 = field[i + 1][j];
            
            // Early exit optimization
            const allAbove = v00 > level && v10 > level && v11 > level && v01 > level;
            const allBelow = v00 <= level && v10 <= level && v11 <= level && v01 <= level;
            if (allAbove || allBelow) continue;
            
            const case4 = 
              (v00 > level ? 8 : 0) +
              (v10 > level ? 4 : 0) +
              (v11 > level ? 2 : 0) +
              (v01 > level ? 1 : 0);
            
            // Simplified linear interpolation
            const lerp = (a, b, t) => a + t * (b - a);
            const safeDiv = (a, b) => b === 0 ? 0 : a / b;
            
            switch (case4) {
              case 1: case 14: {
                const t1 = safeDiv(level - v00, v01 - v00);
                const t2 = safeDiv(level - v01, v11 - v01);
                ctx.moveTo(x, lerp(y, y + resolution, t1));
                ctx.lineTo(lerp(x, x + resolution, t2), y + resolution);
                break;
              }
              case 2: case 13: {
                const t1 = safeDiv(level - v01, v11 - v01);
                const t2 = safeDiv(level - v11, v10 - v11);
                ctx.moveTo(lerp(x, x + resolution, t1), y + resolution);
                ctx.lineTo(x + resolution, lerp(y + resolution, y, t2));
                break;
              }
              case 3: case 12: {
                const t1 = safeDiv(level - v00, v01 - v00);
                const t2 = safeDiv(level - v10, v11 - v10);
                ctx.moveTo(x, lerp(y, y + resolution, t1));
                ctx.lineTo(x + resolution, lerp(y, y + resolution, t2));
                break;
              }
              case 4: case 11: {
                const t1 = safeDiv(level - v10, v11 - v10);
                const t2 = safeDiv(level - v10, v00 - v10);
                ctx.moveTo(x + resolution, lerp(y, y + resolution, t1));
                ctx.lineTo(lerp(x + resolution, x, t2), y);
                break;
              }
              case 5: case 10: {
                // Two lines for saddle points
                const t1 = safeDiv(level - v00, v01 - v00);
                const t2 = safeDiv(level - v00, v10 - v00);
                ctx.moveTo(x, lerp(y, y + resolution, t1));
                ctx.lineTo(lerp(x, x + resolution, t2), y);
                
                const t3 = safeDiv(level - v11, v10 - v11);
                const t4 = safeDiv(level - v11, v01 - v11);
                ctx.moveTo(x + resolution, lerp(y + resolution, y, t3));
                ctx.lineTo(lerp(x + resolution, x, t4), y + resolution);
                break;
              }
              case 6: case 9: {
                const t1 = safeDiv(level - v10, v00 - v10);
                const t2 = safeDiv(level - v11, v01 - v11);
                ctx.moveTo(lerp(x + resolution, x, t1), y);
                ctx.lineTo(lerp(x + resolution, x, t2), y + resolution);
                break;
              }
              case 7: case 8: {
                const t1 = safeDiv(level - v00, v01 - v00);
                const t2 = safeDiv(level - v00, v10 - v00);
                ctx.moveTo(x, lerp(y, y + resolution, t1));
                ctx.lineTo(lerp(x, x + resolution, t2), y);
                break;
              }
            }
          }
        }
        
        ctx.stroke();
      });

      time += 0.0015; // Reduced from 0.0025 for slower animation
      animationFrameId = requestAnimationFrame(animate);
    };

    animationFrameId = requestAnimationFrame(animate);

    return () => {
      // Cancel the animation frame
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      // Clear main canvas
      if (ctx) {
        ctx.clearRect(0, 0, width, height);
      }
      
      // Clear buffer canvas
      if (bufferCtx) {
        bufferCtx.clearRect(0, 0, width, height);
        bufferCanvas.width = 0;
        bufferCanvas.height = 0;
      }
      
      // Clear arrays to prevent memory leaks
      sources.length = 0;
    };
  }, []);

  return (
    <div style={{ 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center',
      width: '100vw', 
      height: '100vh', 
      backgroundColor: '#F0EEE6' 
    }}>
      <canvas 
        ref={canvasRef} 
        style={{ 
          border: '1px solid #eee',
          width: '550px',
          height: '550px'
        }} 
      />
    </div>
  );
};

export default WaveInterferenceV5;
```

```javascript
import { useEffect, useRef } from 'react';

// Themes: paradox of wisdom, hidden truth beneath appearances, embracing contradictions
// Visualization: An ASCII mandala that reveals complex patterns through simple characters, embodying how profound wisdom often appears deceptively simple

const AnimatedAsciiMandala = () => {
  const [frame, setFrame] = useState(0);
  const [asciiGrid, setAsciiGrid] = useState([]);
  const requestRef = useRef();
  const mountedRef = useRef(true);
  const canvasRef = useRef(null);
  
  // The path into light begins with simple forms
  const width = 80;  // Characters across
  const height = 44; // Characters down
  const density = '.·•○●'; // From emptiness to fullness
  
  // Initialize grid on component mount
  useEffect(() => {
    // Create empty grid
    const grid = Array(height).fill().map(() => Array(width).fill(' '));
    setAsciiGrid(grid);
    
    // Animation loop
    const animate = () => {
      if (mountedRef.current) {
        setFrame(prevFrame => prevFrame + 1);
        requestRef.current = requestAnimationFrame(animate);
      }
    };
    requestRef.current = requestAnimationFrame(animate);
    
    return () => {
      mountedRef.current = false;
      if (requestRef.current) {
        cancelAnimationFrame(requestRef.current);
      }
      requestRef.current = null;
      
      // Clear state to prevent memory leaks
      setAsciiGrid([]);
    };
  }, []);
  
  // Update ASCII grid based on animation frame
  useEffect(() => {
    // Only update if component is still mounted
    if (!mountedRef.current) return;
    
    // Create a new empty grid
    const newGrid = Array(height).fill().map(() => Array(width).fill(' '));
    
    // Draw patterns
    drawMandala(newGrid, frame);
    
    if (mountedRef.current) {
      setAsciiGrid(newGrid);
    }
  }, [frame]);
  
  // What seems unsophisticated holds the greatest wisdom
  const drawMandala = (grid, frame) => {
    const centerX = Math.floor(width / 2);  // Finding the still point
    const centerY = Math.floor(height / 2);  // Where opposites meet
    
    // Draw central line
    for (let y = 1; y < height - 1; y++) {
      const lineOpacity = 0.3 + Math.sin(frame * 0.005 + y * 0.1) * 0.1;
      if (lineOpacity > 0.2) {
        grid[y][centerX] = '|';
      }
    }
    
    // Draw central circular pattern
    drawCirclePattern(grid, centerX, centerY, frame);
    
    // Draw radiating patterns
    const numPatterns = 6;
    for (let i = 0; i < numPatterns; i++) {
      const radius = 5 + i * 3;
      const points = 6 + i * 2;
      
      for (let j = 0; j < points; j++) {
        const angle = (j / points) * Math.PI * 2;
        const breathingFactor = 0.2 * Math.sin(frame * 0.025 + i * 0.5 + j * 0.2);
        const x = Math.round(centerX + Math.cos(angle) * (radius + breathingFactor * radius));
        const y = Math.round(centerY + Math.sin(angle) * (radius + breathingFactor * radius));
        
        if (x >= 0 && x < width && y >= 0 && y < height) {
          // Intensity based on animation frame
          const intensityPhase = (Math.sin(frame * 0.015 + i * 0.4 + j * 0.8) + 1) / 2;
          const char = getCharForIntensity(intensityPhase);
          grid[y][x] = char;
          
          // Mirror on the other side for symmetry
          const mirrorX = 2 * centerX - x;
          if (mirrorX >= 0 && mirrorX < width) {
            grid[y][mirrorX] = char;
          }
        }
        
        // Add secondary points
        if (i > 0 && j % 2 === 0) {
          const secondaryRadius = radius * 0.7;
          const x2 = Math.round(centerX + Math.cos(angle + 0.2) * secondaryRadius);
          const y2 = Math.round(centerY + Math.sin(angle + 0.2) * secondaryRadius);
          
          if (x2 >= 0 && x2 < width && y2 >= 0 && y2 < height) {
            const intensityPhase = (Math.sin(frame * 0.025 + i * 0.3 + j) + 1) / 2;
            const char = getCharForIntensity(intensityPhase * 0.8);
            grid[y2][x2] = char;
            
            // Mirror
            const mirrorX2 = 2 * centerX - x2;
            if (mirrorX2 >= 0 && mirrorX2 < width) {
              grid[y2][mirrorX2] = char;
            }
          }
        }
      }
    }
    
    // Add connection lines between points
    for (let i = 0; i < 40; i++) {
      const angle = (i / 40) * Math.PI;
      const radius = 10 + i % 5 * 3;
      const x = Math.round(centerX + Math.cos(angle) * radius);
      const y = Math.round(centerY + Math.sin(angle) * radius);
      
      if (x >= 0 && x < width && y >= 0 && y < height) {
        // Only draw if the cell is empty
        if (grid[y][x] === ' ') {
          const intensityPhase = (Math.sin(frame * 0.02 + i * 0.2) + 1) / 3;
          const char = getCharForIntensity(intensityPhase);
          if (char !== ' ') {
            grid[y][x] = char;
            
            // Mirror
            const mirrorX = 2 * centerX - x;
            if (mirrorX >= 0 && mirrorX < width && grid[y][mirrorX] === ' ') {
              grid[y][mirrorX] = char;
            }
          }
        }
      }
    }
  };
  
  // Draw central circular pattern
  const drawCirclePattern = (grid, centerX, centerY, frame) => {
    // Center point
    const centerIntensity = (Math.sin(frame * 0.025) + 1) / 2;
    grid[centerY][centerX] = getCharForIntensity(centerIntensity, true);
    
    // Draw circular patterns
    for (let r = 0; r < 3; r++) {
      const radius = 2 + r * 2;
      const points = 8 + r * 4;
      
      for (let i = 0; i < points; i++) {
        const angle = (i / points) * Math.PI * 2;
        const breathingFactor = 0.2 * Math.sin(frame * 0.025 + r + i * 0.1);
        const x = Math.round(centerX + Math.cos(angle) * (radius + breathingFactor));
        const y = Math.round(centerY + Math.sin(angle) * (radius + breathingFactor));
        
        if (x >= 0 && x < width && y >= 0 && y < height) {
          const intensityPhase = (Math.sin(frame * 0.02 + r * 0.3 + i * 0.2) + 1) / 2;
          grid[y][x] = getCharForIntensity(intensityPhase, true);
        }
      }
    }
  };
  
  // The perfect form has no shape, yet shapes arise from emptiness
  const getCharForIntensity = (intensity, isCenter = false) => {
    if (intensity < 0.1) return ' ';  // The void that contains all possibilities
    
    // For center elements, use more prominent characters
    if (isCenter) {
      // For center, map to higher density characters
      const index = Math.min(Math.floor(intensity * density.length), density.length - 1);
      return density[Math.max(index, 2)]; // Always use at least '•' for center
    } else {
      const index = Math.min(Math.floor(intensity * density.length), density.length - 1);
      return density[index];
    }
  };

  return (
    <div style={{
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center',
      width: '550px',
      height: '550px',
      backgroundColor: '#F0EEE6',
      overflow: 'hidden',
      padding: '10px',
      borderRadius: '8px',
      boxShadow: 'inset 0 0 10px rgba(0,0,0,0.05)'
    }}>
      <pre style={{
        fontFamily: 'monospace',
        fontSize: '12px',
        lineHeight: '1.2em',
        letterSpacing: '0.1em',
        textAlign: 'center',
        color: '#333',
        margin: 0
      }}>
        {asciiGrid.map((row, i) => (
          <div key={i}>
            {row.map((char, j) => {
              // Calculate color based on character
              let opacity = 1.0;
              switch (char) {
                case '●': opacity = 0.9; break;
                case '○': opacity = 0.7; break;
                case '•': opacity = 0.6; break;
                case '·': opacity = 0.5; break;
                case '.': opacity = 0.4; break;
                case '|': opacity = 0.3; break;
                case ' ': opacity = 0; break;
              }
              
              return (
                <span 
                  key={j} 
                  style={{
                    color: `rgba(50, 50, 50, ${opacity})`,
                    display: 'inline-block',
                    width: '0.6em'  // Fixed width for better alignment
                  }}
                >
                  {char}
                </span>
              );
            })}
          </div>
        ))}
      </pre>
    </div>
  );
};

export default AnimatedAsciiMandala;
```

```javascript
import React, { useEffect, useRef } from 'react'

// Themes: creation from unity, harmony of opposites, cyclical emergence
// Visualization: ASCII patterns that emerge from simple elements combining and recombining, reflecting how the many arise from the One

const metadata = {
  themes: "creation from unity, harmony of opposites, cyclical emergence",
  visualization: "ASCII patterns emerging from simple elements combining and recombining",
  promptSuggestion: "1. Adjust wave frequency\n2. Change pattern density\n3. Try different slash characters\n4. Modify interference angles\n5. Add phase variations"
}

// The One manifests through these three forms
const CHARS = '/\\|'

// The space in which the many emerge
const GRID_SIZE = 90

const AsciiDiagonalPetals: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null)

  useEffect(() => {
    const canvas = canvasRef.current
    if (!canvas) return

    const ctx = canvas.getContext('2d')
    if (!ctx) return

    let time = 0
    let animationFrameId: number | null = null

    // Calculate grid dimensions based on canvas
    const cellSize = 15
    const charWidth = cellSize * 0.7
    const charHeight = cellSize

    // Animation loop
    const animate = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      
      // Fill background
      ctx.fillStyle = '#F0EEE6'
      ctx.fillRect(0, 0, canvas.width, canvas.height)
      
      // Set text style
      ctx.font = `${cellSize}px monospace`
      ctx.textAlign = 'center'
      ctx.textBaseline = 'middle'
      ctx.fillStyle = '#333333'
      
      // Draw grid
      for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
          // Two forces in harmony create movement
          const wave1 = Math.sin((x + y) / 4 + time)
          const wave2 = Math.cos((x - y) / 4 - time * 0.7)
          
          // The boundary between being and non-being
          const boundaryX = Math.abs(x - GRID_SIZE/2) / (GRID_SIZE/2)
          const boundaryY = Math.abs(y - GRID_SIZE/2) / (GRID_SIZE/2)
          const boundary = Math.max(boundaryX, boundaryY)  // Where form meets formlessness
          
          if (boundary < 0.85) {
            // Combine waves with different weights
            const combined = wave1 * 0.6 + wave2 * 0.4
            
            // Add boundary fade
            const fade = 1 - (boundary / 0.85)
            const value = combined * fade
            
            // From Three, the ten thousand things arise
            let char = ' '
            if (value > 0.3) char = CHARS[0]      // Yang rises
            else if (value < -0.3) char = CHARS[1]     // Yin descends
            else if (Math.abs(value) < 0.1) char = CHARS[2] // Balance point
            
            if (char !== ' ') {
              const xPos = (canvas.width / 2) + (x - GRID_SIZE/2) * charWidth
              const yPos = (canvas.height / 2) + (y - GRID_SIZE/2) * charHeight
              ctx.fillText(char, xPos, yPos)
            }
          }
        }
      }
      
      time += 0.0075
      animationFrameId = requestAnimationFrame(animate)
    }

    // Start animation
    animationFrameId = requestAnimationFrame(animate)

    // Cleanup
    return () => {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId)
      }
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height)
      }
    }
  }, [])

  return (
    <div style={{ 
      margin: 0,
      background: '#F0EEE6',
      overflow: 'hidden',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      height: '100%',
      width: '100%'
    }}>
      <canvas 
        ref={canvasRef}
        width={800}
        height={800}
        style={{
          maxWidth: '100%',
          maxHeight: '100%',
          objectFit: 'contain'
        }}
      />
    </div>
  )
}

AsciiDiagonalPetals.metadata = metadata
export default AsciiDiagonalPetals
```

```javascript
import React, { useEffect, useRef } from 'react';
import * as THREE from 'three';

// Themes: power of softness, entering the void, non-action's effectiveness
// Visualization: A delicate constellation that appears through empty space, showing how the gentlest connections create the strongest patterns

const PineconeConstellation = () => {
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!containerRef.current) return;
    
    // The void from which form emerges
    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#F0EEE6');
    
    // The space through which we perceive
    const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    camera.position.z = 10;
    camera.position.y = 0;
    
    // The bridge between emptiness and form
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(550, 550);
    containerRef.current.appendChild(renderer.domElement);
    
    // Create main group
    const pineCone = new THREE.Group();
    
    // Track all created geometries and materials for proper cleanup
    const geometries: THREE.BufferGeometry[] = [];
    const materials: THREE.Material[] = [];
    const meshes: THREE.Mesh[] = [];
    const lines: THREE.Line[] = [];
    
    // Create constellation points
    const layers = 45;
    const pointsPerLayer = 12;
    
    // Store all vertices for creating connections
    const vertices: THREE.Vector3[] = [];
    
    // Shape inverted - narrower at top, wider at bottom
    for (let layer = 0; layer < layers; layer++) {
      const yPosition = (layer / layers) * 18 - 9;
      let layerRadius;
      
      if (layer < 10) {
        // Narrow top
        layerRadius = 3.5 * (layer / 10) * 0.7;
      } else if (layer < 35) {
        // Middle to bottom expansion
        layerRadius = 2.45 + Math.sin(((layer - 10) / 25) * Math.PI) * 1.8;
      } else {
        // Dome-like bottom
        layerRadius = Math.sin(((layers - layer) / 10) * Math.PI * 0.5) * 2;
      }
      
      const taper = 1 - (layer / layers) * 0.3;
      
      for (let i = 0; i < pointsPerLayer; i++) {
        const angle = (i / pointsPerLayer) * Math.PI * 2 + (layer * 0.2);
        
        const x = Math.cos(angle) * layerRadius * taper;
        const z = Math.sin(angle) * layerRadius * taper;
        
        vertices.push(new THREE.Vector3(x, yPosition, z));
        
        // Create dot geometry
        const dotGeometry = new THREE.SphereGeometry(0.03, 8, 8);
        geometries.push(dotGeometry);
        
        const dotMaterial = new THREE.MeshBasicMaterial({ 
          color: '#888888'
        });
        materials.push(dotMaterial);
        
        const dot = new THREE.Mesh(dotGeometry, dotMaterial);
        meshes.push(dot);
        
        dot.position.set(x, yPosition, z);
        pineCone.add(dot);
      }
    }
    
    // The softest connections become the strongest bonds
    const lineMaterial = new THREE.LineBasicMaterial({
      color: '#999999',
      transparent: true,
      opacity: 0.3  // Gentle presence
    });
    materials.push(lineMaterial);
    
    // Through non-action, patterns emerge
    for (let layer = 0; layer < layers; layer++) {
      const startIdx = layer * pointsPerLayer;
      const linePoints = [];
      
      for (let i = 0; i < pointsPerLayer; i++) {
        linePoints.push(vertices[startIdx + i]);
      }
      linePoints.push(vertices[startIdx]); // Close the loop
      
      const geometry = new THREE.BufferGeometry().setFromPoints(linePoints);
      geometries.push(geometry);
      
      const line = new THREE.Line(geometry, lineMaterial);
      lines.push(line);
      pineCone.add(line);
    }
    
    // Connect points between layers
    for (let i = 0; i < pointsPerLayer; i++) {
      const linePoints = [];
      
      for (let layer = 0; layer < layers; layer++) {
        linePoints.push(vertices[layer * pointsPerLayer + i]);
      }
      
      const geometry = new THREE.BufferGeometry().setFromPoints(linePoints);
      geometries.push(geometry);
      
      const line = new THREE.Line(geometry, lineMaterial);
      lines.push(line);
      pineCone.add(line);
    }
    
    // Add diagonal connections for structure
    for (let layer = 0; layer < layers - 1; layer++) {
      for (let i = 0; i < pointsPerLayer; i++) {
        const currentIdx = layer * pointsPerLayer + i;
        const nextLayerIdx = (layer + 1) * pointsPerLayer + ((i + 1) % pointsPerLayer);
        
        const linePoints = [vertices[currentIdx], vertices[nextLayerIdx]];
        const geometry = new THREE.BufferGeometry().setFromPoints(linePoints);
        geometries.push(geometry);
        
        const line = new THREE.Line(geometry, lineMaterial);
        lines.push(line);
        pineCone.add(line);
      }
    }
    
    // Rotate the entire pine cone 180 degrees to point downward
    pineCone.rotation.z = Math.PI;
    
    scene.add(pineCone);
    
    let time = 0;
    let animationFrameId: number;
    
    function animate() {
      animationFrameId = requestAnimationFrame(animate);
      
      time += 0.00125; // Slowed to 12.5% speed
      
      pineCone.rotation.y += 0.00125; // Slowed to 12.5% speed
      
      const breathe = 1 + Math.sin(time * 0.0625) * 0.02; // Slowed breathing to 12.5% speed
      pineCone.scale.set(breathe, breathe, breathe);
      
      renderer.render(scene, camera);
    }
    
    animate();
    
    // Comprehensive cleanup function
    return () => {
      // Stop animation loop
      cancelAnimationFrame(animationFrameId);
      
      // Dispose of all tracked geometries
      geometries.forEach(geometry => {
        geometry.dispose();
      });
      
      // Dispose of all tracked materials
      materials.forEach(material => {
        material.dispose();
      });
      
      // Remove all meshes from the scene
      meshes.forEach(mesh => {
        pineCone.remove(mesh);
      });
      
      // Remove all lines from the scene
      lines.forEach(line => {
        pineCone.remove(line);
      });
      
      // Remove the pine cone from the scene
      scene.remove(pineCone);
      
      // Clear the arrays
      geometries.length = 0;
      materials.length = 0;
      meshes.length = 0;
      lines.length = 0;
      vertices.length = 0;
      
      // Clear scene
      scene.clear();
      
      // Dispose of renderer and force context loss
      renderer.dispose();
      renderer.forceContextLoss();
      
      // Remove canvas from DOM
      if (containerRef.current && renderer.domElement.parentNode) {
        containerRef.current.removeChild(renderer.domElement);
      }
    };
  }, []);

  return (
    <div className="w-full h-screen flex justify-center items-center bg-[#F0EEE6]">
      <div 
        ref={containerRef}
        className="w-[550px] h-[550px]"
      />
    </div>
  );
};

export default PineconeConstellation;
```

```javascript
import React, { useState, useEffect, useCallback, useRef } from 'react';

// Themes: true contentment vs. attachment, value of inner wealth, freedom through acceptance
// Visualization: A radial pattern that finds harmony in simplicity, showing how contentment emerges from accepting what is

const IntricateRadialMesh = () => {
  const [dimensions, setDimensions] = useState({ width: 600, height: 600 });
  const { width, height } = dimensions;
  const radius = Math.min(width, height) * 0.25;
  const lineCount = 300;
  const [mousePos, setMousePos] = useState({ x: width / 2, y: height / 2 });
  
  // Finding contentment in natural movement
  const [circlePositions, setCirclePositions] = useState(null);
  const animationRef = useRef(null);
  const easingFactor = 0.1; // The gentle path of acceptance
  const containerRef = useRef(null);
  
  // Observe container size changes
  useEffect(() => {
    const updateDimensions = () => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        setDimensions({ width: rect.width, height: rect.height });
        setMousePos({ x: rect.width / 2, y: rect.height / 2 });
      }
    };

    // Initial size
    updateDimensions();

    // Setup resize observer
    const resizeObserver = new ResizeObserver(updateDimensions);
    if (containerRef.current) {
      resizeObserver.observe(containerRef.current);
    }

    return () => {
      resizeObserver.disconnect();
    };
  }, []);
  
  // When you recognize nothing is lacking, all the world belongs to you
  useEffect(() => {
    const initialPositions = [];
    for (let i = 0; i < 6; i++) {
      // Each point finds its natural place
      const angle = (i / 6) * Math.PI * 2;
      const x = width / 2 + Math.cos(angle) * radius * 0.6;  // Embracing simplicity
      const y = height / 2 + Math.sin(angle) * radius * 0.6;  // Finding balance
      initialPositions.push({ 
        x, 
        y, 
        targetX: x, 
        targetY: y,
        baseX: x,
        baseY: y,
        phaseX: Math.random() * Math.PI * 2, // Random starting phase for X
        phaseY: Math.random() * Math.PI * 2, // Random starting phase for Y
        frequencyX: 0.5 + Math.random() * 0.3, // Slightly different frequencies
        frequencyY: 0.5 + Math.random() * 0.3
      });
    }
    setCirclePositions(initialPositions);
  }, [width, height, radius]);
  
  // Handle mouse movement
  const handleMouseMove = useCallback((event) => {
    const svg = event.currentTarget;
    const rect = svg.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    setMousePos({ x, y });
  }, []);
  
  // Generate lines for a single circular mesh
  const generateCircleLines = (cx, cy, radius, rotation = 0) => {
    const lines = [];
    for (let i = 0; i < lineCount; i++) {
      const angle = (i / lineCount) * Math.PI * 2 + rotation;
      const x1 = cx + Math.cos(angle) * (radius * 0.1);
      const y1 = cy + Math.sin(angle) * (radius * 0.1);
      const x2 = cx + Math.cos(angle) * radius;
      const y2 = cy + Math.sin(angle) * radius;
      
      lines.push(`M${x1},${y1} L${x2},${y2}`);
    }
    return lines;
  };
  
  // Update target positions based on time and mouse
  useEffect(() => {
    let time = 0;
    const animate = () => {
      time += 0.016; // Time increment
      
      setCirclePositions(prevPositions => {
        if (!prevPositions) return null;
        
        return prevPositions.map((circle, i) => {
          // Calculate gentle floating motion (max 10% of radius)
          const floatAmplitude = radius * 0.05; // 5% radius for floating
          const floatX = Math.sin(time * circle.frequencyX + circle.phaseX) * floatAmplitude;
          const floatY = Math.cos(time * circle.frequencyY + circle.phaseY) * floatAmplitude;
          
          // Add floating motion to base position
          const targetX = circle.baseX + floatX;
          const targetY = circle.baseY + floatY;
          
          return {
            ...circle,
            targetX,
            targetY
          };
        });
      });
      
      requestAnimationFrame(animate);
    };
    
    const animationId = requestAnimationFrame(animate);
    return () => cancelAnimationFrame(animationId);
  }, [radius]);
  
  // Animate circle positions
  useEffect(() => {
    const animate = () => {
      setCirclePositions(prevPositions => {
        if (!prevPositions) return null;
        
        return prevPositions.map(circle => {
          const dx = circle.targetX - circle.x;
          const dy = circle.targetY - circle.y;
          
          return {
            ...circle,
            x: circle.x + dx * easingFactor,
            y: circle.y + dy * easingFactor
          };
        });
      });
      
      animationRef.current = requestAnimationFrame(animate);
    };
    
    animate();
    
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, []);
  
  // Create circles for rendering
  if (!circlePositions) return null;
  
  const circles = circlePositions.map((circle, i) => ({
    cx: circle.x,
    cy: circle.y,
    rotation: (i / 6) * Math.PI * 2
  }));
  
  return (
    <div 
      ref={containerRef} 
      style={{ 
        width: '100%', 
        height: '100%', 
        backgroundColor: '#F0EEE6'
      }}
    >
      <svg 
        width="100%" 
        height="100%" 
        viewBox={`0 0 ${width} ${height}`}
        preserveAspectRatio="xMidYMid meet"
        style={{ cursor: 'crosshair' }}
        onMouseMove={handleMouseMove}
      >
        {circles.map((circle, index) => (
          <g key={index}>
            {generateCircleLines(circle.cx, circle.cy, radius, circle.rotation).map((d, i) => (
              <path
                key={i}
                d={d}
                stroke="#333333"
                strokeWidth="0.3"
                opacity="0.7"
                fill="none"
              />
            ))}
          </g>
        ))}
      </svg>
    </div>
  );
};

export default IntricateRadialMesh;
```

```javascript
import React, { useEffect, useRef } from 'react';

// Themes: perfection in imperfection, wisdom in simplicity, natural authenticity
// Visualization: A single continuous line that appears unrefined yet creates perfect harmony through its natural movement

const ContinuousLineDrawing = () => {
  const canvasRef = useRef(null);
  const animationRef = useRef(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    // True straightness seems twisted
    const centerX = canvas.width / 2;  // Finding the center
    const centerY = canvas.height / 2;  // Where wisdom resides
    let currentTime = 0;  // Each moment perfect in itself
    let currentPosition = { x: centerX, y: centerY };
    let currentAngle = 0;  // The path unfolds naturally
    let radius = 0;  // Beginning from emptiness
    let points = [{ x: centerX, y: centerY, timestamp: 0 }];  // The journey's memory
    
    // Clear canvas with background color
    const clearCanvas = () => {
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    };
    
    // Draw just the dot
    const drawDot = (x, y) => {
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(80, 80, 80, 1)';
      ctx.fill();
    };
    
    // Animation function
    const animate = () => {
      // Increment time
      currentTime += 0.00375;  // 0.015 / 4
      
      // Clear canvas
      clearCanvas();
      
      // Simple expanding spiral
      radius += 0.0375;  // 0.15 / 4
      currentAngle += 0.025;  // 0.1 / 4
      
      // Calculate new position
      const newX = centerX + Math.cos(currentAngle) * radius;
      const newY = centerY + Math.sin(currentAngle) * radius;
      
      // Update current position with some easing
      currentPosition.x = newX;
      currentPosition.y = newY;
      
      // Add the point to our points array with timestamp
      points.push({ x: currentPosition.x, y: currentPosition.y, timestamp: currentTime });
      
      // If we go beyond the canvas, reset
      if (radius > 260) {
        radius = 0;
        points = [{ x: centerX, y: centerY, timestamp: currentTime }];
        currentPosition = { x: centerX, y: centerY };
        currentAngle = 0;
      }
      
      // Draw line segments with age-based color
      for (let i = 1; i < points.length; i++) {
        const p1 = points[i - 1];
        const p2 = points[i];
        
        // True art seems simplistic
        const age = Math.min((currentTime - p1.timestamp) / 10, 1);
        
        // From clarity to mystery
        const startGray = 170;  // The apparent
        const endGray = 85;     // The hidden
        const intensity = Math.floor(startGray + (endGray - startGray) * age);  // The transformation
        
        // Start faint (0.3), end solid (1.0)
        const startAlpha = 0.3;
        const endAlpha = 1.0;
        const alpha = startAlpha + (endAlpha - startAlpha) * age;
        
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.strokeStyle = `rgba(${intensity}, ${intensity}, ${intensity}, ${alpha})`;
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      
      // Draw the current dot
      drawDot(currentPosition.x, currentPosition.y);
      
      // Continue animation
      animationRef.current = requestAnimationFrame(animate);
    };
    
    // Start animation
    clearCanvas();
    animate();
    
    // Cleanup
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      
      // Clear points array to prevent memory leaks
      points.length = 0;
    };
  }, []);
  
  return (
    <div className="flex flex-col items-center justify-center bg-[#F0EEE6] p-4 w-full h-full">
      <div className="w-[550px] h-[550px] border border-gray-200 shadow-md">
        <canvas 
          ref={canvasRef} 
          width={550} 
          height={550} 
          className="bg-[#F0EEE6]"
        />
      </div>
    </div>
  );
};

export default ContinuousLineDrawing;
```

```javascript
import React, { useEffect, useRef } from 'react';

// Themes: technology's dual nature, acceptance vs. control, natural satisfaction
// Visualization: A ribbon that flows freely yet follows mathematical principles, showing how technology can align with natural movement

interface RibbonSegment {
  x: number;
  y: number;
  angle: number;
  width: number;
  height: number;
  depth: number;
}

interface RibbonStrip {
  // Technology in harmony with nature
  segments: RibbonSegment[];
  segmentCount: number;
  width: number;
  initialize: () => void;
  update: (time: number) => void;
  draw: (ctx: CanvasRenderingContext2D) => void;
}

const DramaticRibbonFold = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    canvas.width = 550;
    canvas.height = 550;

    class RibbonStrip {
      // Technology in harmony with nature
      segments: RibbonSegment[] = [];
      segmentCount: number = 30;  // Balance of structure
      width: number = 100;  // Space for movement

      constructor() {
        this.initialize();
      }

      // Each element finds its natural place
      initialize() {
        for (let i = 0; i < this.segmentCount; i++) {
          this.segments.push({
            x: 0,  // Beginning from stillness
            y: 0,  // Ready to flow
            angle: 0,  // No forced direction
            width: this.width,  // Room to breathe
            height: 20,  // Natural proportion
            depth: 0  // Potential for growth
          });
        }
      }

      update(time: number) {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        for (let i = 0; i < this.segments.length; i++) {
          const t = i / (this.segments.length - 1);
          const segment = this.segments[i];
          
          // Technology fostering freedom through natural movement
          const smoothTime = time * 0.25;  // Finding nature's rhythm
          const baseAngle = t * Math.PI * 6 + smoothTime;  // The spiral of life
          const foldPhase = Math.sin(smoothTime * 0.01 + t * Math.PI * 4);  // Waves of change
          const heightPhase = Math.cos(smoothTime * 0.00375 + t * Math.PI * 3);  // Breath of being
          
          // Position along a twisted path - structure revealing freedom
          const radius = 120 + foldPhase * 60;
          segment.x = centerX + Math.cos(baseAngle) * radius;
          segment.y = centerY + Math.sin(baseAngle) * radius + heightPhase * 30;
          
          // Rotation for folding effect - showing flexible response
          segment.angle = baseAngle + foldPhase * Math.PI * 0.5;
          
          // Width variation for perspective - allowing natural expansion
          segment.width = this.width * (1 + foldPhase * 0.3);
          
          // Depth for sorting - layers of understanding
          segment.depth = Math.sin(baseAngle + time * 0.15);
        }
      }

      draw(ctx: CanvasRenderingContext2D) {
        // Set wireframe style - revealing the underlying structure
        ctx.lineWidth = 1.5;
        ctx.setLineDash([2, 2]);
        
        // Sort segments by depth to show natural layering
        const sortedSegments = [...this.segments].sort((a, b) => {
          // Only change order if depth difference is significant - stable flow
          const threshold = 0.1;
          return Math.abs(a.depth - b.depth) > threshold ? a.depth - b.depth : 0;
        });

        // Draw segments as connected structure - technology made visible
        for (let i = 0; i < sortedSegments.length - 1; i++) {
          const current = sortedSegments[i];
          const next = sortedSegments[i + 1];

          ctx.save();
          ctx.beginPath();

          // Four corners of the ribbon segment - defining boundaries
          const cos1 = Math.cos(current.angle);
          const sin1 = Math.sin(current.angle);
          const cos2 = Math.cos(next.angle);
          const sin2 = Math.sin(next.angle);

          const p1 = {
            x: current.x - sin1 * current.width/2,
            y: current.y + cos1 * current.width/2
          };
          const p2 = {
            x: current.x + sin1 * current.width/2,
            y: current.y - cos1 * current.width/2
          };
          const p3 = {
            x: next.x + sin2 * next.width/2,
            y: next.y - cos2 * next.width/2
          };
          const p4 = {
            x: next.x - sin2 * next.width/2,
            y: next.y + cos2 * next.width/2
          };

          // Draw wireframe outline - showing structure without hiding essence
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.lineTo(p3.x, p3.y);
          ctx.lineTo(p4.x, p4.y);
          ctx.closePath();

          // Calculate opacity based on depth for natural visibility
          const depthFactor = (current.depth + 1) * 0.5;
          const opacity = 0.6 + depthFactor * 0.4;
          
          // Draw only stroke - transparency revealing inner truth
          ctx.strokeStyle = `rgba(40, 40, 40, ${opacity})`;
          ctx.stroke();
          
          // Draw diagonal lines for depth visualization - cross-connections
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p3.x, p3.y);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(p2.x, p2.y);
          ctx.lineTo(p4.x, p4.y);
          ctx.stroke();
          
          // Add center line for segment - the path of flow
          ctx.beginPath();
          ctx.moveTo(current.x, current.y);
          ctx.lineTo(next.x, next.y);
          ctx.strokeStyle = `rgba(80, 80, 80, ${opacity * 0.7})`;
          ctx.stroke();
          
          ctx.restore();
        }
        
        // Add vertex dots - connection points of understanding
        for (let i = 0; i < sortedSegments.length; i++) {
          const segment = sortedSegments[i];
          const cos = Math.cos(segment.angle);
          const sin = Math.sin(segment.angle);
          
          const p1 = {
            x: segment.x - sin * segment.width/2,
            y: segment.y + cos * segment.width/2
          };
          const p2 = {
            x: segment.x + sin * segment.width/2,
            y: segment.y - cos * segment.width/2
          };
          
          const depthFactor = (segment.depth + 1) * 0.5;
          const opacity = 0.7 + depthFactor * 0.3;
          
          // Draw vertex points - where structure meets freedom
          ctx.beginPath();
          ctx.arc(p1.x, p1.y, 2, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
          ctx.fill();
          
          ctx.beginPath();
          ctx.arc(p2.x, p2.y, 2, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
          ctx.fill();
          
          // Draw center point - the still center of movement
          ctx.beginPath();
          ctx.arc(segment.x, segment.y, 1.5, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(40, 40, 40, ${opacity})`;
          ctx.fill();
        }
        
        // Reset line dash
        ctx.setLineDash([]);
      }
    }

    const ribbon = new RibbonStrip();
    let time = 0;
    let animationFrameId: number;

    function animate() {
      // Same background color as original
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      time += 0.00125;
      ribbon.update(time);
      ribbon.draw(ctx);
      
      animationFrameId = requestAnimationFrame(animate);
    }

    animate();

    return () => {
      cancelAnimationFrame(animationFrameId);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ribbon.segments = [];
      time = 0;
    };
  }, []);

  return (
    <div style={{
      margin: 0,
      background: '#F0EEE6',
      overflow: 'hidden',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      height: '100vh',
      width: '100vw',
      position: 'relative'
    }}>
      <canvas 
        ref={canvasRef} 
        style={{ 
          display: 'block',
          width: '550px',
          height: '550px'
        }} 
      />
    </div>
  );
};

export default DramaticRibbonFold;
```

```javascript
import React, { useEffect, useRef } from 'react';

// Themes: inner knowing, direct perception, effortless understanding
// Visualization: A shell pattern that reveals the universe's structure through its simple, repeating forms

const ShellRidgePattern = () => {
  const canvasRef = useRef(null);
  const animationFrameId = useRef<number>(null);

  
  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    canvas.width = 550;
    canvas.height = 550;
    
    let time = 0;
    
    function drawRidgePattern() {
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // The still point at the center of all motion
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      // Without going outside, see the pattern of creation
      for (let r = 0; r < 25; r++) {
        const baseRadius = 10 + r * 12;  // Each circle a world within worlds
        
        ctx.beginPath();
        for (let a = 0; a <= Math.PI * 2; a += 0.05) {
          // The dance of form and emptiness
          const distortion = Math.sin(a * 8 + time * 0.75 + r * 0.5) * 8 +  // Breath of life
                           Math.sin(a * 12 - time * 1 + r * 0.3) * 5;       // Pulse of being
          
          const radius = baseRadius + distortion;
          const x = centerX + Math.cos(a) * radius;
          const y = centerY + Math.sin(a) * radius;
          
          if (a === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.closePath();
        
        // Seeing the subtle within the obvious
        ctx.lineWidth = 1.5 + Math.sin(r * 0.5 + time) * 0.5;  // The way things change
        ctx.strokeStyle = `rgba(51, 51, 51, ${0.6 - r * 0.02})`;  // From form to formless
        ctx.stroke();
        
        // The infinite in the finite
        for (let t = 0; t < 60; t++) {  // Each point contains the whole
          const angle = (t / 60) * Math.PI * 2;
          const textureRadius = baseRadius + Math.sin(angle * 8 + time * 1.5) * 5;
          const tx = centerX + Math.cos(angle) * textureRadius;
          const ty = centerY + Math.sin(angle) * textureRadius;
          
          ctx.beginPath();
          ctx.arc(tx, ty, 0.5, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(85, 85, 85, ${0.2 - r * 0.01})`;
          ctx.fill();
        }
      }
    }
    
    function animate() {
      time += 0.005;
      drawRidgePattern();
      animationFrameId.current = requestAnimationFrame(animate);
    }
    
    animate();

    return () => {
      if (animationFrameId.current) {
        cancelAnimationFrame(animationFrameId.current);
      }
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    };

  }, []);
  
  return (
    <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', width: '550px', height: '550px', margin: '0 auto', backgroundColor: '#F0EEE6' }}>
      <canvas ref={canvasRef} />
    </div>
  );
};

export default ShellRidgePattern;
```

```javascript
import React, { useEffect, useRef } from 'react';

// Themes: simplicity through non-action, natural unfolding, letting things take their course
// Visualization: A tree that grows through simple rules, demonstrating how complexity naturally emerges when we step back and let things develop

const SwayingBranches = () => {
  const canvasRef = React.useRef(null);
  
  React.useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    
    // Make canvas fill the entire viewport with proper pixel ratio
    const adjustCanvas = () => {
      const devicePixelRatio = window.devicePixelRatio || 1;
      
      // Set display size (css pixels)
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      
      // Set actual size in memory (scaled to account for extra pixel density)
      canvas.width = window.innerWidth * devicePixelRatio;
      canvas.height = window.innerHeight * devicePixelRatio;
      
      // Normalize coordinate system to use css pixels
      ctx.scale(devicePixelRatio, devicePixelRatio);
    };
    
    adjustCanvas();
    window.addEventListener('resize', adjustCanvas);
    
    // L-system parameters
    // Using a slightly simpler rule set to create larger, more visible structures
    const axiom = "X";
    const rules = {
      "X": "F-[[X]+X]+F[+FX]-X",
      "F": "FF"
    };
    
    // Function to generate L-system string
    const generateLSystem = (start, iterations, customRules = rules) => {
      let result = start;
      for (let i = 0; i < iterations; i++) {
        let nextGen = "";
        for (let j = 0; j < result.length; j++) {
          const current = result[j];
          nextGen += customRules[current] || current;
        }
        result = nextGen;
      }
      return result;
    };
    
    // Pre-compute L-systems to avoid regenerating during animation
    // Using larger length values to make the visualization bigger
    // Create more complex final stage with a different rule
    const finalRule = {
      "X": "F-[[X]+X]+F[+FX]-X+[F+X][-X]",  // Added balanced branching on right side
      "F": "FF"
    };

    const precomputedSystems = [
      {
        config: { iterations: 3, angleDelta: Math.PI / 7, length: 25 },
        system: generateLSystem(axiom, 3)
      },
      {
        config: { iterations: 4, angleDelta: Math.PI / 7, length: 21 },
        system: generateLSystem(axiom, 4)
      },
      {
        // Final stage uses more complex rule and slightly different angle
        config: { iterations: 5, angleDelta: Math.PI / 8, length: 17 },
        system: generateLSystem(axiom, 5, finalRule)  // Pass the complex rule
      }
    ];
    
    // Animation variables
    let time = 0;
    let currentSystemIndex = 0;
    let transitionFactor = 0;
    let isTransitioning = false;
    let growthComplete = false;
    let animationFrameId;
    let swayFactor = 0.4; // Increased swaying motion
    
    // Draw the L-system
    const drawLSystem = (systemData, alpha = 1) => {
      // Get system parameters
      const { config, system } = systemData;
      const { angleDelta, length } = config;
      
      // Calculate starting position - centered at bottom, moved higher to accommodate larger tree
      let x = window.innerWidth / 2;
      let y = window.innerHeight * .98; // Start from bottom of screen to accommodate larger size
      
      // Base angle with enhanced swaying animation
      let baseAngle = -Math.PI / 2 + (Math.sin(time * 0.2) * swayFactor);
      
      const stack = [];
      
      // Draw the L-system
      for (let i = 0; i < system.length; i++) {
        const command = system[i];
        
        switch(command) {
          case 'F': // Draw forward
            const x2 = x + length * Math.cos(baseAngle);
            const y2 = y + length * Math.sin(baseAngle);
            
            // Create a gradient stroke with consistent opacity
            const transparency = (0.2 - (i / system.length) * 0.08) * alpha; // Lighter transparency
            ctx.strokeStyle = `rgba(51, 51, 51, ${transparency})`;
            ctx.lineWidth = 2; // Slightly thicker lines for zoomed view
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            x = x2;
            y = y2;
            break;
            
          case '+': // Turn right
            baseAngle += angleDelta + (Math.sin(time * 0.2 + i * 0.01) * 0.05); // More noticeable variation
            break;
            
          case '-': // Turn left
            baseAngle -= angleDelta + (Math.sin(time * 0.2 + i * 0.01) * 0.05); // More noticeable variation
            break;
            
          case '[': // Save state
            stack.push({ x, y, angle: baseAngle });
            break;
            
          case ']': // Restore state
            const state = stack.pop();
            if (state) {
              ({ x, y, baseAngle } = { ...state, baseAngle: state.angle });
              
              // Add a smaller dot at branching points with lighter opacity
              const dotAlpha = 0.1 * alpha;
              if (dotAlpha > 0.01) { // Only draw visible dots
                ctx.fillStyle = `rgba(51, 51, 51, ${dotAlpha})`;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, Math.PI * 2); // Smaller dots (2px radius)
                ctx.fill();
              }
            }
            break;
        }
      }
    };
    
    // Animation loop with double buffering to prevent flicker
    const animate = () => {
      // Clear canvas smoothly
      ctx.fillStyle = "#F0EEE6";
      ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
      
      time += 0.008; // Even slower time increment for smoother swaying
      
      if (!growthComplete) {
        if (isTransitioning) {
          // Increment transition factor with smooth easing
          transitionFactor += 0.02; // Slower, more elegant transition
          
          if (transitionFactor >= 1) {
            isTransitioning = false;
            transitionFactor = 0;
            currentSystemIndex++;
            
            // Check if we've reached the final stage
            if (currentSystemIndex >= precomputedSystems.length - 1) {
              growthComplete = true;
              currentSystemIndex = precomputedSystems.length - 1;
            }
          } else {
            // Draw fading out system with easing
            const easeOut = 1 - Math.pow(1 - transitionFactor, 3); // Cubic ease out
            drawLSystem(precomputedSystems[currentSystemIndex], 1 - easeOut);
            
            // Draw fading in system with easing
            const nextIndex = Math.min(currentSystemIndex + 1, precomputedSystems.length - 1);
            drawLSystem(precomputedSystems[nextIndex], easeOut);
          }
        } else {
          // Draw current system
          drawLSystem(precomputedSystems[currentSystemIndex]);
          
          // Start next transition after 1 second
          if (time % 1 < 0.016) { // Approximately one frame at 60fps
            isTransitioning = true;
          }
        }
      } else {
        // Just draw final form and sway
        drawLSystem(precomputedSystems[precomputedSystems.length - 1]);
      }
      
      animationFrameId = requestAnimationFrame(animate);
    };
    
    // Start animation
    animate();
    
    // Cleanup function
    return () => {
      window.removeEventListener('resize', adjustCanvas);
      cancelAnimationFrame(animationFrameId);
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      
      // Clear precomputed systems array to prevent memory leaks
      precomputedSystems.length = 0;
    };
  }, []);

  return (
    <div className="w-full h-screen bg-[#F0EEE6] overflow-hidden">
      <canvas 
        ref={canvasRef} 
        style={{ 
          background: "#F0EEE6",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%"
        }}
      />
    </div>
  );
};

export default SwayingBranches;
```

```javascript
import React, { useEffect, useRef } from 'react';

// Themes: universal trust, childlike openness, merging with collective wisdom
// Visualization: A sacred geometry pattern that shows how individual circles merge into a unified whole, representing the harmony of trust and openness

const FlowerOfLife = () => {
  const canvasRef = useRef(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    canvas.width = 550;
    canvas.height = 550;
    
    let time = 0;
    
    const drawCircle = (cx, cy, radius, alpha) => {
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(80, 80, 80, ${alpha})`;
      ctx.lineWidth = 1;
      ctx.stroke();
    };
    
    const animate = () => {
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      time += 0.005;
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const baseRadius = 40;
      
      // Draw central circle
      drawCircle(centerX, centerY, baseRadius, 0.48);
      
      // Draw overlapping circles in hexagonal pattern
      const ringCount = 4;
      for (let ring = 1; ring <= ringCount; ring++) {
        const circles = ring * 6;
        const ringRadius = ring * baseRadius * Math.sqrt(3);
        
        for (let i = 0; i < circles; i++) {
          const angle = (i / circles) * Math.PI * 2;
          const x = centerX + Math.cos(angle) * ringRadius;
          const y = centerY + Math.sin(angle) * ringRadius;
          
          // Add pulsing effect with increased range
          const pulse = Math.sin(time * 2 + ring * 0.5 + i * 0.1) * 0.12;
          const alpha = 0.36 - ring * 0.06 + pulse;
          
          drawCircle(x, y, baseRadius, alpha);
        }
      }
      
      // Draw additional sacred geometry patterns
      // Vesica Piscis
      const vesicaSpacing = baseRadius * 2;
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        const x1 = centerX + Math.cos(angle) * vesicaSpacing;
        const y1 = centerY + Math.sin(angle) * vesicaSpacing;
        const x2 = centerX + Math.cos(angle + Math.PI) * vesicaSpacing;
        const y2 = centerY + Math.sin(angle + Math.PI) * vesicaSpacing;
        
        ctx.beginPath();
        ctx.arc(x1, y1, vesicaSpacing, 0, Math.PI * 2);
        ctx.arc(x2, y2, vesicaSpacing, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(80, 80, 80, 0.12)';
        ctx.stroke();
      }
      
      // Add rotating overlay pattern
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(time * 0.1);
      
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * 200, Math.sin(angle) * 200);
        ctx.strokeStyle = 'rgba(80, 80, 80, 0.06)';
        ctx.stroke();
      }
      
      ctx.restore();
      
      animationId = requestAnimationFrame(animate);
    };
    
    let animationId = requestAnimationFrame(animate);
    
    return () => {
      cancelAnimationFrame(animationId);
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    };
  }, []);
  
  return (
    <div className="flex items-center justify-center w-full h-full" style={{ backgroundColor: '#F0EEE6' }}>
      <div className="w-[550px] h-[550px] shadow-lg rounded-lg overflow-hidden">
        <canvas 
          ref={canvasRef} 
          className="w-full h-full"
        />
      </div>
    </div>
  );
};

export default FlowerOfLife;
```

```javascript
import { useEffect, useRef } from 'react';

// Themes: surrender to the moment, readiness for change, natural completion
// Visualization: A flowing grid that yields to invisible forces, showing how structure can remain while embracing constant change

const FlowingRibbons = () => {
  const canvasRef = useRef(null);
  const ctxRef = useRef(null);
  const pointsCacheRef = useRef(null);
  const timeRef = useRef(0);

  // Pre-calculate constants - the underlying structure that enables flow
  const CANVAS_SIZE = 550;
  const GRID_DENSITY = 100;  // Balance between rigidity and fluidity
  const RIBBON_WIDTH = CANVAS_SIZE * 0.85;
  const RIBBON_OFFSET = (CANVAS_SIZE - RIBBON_WIDTH) / 2;
  const PI4 = Math.PI * 4;
  const PI7 = Math.PI * 7;

  // Optimized deform function with cached trig values - like nature's efficient patterns
  const deform = (x, y, t, progress, sinCache) => {
    // Ensure indices stay within bounds by clamping progress
    const p = Math.max(0, Math.min(1, progress));
    const wave1 = sinCache[Math.floor(Math.abs((p * PI4 + t * 0.01) * 100) % 628)] * 30;
    const wave2 = sinCache[Math.floor(Math.abs((p * PI7 - t * 0.008) * 100) % 628)] * 15;
    const harmonic = sinCache[Math.floor(Math.abs((x * 0.02 + y * 0.015 + t * 0.005) * 100) % 628)] * 10;
    return { offsetX: wave1 + harmonic, offsetY: wave2 };
  };
    
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    // Initialize canvas and context only once
    if (!ctxRef.current) {
      canvas.width = CANVAS_SIZE;
      canvas.height = CANVAS_SIZE;
      ctxRef.current = canvas.getContext('2d', {
        alpha: false // Optimization: no transparency needed
      });
    }
    const ctx = ctxRef.current;

    // Pre-calculate sin values for performance
    if (!pointsCacheRef.current) {
      const sinCache = new Float32Array(628); // 2π * 100
      for (let i = 0; i < 628; i++) {
        sinCache[i] = Math.sin(i / 100);
      }
      pointsCacheRef.current = {
        sinCache,
        verticalLines: new Float32Array(GRID_DENSITY * 2 * (GRID_DENSITY + 1)),
        horizontalLines: new Float32Array(GRID_DENSITY * 2 * (GRID_DENSITY + 1))
      };
    }
    const { sinCache, verticalLines, horizontalLines } = pointsCacheRef.current;

    let animationId;
    
    const animate = () => {
      const time = timeRef.current;
      
      // Clear with background color
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
      
      // Set line style
      ctx.strokeStyle = '#777777';
      ctx.lineWidth = 0.5;
      
      // Update point positions
      let vIdx = 0;
      let hIdx = 0;
      
      // Calculate vertical lines
      for (let i = 0; i < GRID_DENSITY; i++) {
        const x = RIBBON_OFFSET + (i / GRID_DENSITY) * RIBBON_WIDTH;
        
        for (let j = 0; j <= GRID_DENSITY; j++) {
          const progress = (j / GRID_DENSITY) * 1.2 - 0.1;
          const y = progress * CANVAS_SIZE;
          
          const { offsetX, offsetY } = deform(x, y, time, progress, sinCache);
          
          verticalLines[vIdx++] = x + offsetX;
          verticalLines[vIdx++] = y + offsetY;
        }
      }
      
      // Calculate horizontal lines
      for (let j = 0; j < GRID_DENSITY; j++) {
        const progress = (j / GRID_DENSITY) * 1.2 - 0.1;
        const y = progress * CANVAS_SIZE;
        
        for (let i = 0; i <= GRID_DENSITY; i++) {
          const x = RIBBON_OFFSET + (i / GRID_DENSITY) * RIBBON_WIDTH;
          
          const { offsetX, offsetY } = deform(x, y, time, progress, sinCache);
          
          horizontalLines[hIdx++] = x + offsetX;
          horizontalLines[hIdx++] = y + offsetY;
        }
      }
      
      // Draw vertical lines
      vIdx = 0;
      for (let i = 0; i < GRID_DENSITY; i++) {
        ctx.beginPath();
        ctx.moveTo(verticalLines[vIdx], verticalLines[vIdx + 1]);
        vIdx += 2;
        
        for (let j = 1; j <= GRID_DENSITY; j++) {
          ctx.lineTo(verticalLines[vIdx], verticalLines[vIdx + 1]);
          vIdx += 2;
        }
        ctx.stroke();
      }
      
      // Draw horizontal lines
      hIdx = 0;
      for (let j = 0; j < GRID_DENSITY; j++) {
        ctx.beginPath();
        ctx.moveTo(horizontalLines[hIdx], horizontalLines[hIdx + 1]);
        hIdx += 2;
        
        for (let i = 1; i <= GRID_DENSITY; i++) {
          ctx.lineTo(horizontalLines[hIdx], horizontalLines[hIdx + 1]);
          hIdx += 2;
        }
        ctx.stroke();
      }
      
      timeRef.current += 0.3;
      animationId = requestAnimationFrame(animate);
    };
    
    animate();
    
    return () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      
      // Clear canvas context
      if (ctxRef.current) {
        ctxRef.current.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
      }
      
      // Clear refs to prevent memory leaks
      ctxRef.current = null;
      pointsCacheRef.current = null;
      timeRef.current = 0;
    };
  }, []);

  return (
    <div style={{ 
      margin: 0,
      background: '#F0EEE6',
      overflow: 'hidden',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      height: '100%'
    }}>
      <div style={{
        padding: '30px',
        position: 'relative',
        width: '100%',
        height: '100%',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}>
        <canvas 
          ref={canvasRef}
          style={{ display: 'block' }}
        />
      </div>
    </div>
  );
};

export default FlowingRibbons;
```

```javascript
import React, { useEffect, useRef } from 'react';

// Themes: natural nourishment, intelligent formation, welcoming return
// Visualization: Layers of particles that form and flow like geological strata, showing how all things are shaped by their environment

const CanyonStratifiedUndulations = () => {
  const canvasRef = useRef(null);
  const animationFrameRef = useRef(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width = 550;
    const height = canvas.height = 550;
    const centerX = width / 2;
    const centerY = height / 2;
    
    // Each particle represents a point of potential, shaped by its environment
    const PARTICLE_COUNT = 18000;
    const STRATA_LAYERS = 12;  // The layers through which formation occurs
    const particles = [];
    
    // Create particles in stratified rock layers, each finding its natural place
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      const stratum = Math.floor(Math.random() * STRATA_LAYERS);
      const thickness = 40 + stratum * 3;
      const depth = stratum * 25;
      
      // Position within stratum
      const y = Math.random() * height;
      const strataPhase = y * 0.01 + stratum * 0.3;
      
      // Multiple wave frequencies for each stratum
      const primaryUndulation = Math.sin(strataPhase) * 35;
      const secondaryUndulation = Math.sin(strataPhase * 2 + stratum * 0.8) * 18;
      const tertiaryUndulation = Math.sin(strataPhase * 4 + stratum * 1.5) * 8;
      
      const totalUndulation = primaryUndulation + secondaryUndulation + tertiaryUndulation;
      
      // Determine side and position
      const side = Math.random() < 0.5 ? -1 : 1;
      const baseX = centerX + side * (60 + totalUndulation + depth);
      const offsetX = (Math.random() - 0.5) * thickness;
      
      particles.push({
        x: baseX + offsetX,
        y: y,
        z: (stratum - STRATA_LAYERS/2) * 30 + (Math.random() - 0.5) * 20,
        side: side,
        stratum: stratum,
        flow: Math.random() * Math.PI * 2,
        oscillation: Math.random() * Math.PI * 2,
        velocity: 0.05 + stratum * 0.015,
        brightness: 0.6 + Math.random() * 0.4
      });
    }
    
    let time = 0;
    let isRunning = true;
    
    function animate() {
      if (!isRunning) return;
      
      time += 0.016;
      
      // Clear with stratified effect
      ctx.fillStyle = 'rgba(240, 238, 230, 0.025)';
      ctx.fillRect(0, 0, width, height);
      
      // Sort by z-depth and stratum
      particles.sort((a, b) => a.z - b.z);
      
      particles.forEach(particle => {
        const strataPhase = particle.y * 0.01 + particle.stratum * 0.3 + time * 0.03;
        
        // Calculate undulations for this stratum
        const primaryUndulation = Math.sin(strataPhase) * 35;
        const secondaryUndulation = Math.sin(strataPhase * 2 + particle.stratum * 0.8) * 18;
        const tertiaryUndulation = Math.sin(strataPhase * 4 + particle.stratum * 1.5) * 8;
        
        const totalUndulation = primaryUndulation + secondaryUndulation + tertiaryUndulation;
        const depth = particle.stratum * 25;
        const thickness = 40 + particle.stratum * 3;
        
        // Calculate target position
        const targetX = centerX + particle.side * (60 + totalUndulation + depth);
        const strataDrift = Math.sin(particle.flow + time * 0.6 + particle.stratum * 0.4) * thickness * 0.7;
        
        // Smooth movement with stratum-specific dynamics
        particle.x = particle.x * 0.94 + (targetX + strataDrift) * 0.06;
        particle.y += particle.velocity;
        
        // Add vertical oscillation within stratum
        particle.y += Math.sin(particle.oscillation + time * 0.8) * 0.3;
        
        // Update depth
        particle.z += Math.sin(time * 0.3 + particle.flow + particle.stratum * 0.6) * 0.25;
        
        // Reset at bottom
        if (particle.y > height + 40) {
          particle.y = -40;
          particle.flow = Math.random() * Math.PI * 2;
        }
        
        // Draw with stratum-based effects
        const depthFactor = (particle.z + STRATA_LAYERS * 15) / (STRATA_LAYERS * 30);
        const opacity = 0.15 + depthFactor * 0.15;  // More transparent
        const size = 0.3 + depthFactor * 0.8;    // Smaller particles
        const brightness = 45 + particle.stratum * 3 + particle.brightness * 15;  // Lighter, more subtle gradients
        
        if (opacity > 0 && size > 0) {
          // Stratum-based highlighting
          if (particle.stratum % 3 === 0) {
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, size * 2, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(${brightness}, ${brightness}, ${brightness}, ${opacity * 0.06})`;
            ctx.fill();
          }
          
          // Main particle
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${brightness}, ${brightness}, ${brightness}, ${opacity})`;
          ctx.fill();
        }
      });
      
      animationFrameRef.current = requestAnimationFrame(animate);
    }
    
    animate();
    
    return () => {
      isRunning = false;
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
        animationFrameRef.current = null;
      }
      if (ctx) {
        ctx.clearRect(0, 0, width, height);
      }
      particles.length = 0;
      time = 0;
    };
  }, []);
  
  return (
    <div style={{
      width: '550px',
      height: '550px',
      margin: 'auto',
      backgroundColor: '#F0EEE6',
      overflow: 'hidden'
    }}>
      <canvas
        ref={canvasRef}
        style={{
          display: 'block',
          width: '550px',
          height: '550px'
        }}
      />
    </div>
  );
};

export default CanyonStratifiedUndulations;
```

```javascript
import React, { useState, useEffect, useRef } from 'react';

// Themes: return to origin, knowing mother and child, finding inexhaustible energy
// Visualization: A pulsing ASCII form that emerges from and returns to emptiness, showing the cycle of manifestation

const AsciiBlob = () => {
  const [frame, setFrame] = useState(60); // Start at frame 60
  const densityRef = useRef(0); // Use ref to avoid dependency issues
  
  // Characters representing the stages of manifestation
  const simpleChars = '░▒▓█';  // From emptiness to form
  
  // Canvas dimensions - the space of potential
  const width = 60;
  const height = 30;
  
  useEffect(() => {
    let animationFrameId = null;
    let lastFrameTime = 0;
    const targetFPS = 10; // Increased from 2 FPS to 10 FPS
    const frameInterval = 1000 / targetFPS;
    
    const animate = (currentTime) => {
      animationFrameId = requestAnimationFrame(animate);
      
      const deltaTime = currentTime - lastFrameTime;
      
      // Only update if enough time has passed
      if (deltaTime >= frameInterval) {
        // Calculate remainder to prevent drift
        const remainder = deltaTime % frameInterval;
        
        // Update lastFrameTime with the time that's been processed
        lastFrameTime = currentTime - remainder;
        
        setFrame(prevFrame => {
          const newFrame = prevFrame + 1;
          // Update density value in ref (adjusted time factor for 10 FPS)
          densityRef.current = 27.5 + 22.5 * Math.sin(newFrame * 0.002); // Reduced from 0.01 to 0.002 (1/5)
          return newFrame;
        });
      }
    };
    
    // Start animation
    animationFrameId = requestAnimationFrame(animate);
    
    return () => {
      // Clean up the animation frame to stop the animation
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      // Reset frame and density
      setFrame(60); // Reset to frame 60
      densityRef.current = 0;
    };
  }, []); // Empty dependency array to run only once on mount
  
  // Generate ASCII art
  const generateArt = () => {
    const canvas = [];
    const currentDensity = densityRef.current;
    
    for (let y = 0; y < height; y++) {
      let row = '';
      for (let x = 0; x < width; x++) {
        // Generate a value based on position, frame, and density
        const centerX = width / 2;
        const centerY = height / 2;
        
        // Distance from center (normalized)
        const dx = (x - centerX) / centerX;
        const dy = (y - centerY) / centerY;
        const distFromCenter = Math.sqrt(dx * dx + dy * dy);
        
        // Simpler, more ordered pattern (adjusted time factors for 10 FPS)
        let noiseValue = Math.sin(distFromCenter * 3 - frame * 0.002); // Reduced from 0.01 to 0.002 (1/5)
        noiseValue += Math.cos(x * 0.1 - y * 0.1 + frame * 0.0008) * 0.3; // Reduced from 0.004 to 0.0008 (1/5)
        noiseValue = (noiseValue + 1) / 2; // Normalize to 0-1
        
        // Apply density adjustment
        noiseValue = noiseValue * (currentDensity / 100);
        
        // Select character based on value
        const charIndex = Math.floor(noiseValue * simpleChars.length);
        let char = simpleChars[Math.min(Math.max(0, charIndex), simpleChars.length - 1)];
        
        // As we approach non-action, introduce more empty space
        if (currentDensity < 30 && Math.random() > currentDensity / 30) {
          char = ' ';
        }
        
        row += char;
      }
      canvas.push(row);
    }
    
    return canvas;
  };
  
  const canvas = generateArt();
  
  const containerStyle = {
    backgroundColor: '#F0EEE6',
    height: '100vh',
    width: '100vw',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
  };
  
  return (
    <div style={containerStyle}>
      <pre className="font-mono text-gray-800 text-center text-xs md:text-sm whitespace-pre">
        {canvas.join('\n')}
      </pre>
    </div>
  );
};

export default AsciiBlob;
```

```javascript
import React, { useEffect, useRef } from 'react';

// Themes: natural simplicity, balance lost, true path revealed
// Visualization: Growth patterns that spread naturally from centers of energy, showing how complexity emerges from simple rules

const RadialGrowth = () => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    canvas.width = 550;
    canvas.height = 550;

    let animationTime = 0;
    let radiators = [];
    let animationFrameId;

    // Each radiator represents a point of natural growth and decay
    class Radiator {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = Math.random() * 40 + 10;  // Natural variation in size
        this.lines = Math.floor(Math.random() * 150 + 100);  // Each finds its own form
        this.growth = (Math.random() * 0.5 + 0.5) * 0.125;  // Growth follows its own pace
        this.maxLength = Math.random() * 100 + 50;
        this.age = 0;
        this.lifespan = (Math.random() * 200 + 100) * 4;  // Each has its time
        this.opacity = 0;
      }

      update() {
        this.age++;
        // Fade in during first 20% of life, fade out during last 20%
        if (this.age < this.lifespan * 0.2) {
          this.opacity = Math.min(1, this.age / (this.lifespan * 0.2));
        } else if (this.age > this.lifespan * 0.8) {
          this.opacity = Math.max(0, 1 - (this.age - this.lifespan * 0.8) / (this.lifespan * 0.2));
        } else {
          this.opacity = 1;
        }
      }

      draw() {
        const currentLength = Math.min(this.maxLength, this.age * this.growth);
        const centerRadius = 1 + this.age * 0.0025; // Eighth center growth speed
        
        ctx.save();
        ctx.globalAlpha = this.opacity * 0.5;
        ctx.translate(this.x, this.y);

        // Draw radiating lines
        for (let i = 0; i < this.lines; i++) {
          const angle = (i / this.lines) * Math.PI * 2;
          const length = currentLength;
          
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(Math.cos(angle) * length, Math.sin(angle) * length);
          ctx.strokeStyle = '#333';
          ctx.lineWidth = 0.3;
          ctx.stroke();
        }

        // Draw central dot with growth
        ctx.beginPath();
        ctx.arc(0, 0, centerRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fill();

        ctx.restore();
      }

      isDead() {
        return this.age > this.lifespan;
      }
    }

    function spawnRadiator() {
      if (radiators.length < 50) {
        // Spawn in clusters - use existing radiator position as reference
        let baseX, baseY;
        
        if (radiators.length > 0 && Math.random() < 0.8) {
          // 80% chance to spawn near existing radiator
          const parent = radiators[Math.floor(Math.random() * radiators.length)];
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * 50 + 20;
          baseX = parent.x + Math.cos(angle) * distance;
          baseY = parent.y + Math.sin(angle) * distance;
        } else {
          // Random position with bias toward center
          const centerBias = Math.random() * 0.5 + 0.5;
          baseX = canvas.width/2 + (Math.random() - 0.5) * canvas.width * centerBias;
          baseY = canvas.height/2 + (Math.random() - 0.5) * canvas.height * centerBias;
        }

        // Keep within bounds
        baseX = Math.max(50, Math.min(canvas.width - 50, baseX));
        baseY = Math.max(50, Math.min(canvas.height - 50, baseY));

        radiators.push(new Radiator(baseX, baseY));
      }
    }

    function animate() {
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      animationTime++;

      // Spawn new radiators periodically
      if (animationTime % 40 === 0) { // Eighth spawn rate
        spawnRadiator();
      }

      // Update and draw radiators
      radiators = radiators.filter(radiator => !radiator.isDead());
      
      radiators.forEach(radiator => {
        radiator.update();
        radiator.draw();
      });

      animationFrameId = requestAnimationFrame(animate);
    }

    animate();

    return () => {
      // Cancel animation frame to stop the animation
      cancelAnimationFrame(animationFrameId);
      
      // Clear the canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Clean up objects
      radiators = [];
      animationTime = 0;
    };
  }, []);

  return (
    <div style={{ 
      width: '100vw', 
      height: '100vh', 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center',
      backgroundColor: '#F0EEE6'
    }}>
      <div style={{ 
        width: '550px', 
        height: '550px',
        backgroundColor: '#F0EEE6',
        borderRadius: '2px',
        boxShadow: '0 0 10px rgba(0,0,0,0.1)'
      }}>
        <canvas ref={canvasRef} />
      </div>
    </div>
  );
};

export default RadialGrowth;
```

```javascript
import React, { useEffect, useRef } from 'react';

// Themes: inner rootedness, genuine cultivation, universal harmony
// Visualization: Lines that follow invisible force fields, showing how deep patterns emerge from firmly established principles

const VectorFieldLines = () => {
  const canvasRef = useRef(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Core parameters that shape the field's behavior
    const numLines = 300;  // The many that arise from the one
    const linePoints = 200;  // Memory of the path
    const noiseScale = 0.005;  // Subtlety of influence
    const noiseTimeScale = 0.000125;  // Natural rhythm of change
    const lineAlpha = 0.4;  // Balance of presence
    const lineWidth = 0.5;
    
    let animationFrameId;
    let time = 0;
    
    // Simple noise function
    const noise = (x, y, z) => {
      return Math.sin(x * 7 + z * 3) * 0.5 + 
             Math.sin(y * 8 + z * 4) * 0.5;
    };
    
    // The underlying force that guides all movement
    const vectorField = (x, y, t) => {
      // Transform coordinates to the field's natural space
      const nx = (x - width / 2) * 0.01;
      const ny = (y - height / 2) * 0.01;
      
      // Get noise value
      const n = noise(nx, ny, t * noiseTimeScale);
      
      // Create form boundary (mask)
      const cx = x - width / 2;
      const cy = y - height / 2;
      const r = Math.sqrt(cx * cx + cy * cy);
      const mask = Math.max(0, 1 - r / 200);
      
      // Create directional vector based on mask and noise
      const angle = n * Math.PI * 4 + Math.atan2(cy, cx);
      
      return {
        x: Math.cos(angle) * mask,
        y: Math.sin(angle) * mask
      };
    };
    
    // Create a line
    class Line {
      constructor() {
        this.reset();
      }
      
      reset() {
        // Start at random position
        const angle = Math.random() * Math.PI * 2;
        const distance = 50 + Math.random() * 150;
        
        this.x = width / 2 + Math.cos(angle) * distance;
        this.y = height / 2 + Math.sin(angle) * distance;
        
        this.points = [];
        this.age = 0;
        this.lifespan = 400 + Math.random() * 600;  // Quadruple lifespan for smoother transitions
        this.opacity = 0;
        this.fadeIn = true;
        this.width = 0.2 + Math.random() * 0.8;
      }
      
      update(t) {
        // Update age
        this.age += 1;
        
        // Reset when too old
        if (this.age >= this.lifespan) {
          this.reset();
          return;
        }
        
        // Update opacity - fade in and out
        const progress = this.age / this.lifespan;
        if (progress < 0.1) {
          this.opacity = progress / 0.1 * lineAlpha;
        } else if (progress > 0.9) {
          this.opacity = (1 - (progress - 0.9) / 0.1) * lineAlpha;
        } else {
          this.opacity = lineAlpha;
        }
        
        // Get vector at current position
        const vector = vectorField(this.x, this.y, t);
        
        // Add current position to points array
        this.points.push({ x: this.x, y: this.y });
        
        // Limit the number of points
        if (this.points.length > linePoints) {
          this.points.shift();
        }
        
        // Move to next position
        this.x += vector.x * 0.5;  // Quarter speed movement
        this.y += vector.y * 0.5;
        
        // Check if out of bounds or vector is too small
        const magnitude = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
        if (this.x < 0 || this.x > width || this.y < 0 || this.y > height || magnitude < 0.01) {
          this.reset();
        }
      }
      
      draw(ctx) {
        if (this.points.length < 2) return;
        
        ctx.beginPath();
        ctx.strokeStyle = `rgba(51, 51, 51, ${this.opacity})`;
        ctx.lineWidth = this.width * lineWidth;
        
        ctx.moveTo(this.points[0].x, this.points[0].y);
        
        for (let i = 1; i < this.points.length; i++) {
          ctx.lineTo(this.points[i].x, this.points[i].y);
        }
        
        ctx.stroke();
      }
    }
    
    // Create lines
    const lines = Array.from({ length: numLines }, () => new Line());
    
    // Animation loop
    const animate = () => {
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, width, height);
      
      // Update and draw all lines
      lines.forEach(line => {
        line.update(time);
        line.draw(ctx);
      });
      
      time += 1;
      animationFrameId = requestAnimationFrame(animate);
    };
    
    animate();
    
    // Cleanup
    return () => {
      cancelAnimationFrame(animationFrameId);
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, width, height);
      }
      
      // Clear lines array to prevent memory leaks
      lines.length = 0;
    };
  }, []);
  
  return (
    <div className="flex items-center justify-center bg-[#F0EEE6] w-full h-full">
      <canvas ref={canvasRef} width={550} height={550} />
    </div>
  );
};

export default VectorFieldLines;
```

```javascript
import React, { useEffect, useRef } from 'react';

// Themes: natural vitality, perfect balance, eternal spirit
// Visualization: A form that breathes and pulses with life, its hatched lines revealing the balance between structure and movement

const OscillatingHatching = () => {
  const canvasRef = useRef(null);
  const requestRef = useRef(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Set background
    ctx.fillStyle = "#F0EEE6";
    ctx.fillRect(0, 0, width, height);
    
    // Center of the canvas
    const centerX = width / 2;
    const centerY = height / 2;
    
    // Animation variables
    let time = 50;
    const timeStep = 0.004;  // Reduced to 50% speed
    
    // Noise function simulation
    const noise3D = (x, y, z, t) => {
      return Math.sin(x * 0.1 + t * 0.15) * 
             Math.cos(y * 0.1 + Math.sin(z * 0.1) + t * 0.1) * 
             Math.sin(z * 0.1 + Math.sin(x * 0.1) + t * 0.2);
    };
    
    // Parameters that define the form's vital energy
    const baseForm = {
      // Core structure that breathes and flows
      majorRadius: 80,  // Primary circle of life
      minorRadius: 30,  // Secondary pulse
      complexity: 0.8,  // Balance between order and chaos
      resolution: 36    // Clarity of form
    };
    
    // Cache for vertices to avoid regenerating every frame
    let cachedVertices = null;
    let lastCacheTime = -1;
    const cacheLifetime = 0.1; // How often to regenerate vertices
    
    // Generate vertices for the 3D form
    const generateVertices = (time) => {
      // Check if we can use the cache
      if (cachedVertices && time - lastCacheTime < cacheLifetime) {
        return cachedVertices;
      }
      
      const vertices = [];
      const resolution = baseForm.resolution;
      
      // Base radius oscillation
      const breathingFactor = Math.sin(time * 0.2) * 5;  // Reduced to 50% speed
      const majorRadius = baseForm.majorRadius + breathingFactor;
      const minorRadius = baseForm.minorRadius + breathingFactor * 0.2;
      
      // Generate points on a torus with noise deformation
      for (let i = 0; i < resolution; i++) {
        const theta = (i / resolution) * Math.PI * 2;
        
        for (let j = 0; j < resolution; j++) {
          const phi = (j / resolution) * Math.PI * 2;
          
          // Base torus coordinates
          const x = (majorRadius + minorRadius * Math.cos(phi)) * Math.cos(theta);
          const y = (majorRadius + minorRadius * Math.cos(phi)) * Math.sin(theta);
          const z = minorRadius * Math.sin(phi);
          
          // Add noise deformation that changes with time
          const noiseScale = 0.02 * baseForm.complexity;
          const timeFactor = time * 0.2;
          const noise = 
            15 * noise3D(x * noiseScale, y * noiseScale, z * noiseScale, timeFactor) +
            7 * noise3D(x * noiseScale * 2, y * noiseScale * 2, z * noiseScale * 2, timeFactor * 1.3);
            
          // Calculate normal direction (simplified)
          const normalX = x / majorRadius;
          const normalY = y / majorRadius;
          const normalZ = z / minorRadius;
          
          // Normalize the normal vector
          const normalLength = Math.sqrt(normalX*normalX + normalY*normalY + normalZ*normalZ) || 0.001;
          
          // Apply noise along normal direction
          const deformedX = x + (normalX / normalLength) * noise;
          const deformedY = y + (normalY / normalLength) * noise;
          const deformedZ = z + (normalZ / normalLength) * noise;
          
          // Create tangent vectors for hatching direction
          // Primary tangent along phi direction
          const tangent1X = -Math.sin(theta);
          const tangent1Y = Math.cos(theta);
          const tangent1Z = 0;
          
          // Secondary tangent along theta direction
          const tangent2X = -Math.cos(theta) * Math.sin(phi);
          const tangent2Y = -Math.sin(theta) * Math.sin(phi);
          const tangent2Z = Math.cos(phi);
          
          vertices.push({
            position: { 
              x: deformedX, 
              y: deformedY, 
              z: deformedZ 
            },
            normal: { 
              x: normalX / normalLength, 
              y: normalY / normalLength, 
              z: normalZ / normalLength 
            },
            tangent1: { 
              x: tangent1X, 
              y: tangent1Y, 
              z: tangent1Z 
            },
            tangent2: { 
              x: tangent2X, 
              y: tangent2Y, 
              z: tangent2Z 
            },
            theta,
            phi,
            // Pre-calculate a noise value for hatching intensity
            hatchingIntensity: 0.3 + 0.7 * Math.abs(noise3D(
              deformedX * 0.03, 
              deformedY * 0.03, 
              deformedZ * 0.03, 
              time * 0.5
            ))
          });
        }
      }
      
      // Update cache
      cachedVertices = vertices;
      lastCacheTime = time;
      
      return vertices;
    };
    
    // Project 3D point to 2D with subtle rotation
    const project = (point, time) => {
      // Add subtle rotation
      const rotX = time * 0.05;  // Reduced to 50% speed
      const rotY = time * 0.075;  // Reduced to 50% speed
      
      const cosX = Math.cos(rotX);
      const sinX = Math.sin(rotX);
      const cosY = Math.cos(rotY);
      const sinY = Math.sin(rotY);
      
      // Apply rotation around Y-axis
      const y1 = point.y;
      const z1 = point.z * cosX - point.x * sinX;
      const x1 = point.z * sinX + point.x * cosX;
      
      // Apply rotation around X-axis
      const y2 = y1 * cosY - z1 * sinY;
      const z2 = y1 * sinY + z1 * cosY;
      const x2 = x1;
      
      // Project to 2D with larger scale (closer view)
      const scale = 1.5;  // Increase this to make it appear closer
      return {
        x: centerX + x2 * scale,
        y: centerY + y2 * scale,
        z: z2  // Keep z for depth sorting
      };
    };
    
    // Calculate visibility with z-buffer
    const calculateVisibility = (projectedVertices) => {
      // Create a grid-based z-buffer
      const bufferSize = 200;
      const zBuffer = new Array(bufferSize).fill().map(() => new Array(bufferSize).fill(-Infinity));
      const visible = new Array(projectedVertices.length).fill(false);
      
      // Convert canvas coordinates to buffer indices
      const toBufferCoords = (x, y) => {
        const bx = Math.floor((x / width) * bufferSize);
        const by = Math.floor((y / height) * bufferSize);
        return { bx, by };
      };
      
      // Fill z-buffer with furthest visible points
      projectedVertices.forEach((vertex, index) => {
        const { bx, by } = toBufferCoords(vertex.x, vertex.y);
        
        if (bx >= 0 && bx < bufferSize && by >= 0 && by < bufferSize) {
          if (vertex.z > zBuffer[by][bx]) {
            zBuffer[by][bx] = vertex.z;
            visible[index] = true;
          }
        }
      });
      
      return visible;
    };
    
    // Generate hatching lines with animated oscillation
    const generateHatchingLines = (vertices, visibility, time) => {
      // Project vertices to 2D
      const projectedVertices = vertices.map(v => {
        const projection = project(v.position, time);
        return {
          ...projection,
          vertex: v
        };
      });
      
      // Determine visibility
      const isVisible = calculateVisibility(projectedVertices);
      
      // Clear canvas
      ctx.fillStyle = "#F0EEE6";
      ctx.fillRect(0, 0, width, height);
      
      // Group vertices by similar phi values to create "slices"
      const phiGroups = {};
      const phiPrecision = 0.2; // Grouping precision
      
      vertices.forEach((vertex, index) => {
        if (!isVisible[index]) return;
        
        // Round phi to group similar values
        const phiKey = Math.round(vertex.phi / phiPrecision) * phiPrecision;
        
        if (!phiGroups[phiKey]) {
          phiGroups[phiKey] = [];
        }
        
        phiGroups[phiKey].push({
          vertex,
          projectedPos: projectedVertices[index]
        });
      });
      
      // Draw primary hatching lines along phi
      Object.values(phiGroups).forEach(group => {
        if (group.length < 2) return;
        
        // Sort by theta for consistent line drawing
        group.sort((a, b) => a.vertex.theta - b.vertex.theta);
        
        // Draw with varying opacity based on depth and time
        const midPoint = group[Math.floor(group.length / 2)];
        const normalZ = midPoint.vertex.normal.z;
        
        // Make all lines visible by removing the skipping logic
        const timeOscillation = 0; // Fixed value to prevent oscillation
        const skip = false; // Never skip lines - keep them all visible
        
        // No conditional return - all lines will be drawn
        
        // Get hatching intensity from pre-calculated value
        const intensity = midPoint.vertex.hatchingIntensity;
        
        // Calculate line width and opacity based on normal direction and intensity
        const baseLightness = Math.abs(normalZ) * 0.7 + 0.3; // 0.3-1.0 range
        const baseOpacity = 0.1 + baseLightness * 0.5;
        const opacity = baseOpacity * intensity;
        
        // Calculate line width
        const width = 0.3 + intensity * 0.7;
        
        ctx.beginPath();
        
        // Start line
        const start = group[0].projectedPos;
        ctx.moveTo(start.x, start.y);
        
        // Draw line through all points in the group
        for (let i = 1; i < group.length; i++) {
          const point = group[i].projectedPos;
          
          // Add some variation to line based on time
          const variation = 0.5 * Math.sin(time + group[i].vertex.theta * 10);
          ctx.lineTo(point.x + variation, point.y + variation);
        }
        
        // Set line style
        ctx.strokeStyle = `rgba(51, 51, 51, ${opacity})`;
        ctx.lineWidth = width;
        ctx.stroke();
      });
      
      // Group vertices by similar theta values to create "rings"
      const thetaGroups = {};
      const thetaPrecision = 0.15;
      
      vertices.forEach((vertex, index) => {
        if (!isVisible[index]) return;
        
        const thetaKey = Math.round(vertex.theta / thetaPrecision) * thetaPrecision;
        
        if (!thetaGroups[thetaKey]) {
          thetaGroups[thetaKey] = [];
        }
        
        thetaGroups[thetaKey].push({
          vertex,
          projectedPos: projectedVertices[index]
        });
      });
      
      // Draw cross-hatching lines (theta groups - rings)
      Object.values(thetaGroups).forEach(group => {
        if (group.length < 2) return;
        
        // Sort by phi for consistent line drawing
        group.sort((a, b) => a.vertex.phi - b.vertex.phi);
        
        // Make all cross-hatching lines visible by removing the skipping logic
        const midPoint = group[Math.floor(group.length / 2)];
        const timeOscillation = 0; // Fixed value to prevent oscillation
        const skip = false; // Never skip lines - keep them all visible
        
        // No conditional return - all lines will be drawn
        
        // Calculate lighting and intensity similar to primary hatching
        const normalX = midPoint.vertex.normal.x;
        const normalY = midPoint.vertex.normal.y;
        const lightAngle = Math.atan2(normalY, normalX);
        const intensity = 0.3 + 0.7 * Math.abs(Math.sin(lightAngle + time * 0.02));  // Reduced time factor for more consistent intensity
        
        // Cross-hatching is slightly thinner
        const width = 0.2 + intensity * 0.6;
        const opacity = (0.1 + intensity * 0.4) * midPoint.vertex.hatchingIntensity;
        
        ctx.beginPath();
        
        // Start line
        const start = group[0].projectedPos;
        ctx.moveTo(start.x, start.y);
        
        // Draw line through all points in the group
        for (let i = 1; i < group.length; i++) {
          const point = group[i].projectedPos;
          
          // Add some variation to line based on time
          const variation = 0.3 * Math.cos(time * 1.2 + group[i].vertex.phi * 8);
          ctx.lineTo(point.x + variation, point.y + variation);
        }
        
        // Set line style
        ctx.strokeStyle = `rgba(51, 51, 51, ${opacity})`;
        ctx.lineWidth = width;
        ctx.stroke();
      });
      
      // Add accent hatches in areas of high curvature
      const accentThreshold = 0.7;
      
      projectedVertices.forEach((pVertex, index) => {
        if (!isVisible[index]) return;
        
        const vertex = pVertex.vertex;
        
        // Use pre-calculated hatching intensity to find high curvature areas
        if (vertex.hatchingIntensity > accentThreshold) {
          // Create short line segment based on tangent direction
          // Mix both tangent directions for varied hatching
          const mixFactor = Math.sin(time * 0.1 + vertex.theta * 2 + vertex.phi * 1);  // Slower, more subtle oscillation
          const tangentX = vertex.tangent1.x * (1 + mixFactor) / 2 + vertex.tangent2.x * (1 - mixFactor) / 2;
          const tangentY = vertex.tangent1.y * (1 + mixFactor) / 2 + vertex.tangent2.y * (1 - mixFactor) / 2;
          const tangentZ = vertex.tangent1.z * (1 + mixFactor) / 2 + vertex.tangent2.z * (1 - mixFactor) / 2;
          
          // Project start and end points
          const length = 3 + 5 * vertex.hatchingIntensity;
          
          const startPos = {
            x: vertex.position.x - tangentX * length,
            y: vertex.position.y - tangentY * length,
            z: vertex.position.z - tangentZ * length
          };
          
          const endPos = {
            x: vertex.position.x + tangentX * length,
            y: vertex.position.y + tangentY * length,
            z: vertex.position.z + tangentZ * length
          };
          
          const projectedStart = project(startPos, time);
          const projectedEnd = project(endPos, time);
          
          // Draw accent hatch
          ctx.beginPath();
          ctx.moveTo(projectedStart.x, projectedStart.y);
          ctx.lineTo(projectedEnd.x, projectedEnd.y);
          
          // Set style with pulsing effect
          const pulse = 0.5 + 0.5 * Math.sin(time * 0.25 + vertex.theta * 3 + vertex.phi * 2);  // Slower, less intense pulse
          const accentOpacity = 0.1 + 0.5 * pulse * vertex.hatchingIntensity;
          const accentWidth = 0.3 + 0.6 * pulse;
          
          ctx.strokeStyle = `rgba(51, 51, 51, ${accentOpacity})`;
          ctx.lineWidth = accentWidth;
          ctx.stroke();
        }
      });
    };
    
    // Animation loop
    const animate = () => {
      time += timeStep;
      
      // Generate vertices for current time
      const vertices = generateVertices(time);
      
      // Generate and draw hatching lines
      generateHatchingLines(vertices, null, time);
      
      requestRef.current = requestAnimationFrame(animate);
    };
    
    // Start animation
    animate();
    
    // Cleanup
    return () => {
      cancelAnimationFrame(requestRef.current);
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, width, height);
      }
      
      // Clear cached data to prevent memory leaks
      cachedVertices = null;
    };
    
  }, []);

  return (
    <div className="w-full h-full flex items-center justify-center bg-[#F0EEE6]">
      <canvas 
        ref={canvasRef} 
        width={550} 
        height={550} 
        className="border border-gray-300 shadow-md"
      />
    </div>
  );
};

export default OscillatingHatching;
```

```javascript
import React, { useEffect, useRef } from 'react';

// Themes: silent wisdom, primal union, profound impartiality
// Visualization: Waves that interfere and merge without resistance, showing how patterns emerge from silence

const WaveInterferenceV4 = () => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = 550;
    const height = 550;
    canvas.width = width;
    canvas.height = height;

    // Points of origin from which patterns emerge
    const sources = [];
    const gridSize = 4;  // Balance in all directions
    
    for (let i = 0; i < gridSize; i++) {
      for (let j = 0; j < gridSize; j++) {
        sources.push({
          x: width * (i + 0.5) / gridSize,
          y: height * (j + 0.5) / gridSize,
          wavelength: 15 + Math.random() * 10,  // Each source finds its rhythm
          phase: Math.random() * Math.PI * 2    // Beginning in natural harmony
        });
      }
    }

    let time = 0;
    let animationFrameId = null;

    const animate = () => {
      // Fill with project background color
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, width, height);

      // Create overlay for smoother lines
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 0.5;

      // Sample points for marching squares algorithm
      const resolution = 2;
      const rows = Math.floor(height / resolution);
      const cols = Math.floor(width / resolution);
      const field = new Array(rows).fill(0).map(() => new Array(cols).fill(0));

      // Calculate wave field
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const x = j * resolution;
          const y = i * resolution;
          let amplitude = 0;

          sources.forEach(source => {
            const dx = x - source.x;
            const dy = y - source.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const phase = i * Math.PI / 3; // Different phase for each source
            amplitude += Math.sin((distance / source.wavelength - time) * 2 * Math.PI + phase);
          });

          field[i][j] = amplitude / sources.length;
        }
      }

      // Draw contour lines using marching squares
      const contourLevels = [-0.6, -0.3, 0, 0.3, 0.6];
      
      contourLevels.forEach(level => {
        ctx.beginPath();
        
        for (let i = 0; i < rows - 1; i++) {
          for (let j = 0; j < cols - 1; j++) {
            const x = j * resolution;
            const y = i * resolution;
            
            // Marching squares cases
            const case4 = 
              (field[i][j] > level ? 8 : 0) +
              (field[i][j + 1] > level ? 4 : 0) +
              (field[i + 1][j + 1] > level ? 2 : 0) +
              (field[i + 1][j] > level ? 1 : 0);
            
            // Draw line segments based on case
            switch (case4) {
              case 1: case 14:
                ctx.moveTo(x, y + resolution / 2);
                ctx.lineTo(x + resolution / 2, y + resolution);
                break;
              case 2: case 13:
                ctx.moveTo(x + resolution / 2, y + resolution);
                ctx.lineTo(x + resolution, y + resolution / 2);
                break;
              case 3: case 12:
                ctx.moveTo(x, y + resolution / 2);
                ctx.lineTo(x + resolution, y + resolution / 2);
                break;
              case 4: case 11:
                ctx.moveTo(x + resolution, y + resolution / 2);
                ctx.lineTo(x + resolution / 2, y);
                break;
              case 5: case 10:
                ctx.moveTo(x, y + resolution / 2);
                ctx.lineTo(x + resolution / 2, y);
                ctx.moveTo(x + resolution, y + resolution / 2);
                ctx.lineTo(x + resolution / 2, y + resolution);
                break;
              case 6: case 9:
                ctx.moveTo(x + resolution / 2, y);
                ctx.lineTo(x + resolution / 2, y + resolution);
                break;
              case 7: case 8:
                ctx.moveTo(x, y + resolution / 2);
                ctx.lineTo(x + resolution / 2, y);
                break;
            }
          }
        }
        
        ctx.stroke();
      });

      time += 0.003; // Further reduced from 0.005 to 0.001
      animationFrameId = requestAnimationFrame(animate);
    };

    animate();

    return () => {
      // Cancel animation frame to prevent memory leaks
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
    };
  }, []);

  return (
    <div style={{ 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center',
      width: '100vw', 
      height: '100vh', 
      backgroundColor: '#F0EEE6' 
    }}>
      <canvas 
        ref={canvasRef} 
        style={{ 
          border: '1px solid #eee',
          width: '550px',
          height: '550px'
        }} 
      />
    </div>
  );
};

export default WaveInterferenceV4;
```

```javascript
import React, { useEffect, useRef } from 'react';

// Themes: leadership through non-control, natural organization, peace through letting go
// Visualization: Circles that organize themselves into complex patterns, demonstrating how order emerges without force

const MoireMandalaPattern = () => {
  const canvasRef = useRef(null);
  const animationFrameId = useRef<number>(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    canvas.width = 550;
    canvas.height = 550;
    
    const drawPattern = (time = 0) => {
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 0.6;
      
      // Center of the canvas
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      
      // Each layer finds its natural place in the whole
      const layers = [
        { count: 1, radius: 0, circleSize: 60 },        // The still center
        { count: 6, radius: 60, circleSize: 60 },       // First emanation
        { count: 12, radius: 110, circleSize: 50 },     // Growing outward
        { count: 18, radius: 160, circleSize: 45 },     // Expanding freely
        { count: 24, radius: 205, circleSize: 40 }      // Reaching completion
      ];
      
      layers.forEach((layer, layerIndex) => {
        for (let i = 0; i < layer.count; i++) {
          const angle = (i / layer.count) * Math.PI * 2;
          
          // Add subtle animation
          const breathingEffect = Math.sin(time * 0.0015 + layerIndex * 0.5) * 2;  // Halved speed
          const rotation = time * 0.00025 * (layerIndex % 2 === 0 ? 1 : -1);  // Halved speed
          
          // Position each circle around the center with animation
          const circleX = centerX + Math.cos(angle + rotation) * layer.radius;
          const circleY = centerY + Math.sin(angle + rotation) * layer.radius;
          
          // Draw concentric circles for each position
          for (let r = 3; r < layer.circleSize; r += 3) {
            ctx.beginPath();
            
            // Subtle distortion for moiré effect
            for (let theta = 0; theta <= Math.PI * 2; theta += 0.1) {
              const distortion = Math.sin(theta * 8 + time * 0.0025 + angle) * (r * 0.01);  // Halved speed
              const radiusDistortion = Math.sin(time * 0.005 + r * 0.1) * 2;
              
              const x = circleX + (r + distortion + breathingEffect) * Math.cos(theta);
              const y = circleY + (r + distortion + breathingEffect) * Math.sin(theta);
              
              if (theta === 0) {
                ctx.moveTo(x, y);
              } else {
                ctx.lineTo(x, y);
              }
            }
            
            ctx.closePath();
            ctx.stroke();
          }
        }
      });
      
      // Add a central decorative pattern
      const centralSize = 80;
      for (let r = 3; r < centralSize; r += 3) {
        ctx.beginPath();
        
        for (let theta = 0; theta <= Math.PI * 2; theta += 0.05) {
          const distortion = Math.sin(theta * 6 + time * 0.0025) * (r * 0.015);  // Halved speed
          const breathing = Math.sin(time * 0.002) * 1.5;  // Halved speed
          
          const x = centerX + (r + distortion + breathing) * Math.cos(theta);
          const y = centerY + (r + distortion + breathing) * Math.sin(theta);
          
          if (theta === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        ctx.closePath();
        ctx.stroke();
      }
      
      animationFrameId.current = requestAnimationFrame(() => drawPattern(time + 1));
    };
    
    drawPattern();

    return () => {
      if (animationFrameId.current) {
        cancelAnimationFrame(animationFrameId.current);
      }
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      
      // Reset animation frame ref
      animationFrameId.current = null;
    };

  }, []);
  
  return (
    <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', backgroundColor: '#F0EEE6' }}>
      <canvas ref={canvasRef} style={{ boxShadow: '0 0 20px rgba(0,0,0,0.1)' }} />
    </div>
  );
};

export default MoireMandalaPattern;
```

```javascript
import { useRef, useEffect } from 'react';

const BreathingRhombus = () => {
  const containerRef = useRef(null);
  
  useEffect(() => {
    if (!containerRef.current) return;
    
    const container = containerRef.current;
    let animationFrameId = null;
    let isComponentMounted = true;
    const createdElements = [];
    
    // Clear any existing content
    container.innerHTML = '';
    
    const numRhombi = 9;
    
    // Get container dimensions for responsive sizing
    const containerWidth = container.offsetWidth;
    const containerHeight = container.offsetHeight;
    const scaleFactor = containerWidth / 322; // Base container width
    
    // Create SVG pattern for texture
    const patternSVG = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
    patternSVG.setAttribute('width', '0');
    patternSVG.setAttribute('height', '0');
    patternSVG.innerHTML = `
      <defs>
        <pattern id="crackedTexture" x="0" y="0" width="100" height="100" patternUnits="userSpaceOnUse">
          <rect width="100" height="100" fill="#444" opacity="0.1"/>
          <path d="M20,20 L40,15 L35,40 M60,30 L80,25 L75,50 M10,70 L30,65 L25,90" 
                stroke="#333" stroke-width="0.5" fill="none" opacity="0.3"/>
        </pattern>
      </defs>
    `;
    container.appendChild(patternSVG);
    createdElements.push(patternSVG);
    
    // Create rhombi with responsive sizing
    for (let i = 0; i < numRhombi; i++) {
      const baseSize = 80 + Math.sin((i / numRhombi) * Math.PI) * 60;
      const size = baseSize * scaleFactor;
      const baseYPos = i * 40;
      const yPos = baseYPos * scaleFactor;
      
      const rhombusDiv = document.createElement('div');
      rhombusDiv.className = 'rhombus';
      rhombusDiv.style.position = 'absolute';
      rhombusDiv.style.left = '50%';
      rhombusDiv.style.top = `${yPos}px`;
      rhombusDiv.style.transform = 'translateX(-50%)';
      rhombusDiv.style.transition = 'all 0.3s ease';
      rhombusDiv.dataset.index = i;
      rhombusDiv.dataset.originalSize = size;
      
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', size);
      svg.setAttribute('height', size * 0.6);
      svg.setAttribute('viewBox', '0 0 100 60');
      
      const texturePoly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      texturePoly.setAttribute('points', '50,0 100,30 50,60 0,30');
      texturePoly.setAttribute('fill', 'url(#crackedTexture)');
      texturePoly.setAttribute('opacity', '0.15');
      
      const shapePoly = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      shapePoly.setAttribute('points', '50,0 100,30 50,60 0,30');
      shapePoly.setAttribute('fill', 'none');
      shapePoly.setAttribute('stroke', '#333');
      shapePoly.setAttribute('stroke-width', '0.5');
      shapePoly.setAttribute('opacity', '0.8');
      
      const lines = [
        { x1: '50', y1: '0', x2: '50', y2: '60' },
        { x1: '0', y1: '30', x2: '100', y2: '30' },
        { x1: '25', y1: '15', x2: '75', y2: '45' },
        { x1: '75', y1: '15', x2: '25', y2: '45' }
      ];
      
      const lineElems = lines.map(coords => {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', coords.x1);
        line.setAttribute('y1', coords.y1);
        line.setAttribute('x2', coords.x2);
        line.setAttribute('y2', coords.y2);
        line.setAttribute('stroke', '#444');
        line.setAttribute('stroke-width', '0.3');
        line.setAttribute('opacity', '0.6');
        line.classList.add('inner-lines');
        return line;
      });
      
      svg.appendChild(texturePoly);
      svg.appendChild(shapePoly);
      lineElems.forEach(line => svg.appendChild(line));
      
      rhombusDiv.appendChild(svg);
      container.appendChild(rhombusDiv);
      createdElements.push(rhombusDiv);
    }
    
    // Animate breathing effect with mount check
    function animateBreathing() {
      if (!isComponentMounted || !container) return;
      
      const rhombi = container.querySelectorAll('.rhombus');
      if (rhombi.length === 0) return;
      
      const time = Date.now() / 1000;
      
      rhombi.forEach((rhombus, index) => {
        const originalSize = parseFloat(rhombus.dataset.originalSize || '100');
        const delay = index * 0.25;
        const breathAmount = Math.sin(time * 0.4 + delay) * 0.15 + 1;
        const rotation = Math.sin(time * 0.5 + delay) * 3;
        
        if (rhombus instanceof HTMLElement) {
          rhombus.style.transform = `translateX(-50%) scale(${breathAmount}) rotate(${rotation}deg)`;
          
          // Animate opacity based on breath
          const shapes = rhombus.querySelectorAll('polygon, line');
          shapes.forEach(shape => {
            if (shape.getAttribute('stroke')) {
              (shape as SVGElement).style.opacity = (0.2 + Math.sin(time * 0.4 + delay) * 0.3).toString();
            }
          });
        }
      });
      
      if (isComponentMounted) {
        animationFrameId = requestAnimationFrame(animateBreathing);
      }
    }
    
    // Start animation only if component is mounted
    if (isComponentMounted) {
      animateBreathing();
    }
    
    // Comprehensive cleanup function
    return () => {
      // Mark component as unmounted to stop animations
      isComponentMounted = false;
      
      // Cancel any pending animation frame
      if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      // Clear all created elements and their references
      createdElements.forEach(element => {
        if (element && element.parentNode) {
          element.parentNode.removeChild(element);
        }
        // Clear any element-specific properties
        if (element instanceof HTMLElement) {
          element.style.transform = '';
          element.style.opacity = '';
          element.style.transition = '';
        }
      });
      
      // Clear container content completely
      if (container) {
        // Remove any residual event listeners on container
        container.onmouseenter = null;
        container.onmouseleave = null;
        container.onclick = null;
        
        // Clear all child nodes
        while (container.firstChild) {
          container.removeChild(container.firstChild);
        }
        
        // Reset container styles
        container.innerHTML = '';
      }
      
      // Clear the created elements array
      createdElements.length = 0;
    };
  }, []);
  
  return (
    <div className="w-full h-full flex items-center justify-center"
      style={{
        position: 'relative',
        overflow: 'hidden',
      }}
    >
      <div 
        ref={containerRef} 
        className="relative w-full h-full"
        style={{ 
          width: '100%', 
          maxWidth: '322px',
          aspectRatio: '1/1',
          backgroundColor: '#F0EEE6',
          overflow: 'hidden',
          borderRadius: '4px',
          position: 'relative',
        }}
      />
    </div>
  );
};

export default BreathingRhombus;
```

```javascript
import React, { useEffect, useRef } from 'react';

// Themes: power of simplicity, giving up ideas, deep rootedness
// Visualization: Forms that emerge from simple mathematical rules, showing how complexity arises from fundamental principles

const ImplicitDreams = () => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Center of canvas
    const centerX = width / 2;
    const centerY = height / 2;
    
    // Simple parameters from which complexity grows
    let time = 0;
    const scale = 120;  // The space in which forms manifest
    
    // Create the underlying structure
    const resolution = 40;  // Balance between detail and simplicity
    const gridPoints = [];
    const cellSize = 8;  // The fundamental unit
    
    for (let i = 0; i < resolution; i++) {
      for (let j = 0; j < resolution; j++) {
        gridPoints.push({
          i: i,
          j: j,
          x: (i - resolution/2) * cellSize,
          y: (j - resolution/2) * cellSize,
          value: 0,
          flowOffset: Math.random() * Math.PI * 2
        });
      }
    }
    
    // Function to evaluate implicit surface value at a point
    const evaluateImplicitFunction = (x, y, t) => {
      // Normalize coordinates
      const nx = x / scale;
      const ny = y / scale;
      
      // Base implicit function (blob shape)
      let value = nx*nx + ny*ny - 1;
      
      // Add bulges and morphing effects
      const morphFactor = Math.sin(t * 0.1) * 0.5 + 0.5;  // Halved speed
      
      // Shape 1: More rounded
      const shape1 = nx*nx + ny*ny * (1.2 + 0.3 * Math.sin(t * 0.15)) - 1;  // Halved speed
      
      // Shape 2: More elongated
      const angle = Math.atan2(ny, nx);
      const r = Math.sqrt(nx*nx + ny*ny);
      const shape2 = r * (1 + 0.3 * Math.sin(angle * 2 + t * 0.1)) - 1;  // Halved speed
      
      // Blend between shapes
      value = shape1 * (1 - morphFactor) + shape2 * morphFactor;
      
      // Add some organic variation
      value += 0.2 * Math.sin(nx * 3 + t * 0.1) * Math.sin(ny * 3 + t * 0.15);  // Halved speed
      value += 0.1 * Math.sin(nx * 5 + ny * 5 + t * 0.05);  // Halved speed
      
      // Add a bulge on one side
      value -= 0.4 * Math.exp(-(nx - 0.5) * (nx - 0.5) * 4 - ny * ny * 4) * Math.sin(t * 0.15);  // Halved speed
      
      return value;
    };
    
    // Function to update grid point values
    const updateGridValues = (t) => {
      gridPoints.forEach(point => {
        point.value = evaluateImplicitFunction(point.x, point.y, t);
      });
    };
    
    // Function to generate contour lines
    const generateContours = () => {
      const contourLines = [];
      const thresholds = Array(10).fill().map((_, i) => -0.5 + i * 0.1);
      
      // For each cell in the grid
      for (let i = 0; i < resolution - 1; i++) {
        for (let j = 0; j < resolution - 1; j++) {
          const index = i * resolution + j;
          
          // Get the four corners of this cell - with bounds checking
          const topLeft = gridPoints[index];
          const topRight = gridPoints[index + 1];
          const bottomLeft = gridPoints[index + resolution];
          const bottomRight = gridPoints[index + resolution + 1];
          
          // Skip if any corner is undefined
          if (!topLeft || !topRight || !bottomLeft || !bottomRight) {
            continue;
          }
          
          // For each contour threshold
          thresholds.forEach(threshold => {
            // Check each edge of the cell for intersections
            const points = [];
            
            // Top edge
            if ((topLeft.value < threshold && topRight.value >= threshold) ||
                (topLeft.value >= threshold && topRight.value < threshold)) {
              const t = (threshold - topLeft.value) / (topRight.value - topLeft.value);
              points.push({
                x: topLeft.x + t * (topRight.x - topLeft.x),
                y: topLeft.y,
                flowOffset: (topLeft.flowOffset + topRight.flowOffset) / 2
              });
            }
            
            // Right edge
            if ((topRight.value < threshold && bottomRight.value >= threshold) ||
                (topRight.value >= threshold && bottomRight.value < threshold)) {
              const t = (threshold - topRight.value) / (bottomRight.value - topRight.value);
              points.push({
                x: topRight.x,
                y: topRight.y + t * (bottomRight.y - topRight.y),
                flowOffset: (topRight.flowOffset + bottomRight.flowOffset) / 2
              });
            }
            
            // Bottom edge
            if ((bottomLeft.value < threshold && bottomRight.value >= threshold) ||
                (bottomLeft.value >= threshold && bottomRight.value < threshold)) {
              const t = (threshold - bottomLeft.value) / (bottomRight.value - bottomLeft.value);
              points.push({
                x: bottomLeft.x + t * (bottomRight.x - bottomLeft.x),
                y: bottomLeft.y,
                flowOffset: (bottomLeft.flowOffset + bottomRight.flowOffset) / 2
              });
            }
            
            // Left edge
            if ((topLeft.value < threshold && bottomLeft.value >= threshold) ||
                (topLeft.value >= threshold && bottomLeft.value < threshold)) {
              const t = (threshold - topLeft.value) / (bottomLeft.value - topLeft.value);
              points.push({
                x: topLeft.x,
                y: topLeft.y + t * (bottomLeft.y - topLeft.y),
                flowOffset: (topLeft.flowOffset + bottomLeft.flowOffset) / 2
              });
            }
            
            // If we found 2 intersection points, we have a line
            if (points.length === 2) {
              contourLines.push({
                x1: points[0].x,
                y1: points[0].y,
                x2: points[1].x,
                y2: points[1].y,
                threshold: threshold,
                flowOffset1: points[0].flowOffset,
                flowOffset2: points[1].flowOffset
              });
            }
          });
        }
      }
      
      return contourLines;
    };
    
    // Function to draw animated contour lines
    const drawContours = (contourLines, t) => {
      contourLines.forEach(line => {
        // Calculate line properties based on threshold
        const alpha = 0.2 + 0.6 * Math.abs(line.threshold);
        const width = 0.5 + Math.abs(line.threshold) * 0.5;
        
        ctx.strokeStyle = `rgba(51, 51, 51, ${alpha})`;
        ctx.lineWidth = width;
        
        // Draw flowing line
        ctx.beginPath();
        
        // Create flowing effect along the line
        const numSegments = 20;
        const startX = line.x1;
        const startY = line.y1;
        const endX = line.x2;
        const endY = line.y2;
        
        ctx.moveTo(centerX + startX, centerY + startY);
        
        for (let i = 1; i <= numSegments; i++) {
          const progress = i / numSegments;
          
          // Basic linear interpolation
          const x = startX + (endX - startX) * progress;
          const y = startY + (endY - startY) * progress;
          
          // Add flowing wave effects
          const flowSpeed = 0.5 + 0.5 * Math.sin(line.threshold * 10);
          const flowOffset = line.flowOffset1 + (line.flowOffset2 - line.flowOffset1) * progress;
          const waveAmplitude = 3 * Math.sin(line.threshold * 5 + t * 0.2);
          
          const perpX = -(endY - startY) / Math.sqrt((endX - startX) * (endX - startX) + (endY - startY) * (endY - startY));
          const perpY = (endX - startX) / Math.sqrt((endX - startX) * (endX - startX) + (endY - startY) * (endY - startY));
          
          const waveX = perpX * waveAmplitude * Math.sin(progress * Math.PI * 2 + t * flowSpeed + flowOffset);
          const waveY = perpY * waveAmplitude * Math.sin(progress * Math.PI * 2 + t * flowSpeed + flowOffset);
          
          ctx.lineTo(centerX + x + waveX, centerY + y + waveY);
        }
        
        ctx.stroke();
      });
    };
    
    // Main animation loop
    const animate = () => {
      // Clear canvas
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, width, height);
      
      // Update time
      time += 0.005;  // Halved speed
      
      // Update grid values
      updateGridValues(time);
      
      // Generate contour lines
      const contourLines = generateContours();
      
      // Draw contours
      drawContours(contourLines, time);
      
      // Continue animation
      requestAnimationFrame(animate);
    };
    
    // Start animation
    const animationId = requestAnimationFrame(animate);
    
    // Cleanup
    return () => {
      cancelAnimationFrame(animationId);
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, width, height);
      }
      
      // Clear grid points array to prevent memory leaks
      if (gridPoints) {
        gridPoints.length = 0;
      }
    };
  }, []);

  return (
    <div className="flex justify-center items-center bg-[#F0EEE6] w-full h-full">
      <canvas 
        ref={canvasRef} 
        width={550} 
        height={550} 
        className="max-w-full max-h-full"
      />
    </div>
  );
};

export default ImplicitDreams;
```

```javascript
import React, { useRef, useEffect } from 'react'
import * as THREE from 'three'

// Themes: gentle leadership, minimal intervention, natural resolution
// Visualization: A spiral system that finds its own balance, demonstrating how light guidance allows natural patterns to emerge

const metadata = {
  themes: "gentle leadership, minimal intervention, natural resolution",
  visualization: "A spiral system that finds its own balance through minimal guidance",
  promptSuggestion: "1. Enhance flow transitions\n2. Add more transformation points\n3. Develop smoother progressions\n4. Create stronger movement paths\n5. Increase sense of change"
};

const FlowLine = ({ points, radius, height, twist, phase, scene, parent }) => {
  // Each line finds its own path through space
  const linePoints = [];
  
  for (let i = 0; i <= points; i++) {
    const t = i / points;
    const angle = t * Math.PI * 2 * twist + phase;  // Natural rotation
    const r = radius * (1 + Math.sin(t * Math.PI * 3) * 0.5);  // Gentle expansion
    const h = height * t + Math.sin(t * Math.PI * 2) * 1.2;    // Subtle rise and fall
    
    const x = Math.cos(angle) * r;
    const z = Math.sin(angle) * r;
    linePoints.push(new THREE.Vector3(x, h, z));
  }

  // Create geometry for the line
  const geometry = new THREE.BufferGeometry().setFromPoints(linePoints);
  
  // Create material for the line
  const material = new THREE.LineBasicMaterial({
    color: 0x666666,
    transparent: true,
    opacity: 0.5,
    linewidth: 0.5  // Note: linewidth only works on Windows for certain renderers
  });

  // Create the line and add to parent
  const line = new THREE.Line(geometry, material);
  parent.add(line);

  return line;
};

const FlowStructure = ({ baseRadius, baseHeight, scene, parent }) => {
  const count = 24;
  const lines = [];

  for (let i = 0; i < count; i++) {
    const props = {
      points: 50,
      radius: baseRadius * (1 + Math.sin(i / count * Math.PI * 2) * 0.2),
      height: baseHeight * (1 + Math.cos(i / count * Math.PI * 2) * 0.2),
      twist: 2.5 + Math.sin(i / count * Math.PI) * 0.8, // Increased twist variation
      phase: (i / count) * Math.PI * 2
    };

    const line = FlowLine({ ...props, scene, parent });
    lines.push(line);
  }

  return lines;
};

const SpiralStorm = () => {
  const mountRef = useRef(null);
  const groupRef = useRef(null);

  useEffect(() => {
    if (!mountRef.current) return;

    // Setup scene, camera, and renderer
    const scene = new THREE.Scene();
    // Set background color to match original
    scene.background = new THREE.Color(0xf0eee7); // rgb(240, 238, 231)
    
    const camera = new THREE.PerspectiveCamera(
      75,
      mountRef.current.clientWidth / mountRef.current.clientHeight,
      0.1,
      1000
    );
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    
    renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
    mountRef.current.appendChild(renderer.domElement);

    // Create group and add to scene
    const group = new THREE.Group();
    groupRef.current = group;
    scene.add(group);

    // Main flow structures
    FlowStructure({ baseRadius: 2, baseHeight: 3, scene, parent: group });
    
    // Secondary flow structures
    const group2 = new THREE.Group();
    group2.position.set(0, -2.5, 0);
    group2.rotation.set(Math.PI * 0.1, 0, 0);
    FlowStructure({ baseRadius: 1.5, baseHeight: 2, scene, parent: group2 });
    group.add(group2);
    
    const group3 = new THREE.Group();
    group3.position.set(0, 1.5, 0);
    group3.rotation.set(-Math.PI * 0.1, Math.PI * 0.5, 0);
    FlowStructure({ baseRadius: 1, baseHeight: 1.5, scene, parent: group3 });
    group.add(group3);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);
    
    const pointLight = new THREE.PointLight(0xffffff, 0.4);
    pointLight.position.set(-5, 3, -5);
    scene.add(pointLight);

    // Position camera
    camera.position.z = 7;
    camera.position.y = 0;
    camera.lookAt(0, 0, 0);

    // Animation loop
    const clock = new THREE.Clock();
    let animationFrameId;
    
    const animate = () => {
      animationFrameId = requestAnimationFrame(animate);
      
      const time = clock.getElapsedTime();
      
      if (groupRef.current) {
        groupRef.current.rotation.y = Math.sin(time * 0.2) * 0.5; // Increased rotation speed and range
        groupRef.current.rotation.x = Math.cos(time * 0.15) * 0.3; // Increased tilt movement
      }

      renderer.render(scene, camera);
    };

    animate();

    // Handle resize
    const handleResize = () => {
      if (!mountRef.current) return;
      
      const width = mountRef.current.clientWidth;
      const height = mountRef.current.clientHeight;
      
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setSize(width, height);
    };

    window.addEventListener('resize', handleResize);

    // Cleanup
    return () => {
      // Cancel animation frame
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      // Remove event listeners
      window.removeEventListener('resize', handleResize);
      
      // Dispose of geometries, materials, and textures
      scene.traverse((object) => {
        if (object instanceof THREE.Mesh || object instanceof THREE.Line) {
          if (object.geometry) {
            object.geometry.dispose();
          }
          if (object.material) {
            if (Array.isArray(object.material)) {
              object.material.forEach(material => {
                if (material.dispose) material.dispose();
              });
            } else {
              if (object.material.dispose) object.material.dispose();
            }
          }
        }
      });
      
      // Dispose of renderer
      renderer.dispose();
      renderer.forceContextLoss();
      
      // Remove the renderer's canvas from the DOM
      if (mountRef.current && renderer.domElement.parentNode === mountRef.current) {
        mountRef.current.removeChild(renderer.domElement);
      }
      
      // Clear references
      groupRef.current = null;
    };
  }, []);

  return (
    <div 
      ref={mountRef} 
      style={{ 
        width: '100%', 
        height: '100vh', 
        backgroundColor: '#f0eee7' // Match scene background
      }} 
    />
  );
};

SpiralStorm.metadata = metadata;
export default SpiralStorm;
```

```javascript
import React, { useEffect, useRef } from 'react';

// Themes: natural hierarchy, feminine power, mutual submission
// Visualization: A lattice where each element yields to others, creating harmony through gentle influence

const FlowingLattice = () => {
  const canvasRef = useRef(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width = 550;
    const height = canvas.height = 550;
    
    // Parameters that define the system's natural order
    const GRID_SIZE = 8;
    const CELL_SIZE = 16;
    const SPACING = CELL_SIZE * 1.8;  // Room for movement
    const HEX_HEIGHT = Math.sqrt(3) * CELL_SIZE;  // Natural proportion
    
    const cells = [];
    
    // Create cells that will flow together
    for (let row = -GRID_SIZE; row <= GRID_SIZE; row++) {
      const isEvenRow = row % 2 === 0;
      const colOffset = isEvenRow ? 0 : SPACING / 2;
      
      for (let col = -GRID_SIZE; col <= GRID_SIZE; col++) {
        const x = width/2 + col * SPACING + colOffset;
        const y = height/2 + row * HEX_HEIGHT * 0.75;
        const phase = (row + col) * 0.2;
        
        cells.push({ x, y, phase });
      }
    }
    
    let time = 0;
    let animationFrameId: number;
    
    // Draw hexagon
    function drawHexagon(x, y, size, rotation) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rotation);
      
      ctx.beginPath();
      for (let i = 0; i <= 6; i++) {
        const angle = (i / 6) * Math.PI * 2 + Math.PI / 6;
        const radius = size;
        const px = Math.cos(angle) * radius;
        const py = Math.sin(angle) * radius;
        
        if (i === 0) {
          ctx.moveTo(px, py);
        } else {
          ctx.lineTo(px, py);
        }
      }
      ctx.closePath();
      
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.22)';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      ctx.restore();
    }
    
    function animate() {
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, width, height);
      
      time += 0.008;  // Halved speed
      
      // Enhanced rotation of the entire lattice
      const globalRotation = Math.sin(time * 0.1) * 0.15;  // Halved speed
      
      cells.forEach(cell => {
        const dx = cell.x - width/2;
        const dy = cell.y - height/2;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Ripple effect
        const wave = Math.sin(
          time * 1 + // Halved speed
          cell.phase + 
          distance * 0.06 // Increased ripple frequency
        );
        
        const scale = 0.8 + wave * 0.25; // Increased scale variation
        const rotation = wave * 0.25 + globalRotation; // Increased individual rotation
        
        drawHexagon(cell.x, cell.y, CELL_SIZE * scale, rotation);
      });
      
      animationFrameId = requestAnimationFrame(animate);
    }
    
    animate();
    
    return () => {
      // Cancel the animation frame to prevent memory leaks
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = undefined;
      }
      
      // Clear the canvas when unmounting
      if (ctx) {
        ctx.clearRect(0, 0, width, height);
      }
      
      // Clear the cells array to prevent memory leaks
      if (cells) {
        cells.length = 0;
      }
      
      // Reset time variable
      time = 0;
    };
  }, []);
  
  return (
    <div style={{
      width: '550px',
      height: '550px',
      margin: 'auto',
      backgroundColor: '#F0EEE6',
      overflow: 'hidden'
    }}>
      <canvas
        ref={canvasRef}
        style={{
          display: 'block',
          width: '550px',
          height: '550px'
        }}
      />
    </div>
  );
};

export default FlowingLattice;
```

```javascript
import { useRef, useEffect, useState } from 'react';

// Themes: universal treasure, Source as refuge, forgiveness in alignment
// Visualization: Particles that spiral around a central point of energy, showing how all things return to Source

const EffortlessParticles: React.FC<{ count?: number }> = ({ count = 20000 }) => {
  const containerRef = useRef<HTMLDivElement>(null)
  const pointsRef = useRef<THREE.Points | null>(null)
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null)
  const sceneRef = useRef<THREE.Scene | null>(null)
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null)
  const clockRef = useRef<THREE.Clock | null>(null)
  const animationFrameRef = useRef<number | null>(null)

  // Create particle material
  const particleMaterial = useMemo(() => {
    return new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        opacity: { value: 0.9 }
      },
      vertexShader: `
        uniform float time;
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        
        void main() {
          vColor = customColor;
          vec3 pos = position;
          
          // Calculate natural flow based on position
          float t = time * 0.2;
          float radius = length(pos.xz);
          float angle = atan(pos.z, pos.x);
          
          // Effortless transformation
          float flow = sin(t + radius * 2.0 - angle) * cos(t * 0.7 + angle * 3.0);
          
          // Vertical oscillation creating layers
          float layer = floor(pos.y * 2.0) * 0.5;
          float layerPhase = t + layer;
          
          // Complex autonomous motion
          vec3 motion;
          motion.x = cos(layerPhase) * sin(t * 0.5 + pos.z) * 0.5;
          motion.y = sin(layerPhase * 0.7) * 0.3;
          motion.z = sin(layerPhase) * cos(t * 0.5 + pos.x) * 0.5;
          
          // Apply transformations
          pos += motion * (1.0 + flow * 0.3);
          
          // Scale up the overall effect
          pos *= 0.6;
          
          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_PointSize = size * (192.0 / -mvPosition.z);
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        uniform float opacity;
        varying vec3 vColor;
        void main() {
          float dist = length(gl_PointCoord - vec2(0.5));
          if (dist > 0.5) discard;
          float alpha = (1.0 - smoothstep(0.45, 0.5, dist)) * opacity;
          gl_FragColor = vec4(vColor, alpha);
        }
      `,
      transparent: true,
      depthWrite: false
    })
  }, [])

  // Generate particles in layered formations
  const [positions, colors, sizes] = useMemo(() => {
    const pos = new Float32Array(count * 3)
    const col = new Float32Array(count * 3)
    const siz = new Float32Array(count)

    for (let i = 0; i < count; i++) {
      // Each layer represents a level of return to Source
      const layer = Math.floor(i / (count / 5)) - 2 // Five stages of return
      const t = (i % (count / 5)) / (count / 5)
      const radius = Math.sqrt(t) * 3 // Distance from center
      const angle = t * Math.PI * 15 // Path of return
      
      pos[i * 3] = Math.cos(angle) * radius
      pos[i * 3 + 1] = layer * 1.2 // More vertical separation
      pos[i * 3 + 2] = Math.sin(angle) * radius

      // Rich grays for depth
      const baseShade = 0.3
      const variation = Math.random() * 0.15
      const shade = baseShade + variation
      col[i * 3] = shade
      col[i * 3 + 1] = shade
      col[i * 3 + 2] = shade

      // Particle sizes ranging from 0.06 to 0.10
      siz[i] = 0.12 + Math.random() * 0.04
    }

    return [pos, col, siz]
  }, [count])

  useEffect(() => {
    if (!containerRef.current) return

    // Initialize Three.js
    const scene = new THREE.Scene()
    const camera = new THREE.PerspectiveCamera(75, containerRef.current.clientWidth / containerRef.current.clientHeight, 0.1, 1000)
    const renderer = new THREE.WebGLRenderer({ antialias: true })
    const clock = new THREE.Clock()

    sceneRef.current = scene
    cameraRef.current = camera
    rendererRef.current = renderer
    clockRef.current = clock

    // Set pixel ratio for sharp rendering on high DPI displays
    const pixelRatio = window.devicePixelRatio || 1
    renderer.setPixelRatio(pixelRatio)
    renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight)
    containerRef.current.appendChild(renderer.domElement)

    // Set background color
    scene.background = new THREE.Color('#F0EEE6')
    
    // Set initial camera position
    camera.position.z = 5

    // Create particles
    const geometry = new THREE.BufferGeometry()
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))
    geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3))
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1))

    const points = new THREE.Points(geometry, particleMaterial)
    pointsRef.current = points
    scene.add(points)

    // Animation loop
    const animate = () => {
      animationFrameRef.current = requestAnimationFrame(animate)
      
      const time = clock.getElapsedTime()
      particleMaterial.uniforms.time.value = time
      
      renderer.render(scene, camera)
    }

    animate()

    // Handle resize
    const handleResize = () => {
      if (!containerRef.current || !camera || !renderer) return
      
      camera.aspect = containerRef.current.clientWidth / containerRef.current.clientHeight
      camera.updateProjectionMatrix()
      renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight)
      // Maintain pixel ratio on resize
      const pixelRatio = window.devicePixelRatio || 1
      renderer.setPixelRatio(pixelRatio)
    }

    window.addEventListener('resize', handleResize)

    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize)
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current)
        animationFrameRef.current = null
      }
      
      // Clean up Three.js objects
      if (pointsRef.current && sceneRef.current) {
        sceneRef.current.remove(pointsRef.current)
        pointsRef.current = null
      }
      
      if (geometry) {
        geometry.dispose()
      }
      
      // Clean up renderer and canvas
      if (rendererRef.current) {
        if (containerRef.current && rendererRef.current.domElement && containerRef.current.contains(rendererRef.current.domElement)) {
          containerRef.current.removeChild(rendererRef.current.domElement)
        }
        rendererRef.current.dispose()
        rendererRef.current.forceContextLoss()
        rendererRef.current = null
      }
      
      // Clean up scene
      if (sceneRef.current) {
        sceneRef.current.clear()
        sceneRef.current = null
      }
      
      // Clean up camera
      if (cameraRef.current) {
        cameraRef.current = null
      }
      
      // Clean up clock
      if (clockRef.current) {
        clockRef.current = null
      }
    }
  }, [count, positions, colors, sizes, particleMaterial])

  return <div ref={containerRef} style={{ width: '100%', height: '100%' }} />
}

const Artwork63v2: React.FC = () => {
  return (
    <div style={{ width: '100vw', height: '100vh', top: 0, left: 0 }}>
      <EffortlessParticles />
    </div>
  )
}

const metadata = {
  themes: "Accomplishing through non-doing, seeing the large in the small",
  visualization: "Particles flowing in effortless, self-organizing patterns",
  promptSuggestion: "1. Add subtle flow variations\n2. Create self-organizing waves\n3. Vary effortless patterns naturally\n4. Introduce gentle layer transitions\n5. Make motion follow natural rhythms"
}

Artwork63v2.metadata = metadata
export default Artwork63v2
```

```javascript
import React, { useEffect, useRef } from 'react';
import * as THREE from 'three';

// Themes: effortless action, starting with simplicity, natural accomplishment
// Visualization: A knot that forms and moves without strain, showing how complexity emerges from simple principles

const DelicateTorusKnot = () => {
  const containerRef = useRef(null);
  const animationRef = useRef(null);
  const sceneRef = useRef(null);
  const rendererRef = useRef(null);

  useEffect(() => {
    // Only create scene and renderer once
    if (!sceneRef.current) {
      sceneRef.current = new THREE.Scene();
      rendererRef.current = new THREE.WebGLRenderer({ 
        antialias: true,
        powerPreference: "high-performance" // Prefer GPU rendering
      });
      
      // Set fixed size to 550x550
      rendererRef.current.setSize(550, 550);
      // Set background to cream color
      rendererRef.current.setClearColor(0xF0EEE6);
      
      if (containerRef.current) {
        containerRef.current.appendChild(rendererRef.current.domElement);
      }
    }
    
    const scene = sceneRef.current;
    const renderer = rendererRef.current;
    
    // Camera setup
    const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    camera.position.z = 4;
    
    // Simple parameters that give rise to complex form
    const geometry = new THREE.TorusKnotGeometry(
      1.8,  // The space to unfold within
      0.3,  // Delicate presence
      150,  // Detail emerges naturally
      24,   // Smooth transitions
      3,    // Primary rhythm
      4     // Secondary rhythm
    );
    
    const material = new THREE.LineBasicMaterial({ 
      color: 0x777777, // Medium gray
      transparent: true,
      opacity: 0.7,
      linewidth: 0.25
    });
    
    const edges = new THREE.EdgesGeometry(geometry);
    const knot = new THREE.LineSegments(edges, material);
    
    // Center it on screen
    knot.position.set(0, 0, 0);
    
    scene.add(knot);
    
    // Animation
    let time = 0;
    const animate = () => {
      time += 0.002; // Halved base time increment
      
      // Create varied rotation speeds on all axes
      knot.rotation.x = Math.PI / 6 + Math.sin(time * 0.25) * 0.2; // Halved speed
      knot.rotation.y = time * 0.4 + Math.sin(time * 0.15) * 0.3; // Halved speed
      knot.rotation.z = Math.cos(time * 0.2) * 0.15; // Halved speed
      
      // Add a slight wandering motion
      knot.position.x = Math.sin(time * 0.1) * 0.1; // Halved speed
      knot.position.y = Math.cos(time * 0.15) * 0.1; // Halved speed
      
      // Breathing effect with slight variation
      const scale = 0.95 + 0.05 * Math.sin(time * 0.6 + Math.sin(time * 0.25) * 0.3); // Halved speed
      knot.scale.setScalar(scale);
      
      renderer.render(scene, camera);
      animationRef.current = requestAnimationFrame(animate);
    };
    
    animate();
    
    // Cleanup
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = null;
      }
      
      // Dispose of Three.js resources
      if (geometry) {
        geometry.dispose();
      }
      if (material) {
        material.dispose();
      }
      if (edges) {
        edges.dispose();
      }
      if (scene && knot) {
        scene.remove(knot);
      }
      
      // Clear scene
      if (sceneRef.current) {
        sceneRef.current.clear();
        sceneRef.current = null;
      }
      
      // Clean up renderer
      if (rendererRef.current) {
        if (containerRef.current && rendererRef.current.domElement && containerRef.current.contains(rendererRef.current.domElement)) {
          containerRef.current.removeChild(rendererRef.current.domElement);
        }
        rendererRef.current.dispose();
        rendererRef.current.forceContextLoss();
        rendererRef.current = null;
      }
      
      // Reset time variable
      time = 0;
    };
  }, []);

  return (
    <div className="flex items-center justify-center w-full h-full bg-[#F0EEE6]">
      <div className="w-[550px] h-[550px]">
        <div ref={containerRef} className="w-full h-full" />
      </div>
    </div>
  );
};

export default DelicateTorusKnot;
```

```javascript
import React, { useEffect, useRef } from 'react';
import * as THREE from 'three';

// Themes: dealing with things early, starting from stillness, step by step progress
// Visualization: A form that emerges gradually from a central point, showing how patterns develop from simple beginnings

const HourglassSpiral = () => {
  const containerRef = useRef(null);

  useEffect(() => {
    if (!containerRef.current) return;

    // Setup scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color('#F0EEE6');
    
    // Setup camera
    const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    camera.position.z = 16;
    camera.position.y = 0;
    
    // Setup renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(550, 550);
    containerRef.current.appendChild(renderer.domElement);
    
    // Create main group
    const pineCone = new THREE.Group();
    
    // Begin with the smallest elements
    const particleCount = 10000;  // The many that arise from one
    const particles = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);  // Space for growth
    const colors = new Float32Array(particleCount * 3);     // Potential for form
    const sizes = new Float32Array(particleCount);          // Room to develop
    
    for (let i = 0; i < particleCount; i++) {
      // Create hourglass shape with particles
      const t = i / particleCount;
      const layer = t * 40;
      const angle = layer * 0.3 + Math.random() * 0.2;
      const spiralAngle = t * Math.PI * 40;
      
      let radius;
      if (t < 0.3) {
        // Top bulge
        radius = Math.sin(t * Math.PI / 0.3) * 2.5;
      } else if (t < 0.5) {
        // Middle pinch - create hourglass waist
        radius = 2.5 - (Math.sin((t - 0.3) * Math.PI / 0.2)) * 1.5;
      } else if (t < 0.7) {
        // Begin expansion after pinch
        radius = 1 + (Math.sin((t - 0.5) * Math.PI / 0.2)) * 2;
      } else {
        // Bottom bulge
        radius = 3 - (Math.sin((t - 0.7) * Math.PI / 0.3)) * 1;
      }
      
      // Add some randomness for organic feel
      radius += (Math.random() - 0.5) * 0.1;
      
      const y = t * 16 - 8;
      const x = Math.cos(spiralAngle) * radius;
      const z = Math.sin(spiralAngle) * radius;
      
      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;
      
      // Set all particles to black
      colors[i * 3] = 0;
      colors[i * 3 + 1] = 0;
      colors[i * 3 + 2] = 0;
      
      // Vary particle sizes
      sizes[i] = Math.random() * 0.03 + 0.01;
    }
    
    particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    
    const particleMaterial = new THREE.PointsMaterial({
      size: 0.02,
      vertexColors: true,
      transparent: true,
      opacity: 0.8,
      sizeAttenuation: true,
      blending: THREE.NormalBlending
    });
    
    const particleSystem = new THREE.Points(particles, particleMaterial);
    pineCone.add(particleSystem);
    
    // Add some structural lines - keeping these gray
    const lineMaterial = new THREE.LineBasicMaterial({
      color: '#888888',
      transparent: true,
      opacity: 0.3
    });
    
    // Spiral structure
    const spiralPoints = [];
    for (let i = 0; i < 200; i++) {
      const t = i / 200;
      const angle = t * Math.PI * 16;
      const y = t * 16 - 8;
      
      let radius;
      if (t < 0.3) {
        // Top bulge
        radius = Math.sin(t * Math.PI / 0.3) * 2.5;
      } else if (t < 0.5) {
        // Middle pinch - create hourglass waist
        radius = 2.5 - (Math.sin((t - 0.3) * Math.PI / 0.2)) * 1.5;
      } else if (t < 0.7) {
        // Begin expansion after pinch
        radius = 1 + (Math.sin((t - 0.5) * Math.PI / 0.2)) * 2;
      } else {
        // Bottom bulge
        radius = 3 - (Math.sin((t - 0.7) * Math.PI / 0.3)) * 1;
      }
      
      spiralPoints.push(new THREE.Vector3(
        Math.cos(angle) * radius,
        y,
        Math.sin(angle) * radius
      ));
    }
    
    const spiralGeometry = new THREE.BufferGeometry().setFromPoints(spiralPoints);
    const spiralLine = new THREE.Line(spiralGeometry, lineMaterial);
    pineCone.add(spiralLine);
    
    scene.add(pineCone);
    
    let time = 0;
    let animationFrameId: number;
    
    function animate() {
      animationFrameId = requestAnimationFrame(animate);
      
      time += 0.005;  // Halved speed
      
      pineCone.rotation.y = time * 0.45;  // Increased rotation speed
      pineCone.rotation.x = Math.sin(time * 0.25) * 0.05;  // Halved speed
      pineCone.rotation.z = Math.cos(time * 0.35) * 0.03;  // Halved speed
      
      const breathe = 1 + Math.sin(time * 0.25) * 0.02;  // Halved speed
      pineCone.scale.set(breathe, breathe, breathe);
      
      // Animate particles slightly
      const positions = particleSystem.geometry.attributes.position.array;
      for (let i = 0; i < positions.length; i += 3) {
        positions[i] += Math.sin(time + i) * 0.00005;  // Halved movement
        positions[i + 1] += Math.cos(time + i) * 0.00005;  // Halved movement
        positions[i + 2] += Math.sin(time + i + 1) * 0.00005;  // Halved movement
      }
      particleSystem.geometry.attributes.position.needsUpdate = true;
      
      renderer.render(scene, camera);
    }
    
    animate();
    
    // Cleanup function
    return () => {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = undefined;
      }
      
      // Dispose of geometries
      if (particles) {
        particles.dispose();
      }
      if (spiralGeometry) {
        spiralGeometry.dispose();
      }
      
      // Dispose of materials
      if (particleMaterial) {
        particleMaterial.dispose();
      }
      if (lineMaterial) {
        lineMaterial.dispose();
      }
      
      // Remove objects from scene
      if (pineCone) {
        if (particleSystem) {
          pineCone.remove(particleSystem);
        }
        if (spiralLine) {
          pineCone.remove(spiralLine);
        }
        scene.remove(pineCone);
      }
      
      // Clear scene
      if (scene) {
        scene.clear();
      }
      
      // Dispose of renderer
      if (renderer) {
        if (containerRef.current && renderer.domElement && containerRef.current.contains(renderer.domElement)) {
          containerRef.current.removeChild(renderer.domElement);
        }
        renderer.dispose();
        renderer.forceContextLoss();
      }
      
      // Clear arrays to prevent memory leaks
      if (positions) {
        positions.fill(0);
      }
      if (colors) {
        colors.fill(0);
      }
      if (sizes) {
        sizes.fill(0);
      }
      if (spiralPoints) {
        spiralPoints.length = 0;
      }
      
      // Reset time variable
      time = 0;
    };
  }, []);

  return (
    <div className="w-full h-screen flex justify-center items-center bg-[#F0EEE6]">
      <div 
        ref={containerRef}
        className="w-[550px] h-[550px]"
      />
    </div>
  );
};

export default HourglassSpiral;
```

```javascript
import { useState, useEffect, useCallback, useRef } from 'react';

// Themes: natural wisdom, avoiding cleverness, return to simplicity
// Visualization: A flower that responds to presence without force, showing how patterns emerge through gentle guidance

const RadialMeshFlower = () => {
  // Natural proportions that allow harmony to emerge
  const [dimensions, setDimensions] = useState({ width: 600, height: 600 });
  const { width, height } = dimensions;
  const radius = Math.min(width, height) * 0.267;  // The space of unfolding
  const lineCount = 400;  // Detail arises from simplicity
  const [mousePos, setMousePos] = useState({ x: width / 2, y: height / 2 });
  const [circlePositions, setCirclePositions] = useState(null);
  const [centerRotation, setCenterRotation] = useState(0);
  const animationRef = useRef(null);
  const easingFactor = 0.08;  // Gentle transitions
  const container Ref = useRef(null);
  
  // Observe container size changes
  useEffect(() => {
    const updateDimensions = () => {
      if (containerRef.current) {
        const rect = containerRef.current.getBoundingClientRect();
        setDimensions({ width: rect.width, height: rect.height });
        setMousePos({ x: rect.width / 2, y: rect.height / 2 });
      }
    };

    // Initial size
    updateDimensions();

    // Setup resize observer
    const resizeObserver = new ResizeObserver(updateDimensions);
    if (containerRef.current) {
      resizeObserver.observe(containerRef.current);
    }

    return () => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, []);
  
  // Initialize circle positions when dimensions change
  useEffect(() => {
    const initialPositions = [];
    // Create 8 circles (like flower petals) in a more flower-like arrangement
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2;
      const distanceFromCenter = radius * 0.5; // Closer together for flower effect
      const x = width / 2 + Math.cos(angle) * distanceFromCenter;
      const y = height / 2 + Math.sin(angle) * distanceFromCenter;
      initialPositions.push({ x, y, targetX: x, targetY: y });
    }
    // Add central circle
    initialPositions.push({ 
      x: width / 2, 
      y: height / 2, 
      targetX: width / 2, 
      targetY: height / 2 
    });
    setCirclePositions(initialPositions);
  }, [width, height, radius]);
  
  // Handle mouse movement
  const handleMouseMove = useCallback((event) => {
    const svg = event.currentTarget;
    const rect = svg.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    setMousePos({ x, y });
  }, []);
  
  // Update target positions based on mouse
  useEffect(() => {
    setCirclePositions(prevPositions => {
      if (!prevPositions) return null;
      
      let closestCircleIndex = 0;
      let minDistance = Infinity;
      
      prevPositions.forEach((circle, i) => {
        const dx = mousePos.x - circle.x;
        const dy = mousePos.y - circle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < minDistance) {
          minDistance = distance;
          closestCircleIndex = i;
        }
      });
      
      return prevPositions.map((circle, i) => {
        // Calculate base position
        let baseCx, baseCy;
        if (i === 8) { // Center circle
          baseCx = width / 2;
          baseCy = height / 2;
        } else {
          const angle = (i / 8) * Math.PI * 2;
          const distanceFromCenter = radius * 0.5;
          baseCx = width / 2 + Math.cos(angle) * distanceFromCenter;
          baseCy = height / 2 + Math.sin(angle) * distanceFromCenter;
        }
        
        if (i === closestCircleIndex) {
          const maxMovement = radius * 0.1;
          const dx = mousePos.x - baseCx;
          const dy = mousePos.y - baseCy;
          const movement = Math.min(Math.sqrt(dx * dx + dy * dy) / radius, 1) * maxMovement;
          const moveAngle = Math.atan2(dy, dx);
          
          return {
            ...circle,
            targetX: baseCx + Math.cos(moveAngle) * movement,
            targetY: baseCy + Math.sin(moveAngle) * movement
          };
        } else {
          return {
            ...circle,
            targetX: baseCx,
            targetY: baseCy
          };
        }
      });
    });
  }, [mousePos, width, height, radius]);
  
  // Animate circle positions and rotation
  useEffect(() => {
    const animate = () => {
      // Update center rotation
      setCenterRotation(prev => prev + 0.005); // Reduced rotation speed for gentler movement
      
      // Update circle positions
      setCirclePositions(prevPositions => {
        if (!prevPositions) return null;
        
        return prevPositions.map(circle => {
          const dx = circle.targetX - circle.x;
          const dy = circle.targetY - circle.y;
          
          return {
            ...circle,
            x: circle.x + dx * easingFactor,
            y: circle.y + dy * easingFactor
          };
        });
      });
      
      animationRef.current = requestAnimationFrame(animate);
    };
    
    animate();
    
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
        animationRef.current = null;
      }
    };
  }, [easingFactor]);
  
  // Generate petal-like lines for each circle
  const generatePetalLines = (cx, cy, radius, rotation = 0, isCenter = false) => {
    const lines = [];
    const petalCount = 12; // Number of petals in each circle
    
    for (let petal = 0; petal < petalCount; petal++) {
      const petalAngle = (petal / petalCount) * Math.PI * 2 + rotation;
      const linesPerPetal = Math.floor(lineCount / petalCount);
      
      for (let i = 0; i < linesPerPetal; i++) {
        const t = i / linesPerPetal;
        const angle = petalAngle + (t - 0.5) * 0.5; // Spread lines within petal
        
        // Create tapered petal effect
        const innerRadius = isCenter ? radius * 0.1 : radius * 0.2;
        const outerRadius = radius * (0.9 - Math.pow(Math.abs(t - 0.5) * 2, 2) * 0.3);
        
        // Add subtle curve to lines
        const curveOffset = Math.sin(t * Math.PI) * 0.1;
        const curvedAngle = angle + curveOffset;
        
        const x1 = cx + Math.cos(curvedAngle) * innerRadius;
        const y1 = cy + Math.sin(curvedAngle) * innerRadius;
        const x2 = cx + Math.cos(angle) * outerRadius;
        const y2 = cy + Math.sin(angle) * outerRadius;
        
        lines.push({
          path: `M${x1},${y1} L${x2},${y2}`,
          opacity: 0.6 - Math.abs(t - 0.5) * 0.4 // Fade at edges
        });
      }
    }
    return lines;
  };
  
  if (!circlePositions) return null;
  
  return (
    <div 
      ref={containerRef} 
      style={{ 
        width: '100%', 
        height: '100%', 
        backgroundColor: '#F0EEE6',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}
    >
      <svg 
        width={width} 
        height={height} 
        viewBox={`0 0 ${width} ${height}`}
        preserveAspectRatio="xMidYMid meet"
        style={{ cursor: 'crosshair' }}
        onMouseMove={handleMouseMove}
      >
        {circlePositions.map((circle, index) => (
          <g key={index}>
            {generatePetalLines(
              circle.x, 
              circle.y, 
              index === 8 ? radius * 0.7 : radius, // Smaller center
              index === 8 ? centerRotation : (index / 8) * Math.PI * 2, // Apply rotation to center
              index === 8
            ).map((line, i) => (
              <path
                key={i}
                d={line.path}
                stroke="#333333"
                strokeWidth={index === 8 ? "0.4" : "0.3"}
                opacity={line.opacity}
                fill="none"
              />
            ))}
          </g>
        ))}
      </svg>
    </div>
  );
};

export default RadialMeshFlower;
```