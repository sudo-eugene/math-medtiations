```javascript
import React, { useRef, useEffect, useState } from 'react'
import * as THREE from 'three'

// themes: duality, eternal vs temporal, form vs formlessness, mystery of origin, essence vs manifestation
// visualization: Ethereal geometric patterns emerge from invisible mathematical formulas, illustrating how the nameable arises from the unnameable


const metadata = {
  themes: "Interference, Pattern, Wave, Interaction, Harmony",
  visualization: "Precise geometric interference patterns with wave interactions",
  promptSuggestion: "1. Enhance interference complexity\n2. Add more wave interactions\n3. Develop stronger patterns\n4. Create clearer harmonies\n5. Increase sense of interaction"
}

interface WaveSourceProps {
  position: [number, number, number]
  frequency: number
  amplitude: number
  phase: number
}

interface HankiesInTheWindProps {
  initialZoom?: number;
}

const HankiesInTheWind: React.FC<HankiesInTheWindProps> = ({ initialZoom = 6 }) => {
  const containerRef = useRef<HTMLDivElement>(null)
  const [currentZoom, setCurrentZoom] = useState(initialZoom)

  useEffect(() => {
    if (!containerRef.current) return
    
    let animationFrameId: number | null = null
    let scene: any = null
    let camera: any = null
    let renderer: any = null
    let lineGroups: any[] = []
    let cameraZoom = currentZoom // Control camera zoom distance (lower number = closer)

    // Create wave sources
    const createWaveSources = (time: number, scale: number): WaveSourceProps[] => {
      const result: WaveSourceProps[] = []
      const count = 5
      
      // Create wave sources in a circular pattern
      for (let i = 0; i < count; i++) {
        const angle = (i / count) * Math.PI * 2
        const radius = scale * (1 + Math.sin(angle * 3) * 0.2)
        
        result.push({
          position: [
            Math.cos(angle) * radius,
            0,
            Math.sin(angle) * radius
          ],
          frequency: 2 + Math.sin(angle * 2),
          amplitude: 0.3 + Math.cos(angle) * 0.1,
          phase: time * 3 + angle
        })
      }
      
      // Add central source
      result.push({
        position: [0, 0, 0],
        frequency: 3,
        amplitude: 0.4,
        phase: time * 4
      })
      
      return result
    }

    // Create interference field geometry
    const createInterferenceField = (sources: WaveSourceProps[], size: number, resolution: number, time: number) => {
      const step = size / resolution
      const heightMap: number[][] = []
      
      // Calculate interference pattern grid
      for (let i = 0; i <= resolution; i++) {
        heightMap[i] = []
        const x = (i * step) - (size / 2)
        
        for (let j = 0; j <= resolution; j++) {
          const z = (j * step) - (size / 2)
          let height = 0
          
          // Sum contributions from all wave sources
          sources.forEach(({ position: [sx, sy, sz], frequency, amplitude, phase }) => {
            const dx = x - sx
            const dz = z - sz
            const distance = Math.sqrt(dx * dx + dz * dz)
            height += Math.sin(distance * frequency - time * 5 + phase) * 
                     amplitude * Math.exp(-distance * 0.3)
          })
          
          heightMap[i][j] = height
        }
      }
      
      const linesMaterial = new THREE.LineBasicMaterial({ 
        color: 0x333333,
        transparent: true,
        opacity: 0.4
      })
      
      const linesGroup = new THREE.Group()
      lineGroups.push(linesGroup)
      
      // Create horizontal lines
      for (let i = 0; i <= resolution; i++) {
        const geometry = new THREE.BufferGeometry()
        const points = []
        const x = (i * step) - (size / 2)
        
        for (let j = 0; j <= resolution; j++) {
          const z = (j * step) - (size / 2)
          points.push(x, heightMap[i][j], z)
        }
        
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3))
        const line = new THREE.Line(geometry, linesMaterial)
        linesGroup.add(line)
      }
      
      // Create vertical lines
      for (let j = 0; j <= resolution; j++) {
        const geometry = new THREE.BufferGeometry()
        const points = []
        const z = (j * step) - (size / 2)
        
        for (let i = 0; i <= resolution; i++) {
          const x = (i * step) - (size / 2)
          points.push(x, heightMap[i][j], z)
        }
        
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3))
        const line = new THREE.Line(geometry, linesMaterial)
        linesGroup.add(line)
      }
      
      // Add interference highlight lines
      for (let i = 1; i < resolution; i++) {
        for (let j = 1; j < resolution; j++) {
          const x = (i * step) - (size / 2)
          const z = (j * step) - (size / 2)
          const height = heightMap[i][j]
          const heightDiff = Math.abs(
            height - 
            (heightMap[i-1][j] + heightMap[i+1][j] + 
             heightMap[i][j-1] + heightMap[i][j+1]) / 4
          )
          
          if (heightDiff > 0.2) {
            const geometry1 = new THREE.BufferGeometry()
            const points1 = [
              x - step/2, height, z - step/2,
              x + step/2, height, z + step/2
            ]
            geometry1.setAttribute('position', new THREE.Float32BufferAttribute(points1, 3))
            const line1 = new THREE.Line(geometry1, linesMaterial)
            linesGroup.add(line1)
            
            const geometry2 = new THREE.BufferGeometry()
            const points2 = [
              x - step/2, height, z + step/2,
              x + step/2, height, z - step/2
            ]
            geometry2.setAttribute('position', new THREE.Float32BufferAttribute(points2, 3))
            const line2 = new THREE.Line(geometry2, linesMaterial)
            linesGroup.add(line2)
          }
        }
      }
      
      return linesGroup
    }

    const container = containerRef.current
    const width = container.clientWidth
    const height = container.clientHeight
    const dpr = window.devicePixelRatio || 1

    // Scene, camera, renderer setup
    scene = new THREE.Scene()
    camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000)
    renderer = new THREE.WebGLRenderer({ antialias: true })
    
    renderer.setPixelRatio(Math.min(dpr, 2))
    renderer.setSize(width, height)
    renderer.setClearColor(0xF0EEE6)
    container.appendChild(renderer.domElement)

    // Lighting - matching original
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4)
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6)
    directionalLight.position.set(5, 5, 5)
    const pointLight = new THREE.PointLight(0xffffff, 0.4)
    pointLight.position.set(-5, 3, -5)
    
    scene.add(ambientLight)
    scene.add(directionalLight)
    scene.add(pointLight)

    // Position camera using zoom variable
    camera.position.set(0, 0, cameraZoom)
    camera.lookAt(0, 0, 0)

    // Create groups for interference systems
    const mainGroup = new THREE.Group()
    scene.add(mainGroup)

    // Animation loop
    let time = 0
    
    const animate = () => {
      animationFrameId = requestAnimationFrame(animate)
      
      time += 0.0013
      
      // Clear previous line groups
      mainGroup.children.forEach((child: any) => {
        if (child instanceof THREE.Group) {
          child.children.forEach((line: any) => {
            if (line.geometry) line.geometry.dispose()
            if (line.material) line.material.dispose()
          })
          mainGroup.remove(child)
        }
      })
      lineGroups = []
      
      // Create and add new interference fields
      const sources1 = createWaveSources(time, 1.5)
      const field1 = createInterferenceField(sources1, 1.5 * 4, 32, time)
      mainGroup.add(field1)
      
      const sources2 = createWaveSources(time + 0.33, 0.8)
      const field2 = createInterferenceField(sources2, 0.8 * 4, 32, time + 0.33)
      field2.position.set(0, 1.5, 0)
      field2.rotation.set(Math.PI/6, 0, Math.PI/4)
      mainGroup.add(field2)
      
      const sources3 = createWaveSources(time + 0.66, 0.8)
      const field3 = createInterferenceField(sources3, 0.8 * 4, 32, time + 0.66)
      field3.position.set(0, -1.5, 0)
      field3.rotation.set(-Math.PI/6, 0, -Math.PI/4)
      mainGroup.add(field3)
      
      // Rotate main group
      mainGroup.rotation.y = Math.sin(time * 0.3) * 0.2
      mainGroup.rotation.x = Math.cos(time * 0.2) * 0.1
      
      renderer.render(scene, camera)
    }
    
    animate()

    // Handle resize
    const handleResize = () => {
      if (!containerRef.current) return
      
      const width = containerRef.current.clientWidth
      const height = containerRef.current.clientHeight
      const dpr = window.devicePixelRatio || 1
      
      camera.aspect = width / height
      camera.updateProjectionMatrix()
      renderer.setPixelRatio(Math.min(dpr, 2))
      renderer.setSize(width, height)
    }
    
    window.addEventListener('resize', handleResize)

    // Cleanup function
    return () => {
      window.removeEventListener('resize', handleResize)
      
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId)
      }
      
      if (renderer) {
        renderer.dispose()
        if (container.contains(renderer.domElement)) {
          container.removeChild(renderer.domElement)
        }
      }
      
      if (scene) {
        scene.traverse((object: any) => {
          if (object instanceof THREE.Mesh) {
            if (object.geometry) object.geometry.dispose()
            if (object.material) {
              if (Array.isArray(object.material)) {
                object.material.forEach((material: any) => material.dispose())
              } else {
                object.material.dispose()
              }
            }
          } else if (object instanceof THREE.Line) {
            if (object.geometry) object.geometry.dispose()
            if (object.material) object.material.dispose()
          }
        })
      }
    }
  }, [])

  return (
    <div 
      ref={containerRef}
      style={{ 
        margin: 0,
        background: '#F0EEE6',
        overflow: 'hidden',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        height: '100vh',
        width: '100vw',
        position: 'relative'
      }}
    />
  )
}

HankiesInTheWind.metadata = metadata
export default HankiesInTheWind
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: duality of opposites, quiet example, cycles of creation/dissolution
// visualization: Geometric patterns that emerge and dissolve naturally, illustrating how opposites define and transform each other

const TessellationPatterns = () => {
  const canvasRef = useRef(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width = 550;
    const height = canvas.height = 550;
    
    let time = 0;
    const SCALE = 60;
    let animationFrameId = null;
    
    // Draw hexagonal tile - where elegance emerges from simple geometry
    function drawTile(cx, cy, size, rotation, phase, morph) {
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(rotation);
      
      // Draw outer hexagon - the form that contains opposites
      ctx.beginPath();
      const points = 6;
      for (let i = 0; i <= points; i++) {
        const angle = (i / points) * Math.PI * 2;
        const r = size * (1 + Math.sin(phase + i) * 0.1);
        const x = Math.cos(angle) * r;
        const y = Math.sin(angle) * r;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.strokeStyle = 'rgba(51, 51, 51, 0.4)';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // Draw internal structure - the quiet example within
      for (let i = 0; i < points; i += 2) {
        const angle1 = (i / points) * Math.PI * 2;
        const angle2 = ((i + 2) / points) * Math.PI * 2;
        const r1 = size * (1 + Math.sin(phase + i) * 0.1);
        const r2 = size * (1 + Math.sin(phase + i + 2) * 0.1);
        
        // Outer points
        const x1 = Math.cos(angle1) * r1;
        const y1 = Math.sin(angle1) * r1;
        const x2 = Math.cos(angle2) * r2;
        const y2 = Math.sin(angle2) * r2;
        
        // Inner point with morph
        const midAngle = (angle1 + angle2) / 2;
        const innerR = size * 0.5 * (1 + morph * 0.5);
        const xi = Math.cos(midAngle) * innerR;
        const yi = Math.sin(midAngle) * innerR;
        
        // Draw connection lines
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(xi, yi);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(xi, yi);
        ctx.stroke();
      }
      
      ctx.restore();
    }
    
    // Create hexagonal grid - a field where creation and dissolution dance
    function createTessellationField(offsetX, offsetY, fieldScale, timeOffset) {
      const gridSize = 4;
      const spacing = SCALE * fieldScale * 0.8;
      
      for (let row = -gridSize; row <= gridSize; row++) {
        const rowOffset = (row % 2) * spacing * 0.5;
        for (let col = -gridSize; col <= gridSize; col++) {
          const x = (col * spacing * 0.866) + rowOffset + offsetX;
          const y = row * spacing * 0.75 + offsetY;
          const dist = Math.sqrt(x * x + y * y);
          
          // Skip tiles that are too far from center
          if (dist > SCALE * fieldScale * 2.5) continue;
          
          // Calculate tile properties
          const angle = Math.atan2(y - offsetY, x - offsetX);
          const phase = (time + timeOffset) + dist * 0.01;
          const morph = Math.sin(phase + angle) * 0.5 + 0.5;
          
          drawTile(
            width/2 + x,
            height/2 + y,
            SCALE * fieldScale * 0.4 * (1 - dist/(SCALE * fieldScale * 3) * 0.3),
            angle + (time + timeOffset) * 0.2,
            phase,
            morph
          );
        }
      }
    }
    
    // The eternal cycle of creation and letting go
    function animate() {
      
      time += 0.01;
      
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, width, height);
      
      // Main tessellation field
      createTessellationField(0, 0, 1.5, 0);
      
      // Upper field with rotation
      ctx.save();
      ctx.translate(width/2, height/2);
      ctx.rotate(Math.PI/6);
      ctx.translate(-width/2, -height/2);
      createTessellationField(0, -100, 0.8, time * 0.2 + Math.PI/3);
      ctx.restore();
      
      // Lower field with rotation
      ctx.save();
      ctx.translate(width/2, height/2);
      ctx.rotate(-Math.PI/6);
      ctx.translate(-width/2, -height/2);
      createTessellationField(0, 100, 0.8, time * 0.2 - Math.PI/3);
      ctx.restore();
      
      animationFrameId = requestAnimationFrame(animate);
    }
    
    animate();
    
    return () => {
      
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      if (ctx) {
        ctx.clearRect(0, 0, width, height);
      }
      
      if (canvas) {
        canvas.width = 0;
        canvas.height = 0;
      }
    };
  }, []);
  
  return (
    <div style={{
      width: '550px',
      height: '550px',
      margin: 'auto',
      backgroundColor: '#F0EEE6',
      overflow: 'hidden'
    }}>
      <canvas
        ref={canvasRef}
        style={{
          display: 'block',
          width: '550px',
          height: '550px'
        }}
      />
    </div>
  );
};

export default TessellationPatterns;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: emptiness vs expectation, natural self-sufficiency, action through non-action
// visualization: Binary patterns that naturally erode and flow, demonstrating how emptiness enables movement

const AsciiBinaryFlow: React.FC = () => {
    const canvasRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        let width = 65;
        let height = 65;
        let grid: string[][] = [];
        let time = 0;
        let animationFrameId: number;
        
        // Initialize grid - emptying the mind of expectation
        function initGrid() {
            grid = [];
            for (let y = 0; y < height; y++) {
                let row = [];
                for (let x = 0; x < width; x++) {
                    row.push(' ');
                }
                grid.push(row);
            }
        }
        
        // Render grid
        function render() {
            let html = '';
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    html += grid[y][x];
                }
                html += '<br>';
            }
            canvas.innerHTML = html;
        }
        
        // Update grid
        function update() {
            initGrid(); // Clear grid
            
            // Create a rigid structure - perfectly centered
            const blockSize = 30;
            const blockX = Math.floor(width / 2 - blockSize / 2);
            const blockY = Math.floor(height / 2 - blockSize / 2);
            
            // Time-based flow with slower motion (reduced to 2/3 speed)
            const t = time * 0.005;
            
            // Draw water flow around and through the structure
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // Create block - structure yields to natural flow
                    if (x >= blockX && x < blockX + blockSize && 
                        y >= blockY && y < blockY + blockSize) {
                        // The block is gradually being eroded
                        const innerDist = Math.min(
                            x - blockX, 
                            blockX + blockSize - x,
                            y - blockY,
                            blockY + blockSize - y
                        );
                        
                        // Erosion from edge inward (slower)
                        const erosion = time * 0.0067;
                        if (innerDist > erosion) {
                            grid[y][x] = '1';
                        } else {
                            // Transition zone - less random
                            grid[y][x] = Math.random() > 0.8 ? '1' : '0';
                        }
                    } else {
                        // Water flow pattern - natural self-sufficiency in motion
                        const dx = x - width / 2;
                        const dy = y - height / 2;
                        const angle = Math.atan2(dy, dx);
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        // Create fluid pattern resembling water - smoother transitions
                        const wave = Math.sin(dist * 0.2 - t + angle * 1.5);
                        const flow = Math.sin(x * 0.08 + y * 0.04 + t * 0.4);
                        
                        // Use a threshold that creates less flickering
                        if (flow + wave > 0.4) {
                            grid[y][x] = '0';
                        } else if (flow + wave < -0.4) {
                            grid[y][x] = '~';
                        }
                    }
                }
            }
            
            // Add cracks to the block
            for (let i = 0; i < 5; i++) {
                const crackX = blockX + Math.floor(Math.random() * blockSize);
                const crackY = blockY + Math.floor(Math.random() * blockSize);
                const length = Math.floor(Math.random() * 10) + 5;
                let cx = Math.floor(crackX);
                let cy = Math.floor(crackY);
                
                for (let j = 0; j < length; j++) {
                    if (cx >= 0 && cx < width && cy >= 0 && cy < height) {
                        grid[cy][cx] = '0';
                    }
                    // Move in random direction
                    cx += Math.floor(Math.random() * 3) - 1;
                    cy += Math.floor(Math.random() * 3) - 1;
                }
            }
            
            time++;
        }
        
        function animate() {
            update();
            render();
            animationFrameId = requestAnimationFrame(animate);
        }
        
        initGrid();
        animationFrameId = requestAnimationFrame(animate);

        return () => {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            
            if (canvas) {
                canvas.innerHTML = '';
            }
            
            grid = [];
            time = 0;
        };
    }, []);

    return (
        <div style={{ 
            margin: 0,
            background: '#F0EEE6',
            overflow: 'hidden',
            fontFamily: 'monospace',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            height: '100%'
        }}>
            <div style={{
                padding: '30px',
                position: 'relative',
                width: '100%',
                height: '100%',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
            }}>
                <div 
                    ref={canvasRef}
                    style={{
                        lineHeight: '0.85',
                        letterSpacing: '0.05em',
                        color: 'rgba(0,0,0,0.85)',
                        userSelect: 'none',
                        width: '100%',
                        height: '100%',
                        overflow: 'hidden',
                        display: 'flex',
                        flexDirection: 'column',
                        justifyContent: 'center',
                        marginLeft: '10%',
                    }}
                />
            </div>
        </div>
    );
};

export default AsciiBinaryFlow;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: inexhaustible source, smoothing complexity, effortless flow
// visualization: Vertical patterns that endlessly transform, showing how complexity resolves into fluid motion

const ScrollingVerticalBars = () => {
  const canvasRef = useRef(null);
  const scrollPositionRef = useRef(0);
  const animationFrameId = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    canvas.width = 550;
    canvas.height = 550;
    
    const numLines = 60;
    const lineSpacing = canvas.width / numLines;
    
    // Create two different patterns - complexity arising from the inexhaustible source
    const createPattern = (offset) => {
      const pattern = [];
      for (let i = 0; i < numLines; i++) {
        const bars = [];
        const numBars = 10 + Math.sin(i * 0.3 + offset) * 5;
        
        for (let j = 0; j < numBars; j++) {
          bars.push({
            y: (j / numBars) * canvas.height + Math.sin(i * 0.5 + j * 0.3 + offset) * 30,
            height: 5 + Math.sin(i * 0.2 + j * 0.4) * 3,
            width: 2 + Math.cos(i * 0.3) * 2
          });
        }
        pattern.push(bars);
      }
      return pattern;
    };
    
    const pattern1 = createPattern(0);
    const pattern2 = createPattern(Math.PI);
    
    const animate = () => {
      
      scrollPositionRef.current += 0.0025;
      const scrollFactor = (Math.sin(scrollPositionRef.current) + 1) / 2;
      
      // Clear canvas
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw lines and interpolated bars - smoothing sharp edges into gentle flow
      for (let i = 0; i < numLines; i++) {
        const x = i * lineSpacing + lineSpacing / 2;
        
        // Draw vertical line
        ctx.beginPath();
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 1;
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
        
        // Interpolate between patterns - effortless transformation
        const bars1 = pattern1[i];
        const bars2 = pattern2[i];
        const maxBars = Math.max(bars1.length, bars2.length);
        
        for (let j = 0; j < maxBars; j++) {
          const bar1 = bars1[j] || bars2[j];
          const bar2 = bars2[j] || bars1[j];
          
          const y = bar1.y + (bar2.y - bar1.y) * scrollFactor;
          const height = bar1.height + (bar2.height - bar1.height) * scrollFactor;
          const width = bar1.width + (bar2.width - bar1.width) * scrollFactor;
          
          ctx.fillStyle = '#222';
          ctx.fillRect(x - width/2, y - height/2, width, height);
        }
      }
      
      animationFrameId.current = requestAnimationFrame(animate);
    };
    
    animate();
    
    return () => {
      
      if (animationFrameId.current) {
        cancelAnimationFrame(animationFrameId.current);
        animationFrameId.current = null;
      }
      
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      
      if (canvas) {
        canvas.width = 0;
        canvas.height = 0;
      }
      
      scrollPositionRef.current = 0;
    };
  }, []);

  return (
    <div style={{ width: '550px', height: '550px', backgroundColor: '#F0EEE6' }}>
      <canvas ref={canvasRef} style={{ display: 'block' }} />
    </div>
  );
};

export default ScrollingVerticalBars;
```

```javascript
import React, { useEffect, useRef, useCallback } from 'react'
import * as THREE from 'three'

const EmptyParticles = ({ count = 45000 }) => {
  const mountRef = useRef(null)
  const animationRef = useRef(null)
  const sceneRef = useRef(null)
  const rendererRef = useRef(null)
  const cameraRef = useRef(null)
  const geometryRef = useRef(null)
  const materialRef = useRef(null)
  const pointsRef = useRef(null)
  const resizeObserverRef = useRef(null)
  const timeoutsRef = useRef([])
  
  useEffect(() => {
    if (!mountRef.current) return
    
    // Get container dimensions
    const container = mountRef.current
    const width = container.clientWidth
    const height = container.clientHeight
    
    const scene = new THREE.Scene()
    sceneRef.current = scene
    
    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000)
    cameraRef.current = camera
    
    const renderer = new THREE.WebGLRenderer({ 
      antialias: true,
      powerPreference: "high-performance",
      alpha: false,
      stencil: false,
      depth: true
    })
    rendererRef.current = renderer
    
    renderer.setSize(width, height)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
    container.appendChild(renderer.domElement)
    
    camera.position.z = 5
    scene.background = new THREE.Color('#F0EEE6')
    
    const particleMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        opacity: { value: 0.4 }
      },
      vertexShader: `
        uniform float time;
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        
        // Optimized vertex shader - pre-compute constants and minimize operations
        void main() {
          vColor = customColor;
          vec3 pos = position;
          
          // Calculate radial distance and angle with optimized math
          float radius = length(pos.xz);
          float angle = atan(pos.z, pos.x);
          float height = pos.y;
          
          // Pre-compute common calculations
          float vessel = smoothstep(0.3, 0.7, radius) * smoothstep(1.0, 0.7, radius);
          
          // Simplified rotation
          angle += time * 0.08;
          
          // Simplified space calculation
          float space = sin(time * 0.3 + radius * 3.0) * 0.1;
          
          // Combine calculations with fewer temporary variables
          float newRadius = (radius + space) * vessel;
          
          vec3 newPos;
          newPos.x = cos(angle) * newRadius;
          newPos.z = sin(angle) * newRadius;
          newPos.y = height * vessel - 1.2;
          
          // Scale for canvas size
          newPos *= 2.75;
          
          vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
          gl_PointSize = size * (128.0 / -mvPosition.z);
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        uniform float opacity;
        varying vec3 vColor;
        void main() {
          // Optimized circle calculation with early exit
          vec2 center = gl_PointCoord - vec2(0.5);
          float dist = dot(center, center); // Use squared distance to avoid sqrt
          
          if (dist > 0.25) discard; // dist*dist > 0.5*0.5
          
          float alpha = (1.0 - smoothstep(0.2025, 0.25, dist)) * opacity; // Pre-computed squared values
          gl_FragColor = vec4(vColor, alpha);
        }
      `,
      transparent: true,
      depthWrite: false,
      blending: THREE.NormalBlending,
      side: THREE.DoubleSide,
      vertexColors: true
    })
    materialRef.current = particleMaterial
    
    // Pre-allocate typed arrays for better memory management
    const positions = new Float32Array(count * 3)
    const colors = new Float32Array(count * 3)
    const sizes = new Float32Array(count)
    
    // Generate particles - defining the vessel through stillness and movement
    let i3 = 0
    for (let i = 0; i < count; i++) {
      // Create vessel-like distribution - empty space holding infinite potential
      const t = i / count
      const radius = Math.pow(t, 0.5)
      const angle = t * Math.PI * 40
      
      // Pre-calculate height
      const vesselHeight = Math.sin(t * Math.PI) * 1.8
      
      // Add randomness
      const randRadius = radius + (Math.random() - 0.5) * 0.05
      const randAngle = angle + (Math.random() - 0.5) * 0.1
      
      // Directly write to typed arrays
      positions[i3] = Math.cos(randAngle) * randRadius
      positions[i3 + 1] = vesselHeight
      positions[i3 + 2] = Math.sin(randAngle) * randRadius

      // Simplified color calculation
      const shade = 0.1 + Math.sqrt(radius) * 0.1 + Math.random() * 0.02
      colors[i3] = shade
      colors[i3 + 1] = shade
      colors[i3 + 2] = shade

      // Optimized size calculation
      sizes[i] = (1.0 - Math.abs(vesselHeight * 0.5)) * 0.2 + 0.1
      
      i3 += 3
    }
    
    const geometry = new THREE.BufferGeometry()
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))
    geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3))
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1))
    geometry.computeBoundingBox()
    geometry.computeBoundingSphere()
    geometryRef.current = geometry
    
    const points = new THREE.Points(geometry, particleMaterial)
    pointsRef.current = points
    scene.add(points)
    
    // Optimized animation loop with requestAnimationFrame control
    const clock = new THREE.Clock()
    let lastTime = 0
    const targetFPS = 60
    const targetInterval = 1000 / targetFPS
    
    const animate = (currentTime) => {
      animationRef.current = requestAnimationFrame(animate)
      
      const deltaTime = currentTime - lastTime
      if (deltaTime < targetInterval) return
      
      lastTime = currentTime - (deltaTime % targetInterval)
      
      const time = clock.getElapsedTime()
      particleMaterial.uniforms.time.value = time
      
      renderer.render(scene, camera)
    }
    
    animationRef.current = requestAnimationFrame(animate)
    
    let resizeTimeout = null
    const handleResize = () => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      
      resizeTimeout = setTimeout(() => {
        if (!mountRef.current) return
        
        const container = mountRef.current
        const width = container.clientWidth
        const height = container.clientHeight
        
        camera.aspect = width / height
        camera.updateProjectionMatrix()
        renderer.setSize(width, height)
      }, 100)
    }
    
    window.addEventListener('resize', handleResize, { passive: true })
    
    let observerTimeout = null
    const resizeObserverCallback = () => {
      if (observerTimeout) clearTimeout(observerTimeout)
      observerTimeout = setTimeout(handleResize, 100)
    }
    
    const resizeObserver = new ResizeObserver(resizeObserverCallback)
    resizeObserverRef.current = resizeObserver
    
    if (mountRef.current) {
      resizeObserver.observe(mountRef.current)
    }
    
    timeoutsRef.current.push(() => {
      if (resizeTimeout) clearTimeout(resizeTimeout)
      if (observerTimeout) clearTimeout(observerTimeout)
    })
    
    return () => {
      timeoutsRef.current.forEach(clearFn => clearFn())
      timeoutsRef.current = []
      
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current)
        animationRef.current = null
      }
      
      window.removeEventListener('resize', handleResize)
      
      if (resizeObserverRef.current) {
        resizeObserverRef.current.disconnect()
        resizeObserverRef.current = null
      }
      
      if (sceneRef.current && pointsRef.current) {
        sceneRef.current.remove(pointsRef.current)
      }
      
      if (geometryRef.current) {
        geometryRef.current.dispose()
        geometryRef.current = null
      }
      
      if (materialRef.current) {
        materialRef.current.dispose()
        materialRef.current = null
      }
      
      if (rendererRef.current) {
        rendererRef.current.dispose()
        if (container.contains(rendererRef.current.domElement)) {
          container.removeChild(rendererRef.current.domElement)
        }
        rendererRef.current.forceContextLoss()
        rendererRef.current = null
      }
      
      sceneRef.current = null
      cameraRef.current = null
      pointsRef.current = null
    }
  }, [count])
  
  return <div ref={mountRef} style={{ width: '100vw', height: '100vh' }} />
}

const ParticleVessel = () => {
  return <EmptyParticles />
}

const metadata = {
  themes: "impartiality, empty potential, stillness as power",
  visualization: "Particles define a vessel through their movement around emptiness, showing how stillness contains infinite possibility",
  promptSuggestion: "1. Add subtle void variations\n2. Create empty vessel patterns\n3. Vary spatial definitions naturally\n4. Introduce gentle utility waves\n5. Make emptiness follow natural forms"
}

ParticleVessel.metadata = metadata
export default ParticleVessel
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: feminine creative force, eternal fertility, root energy
// visualization: Particles bloom and flow from a central source, embodying the eternal creative feminine

const ParticleFlower = () => {
  const canvasRef = useRef(null);
  const animationFrameRef = useRef(null);
  const particlesRef = useRef([]);
  const ctxRef = useRef(null);
  const timeRef = useRef(0);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    ctxRef.current = ctx;
    const width = canvas.width = 550;
    const height = canvas.height = 550;
    const centerX = width / 2;
    const centerY = height / 2;
    
    const PARTICLE_COUNT = 30000;
    const FORM_SCALE = 2.4; // Increased by 20% from 2.0
    const particles = [];
    particlesRef.current = particles;
    
    // Initialize particles - seeds of the eternal feminine
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      // Start with a more converged form
      const theta = Math.random() * Math.PI * 2;
      const r = Math.pow(Math.random(), 0.5) * FORM_SCALE * 0.5 * 150; // Tighter radius
      const height = (Math.random() * 2 - 1) * FORM_SCALE * 0.3; // Less vertical spread
      
      // Calculate initial flow influence - root energy spiraling outward
      const angle = theta;
      const dist = r / 150;
      const flow = Math.sin(angle * 2 + height * 2) * 0.03;
      const counterFlow = Math.cos(angle * 2 - height * 2) * 0.03;
      const blend = (Math.sin(height * Math.PI) + 1) * 0.5;
      const combinedFlow = flow * blend + counterFlow * (1 - blend);
      
      // Apply initial flow to starting position
      const dx = r * Math.cos(theta);
      const dy = r * Math.sin(theta);
      const containment = Math.pow(Math.min(1, dist / (FORM_SCALE * 0.8)), 4);
      const pull = containment * 0.1;
      
      particles.push({
        x: centerX + dx + (dx * combinedFlow) - (dx * pull),
        y: centerY + dy + (dy * combinedFlow) - (dy * pull),
        z: height,
        initialR: r,
        initialTheta: theta,
        initialHeight: height
      });
    }
    
    // Animation timing control variables
    let lastFrameTime = 0;
    const targetFPS = 10; // Equivalent to 100ms setInterval
    const frameInterval = 1000 / targetFPS;
    
    // Animation function with time delta control
    function animate(currentTime) {
      // Initialize lastFrameTime on first frame
      if (!lastFrameTime) {
        lastFrameTime = currentTime;
      }
      
      const deltaTime = currentTime - lastFrameTime;
      
      // Only update animation when enough time has passed (mimics setInterval at 100ms)
      if (deltaTime >= frameInterval) {
        // Using a fixed time increment for consistent animation
        timeRef.current += 0.0005;
        
        // Clear with slight trails for ghosting effect
        // More transparent for smoother trails at lower frame rates
        ctx.fillStyle = 'rgba(240, 238, 230, 0.05)';
        ctx.fillRect(0, 0, width, height);
        
        particles.forEach(particle => {
          // Get relative position to center
          const dx = particle.x - centerX;
          const dy = particle.y - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy) / 150; // Normalize distance
          const angle = Math.atan2(dy, dx);
          const height = particle.z / (FORM_SCALE * 0.4);
          
          const flow = Math.sin(angle * 2 - timeRef.current * 0.5 + height * 2) * 0.015;
          const counterFlow = Math.cos(angle * 2 + timeRef.current * 0.5 - height * 2) * 0.015;
          
          // Blend flows based on height
          const blend = (Math.sin(height * Math.PI) + 1) * 0.5;
          const combinedFlow = flow * blend + counterFlow * (1 - blend);
          
          // Strong containment
          const containment = Math.pow(Math.min(1, dist / (FORM_SCALE * 0.8)), 4);
          const pull = containment * 0.1;
          
          // Apply gentle balanced motion
          particle.x = particle.x + (dx * combinedFlow) - (dx * pull);
          particle.y = particle.y + (dy * combinedFlow) - (dy * pull);
          particle.z = particle.z + Math.sin(timeRef.current * 0.15 + dist * 2) * 0.01;
          
          // Draw particle with depth-based opacity
          const depthFactor = 1 + particle.z * 0.5;
          const opacity = 0.35 * depthFactor;
          const size = Math.max(0.001, 0.6 * depthFactor); // Increased particle size by 20% from 0.5
          
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(51, 51, 51, ${opacity})`;
          ctx.fill();
        });
        
        // Update lastFrameTime, accounting for any remainder to prevent drift
        lastFrameTime = currentTime - (deltaTime % frameInterval);
      }
      
      // Continue animation loop
      animationFrameRef.current = requestAnimationFrame(animate);
    }
    
    // Start animation
    animationFrameRef.current = requestAnimationFrame(animate);
    
    return () => {
      // Cancel animation frame to prevent memory leaks
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
        animationFrameRef.current = null;
      }
      
      if (ctxRef.current && canvasRef.current) {
        ctxRef.current.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
      }
      
      if (canvasRef.current) {
        canvasRef.current.width = 0;
        canvasRef.current.height = 0;
      }
      
      if (particlesRef.current) {
        particlesRef.current.length = 0;
        particlesRef.current = null;
      }
      
      timeRef.current = 0;
      ctxRef.current = null;
    };
  }, []);
  
  return (
    <div style={{
      width: '550px',
      height: '550px',
      margin: 'auto',
      backgroundColor: '#F0EEE6',
      overflow: 'hidden'
    }}>
      <canvas
        ref={canvasRef}
        style={{
          display: 'block',
          width: '550px',
          height: '550px'
        }}
      />
    </div>
  );
};

export default ParticleFlower;
```

```javascript
import React, { useEffect, useRef } from 'react';
import * as THREE from 'three';

// themes: detachment leads to fulfillment, eternal endurance, selfless service
// visualization: A delicate structure that endures through transparency and interconnection

const PineconeDelicate = () => {
  const containerRef = useRef<HTMLDivElement | null>(null);
  const sceneRef = useRef<THREE.Scene | null>(null);
  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);
  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);
  const pineConeRef = useRef<THREE.Group | null>(null);
  const lightsRef = useRef<THREE.Light[]>([]);
  const resourcesRef = useRef({
    geometries: [] as THREE.BufferGeometry[],
    materials: [] as THREE.Material[],
    meshes: [] as THREE.Mesh[],
    lineSegments: [] as THREE.LineSegments[],
    scaleGroups: [] as THREE.Group[],
    instancedMeshes: [] as THREE.InstancedMesh[]
  });

  useEffect(() => {
    if (!containerRef.current) return;

    const { geometries, materials, meshes, lineSegments, scaleGroups, instancedMeshes } = resourcesRef.current;
    
    const scene = new THREE.Scene();
    sceneRef.current = scene;
    scene.background = new THREE.Color('#F0EEE6');
    
    const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    cameraRef.current = camera;
    camera.position.z = 16;
    camera.position.y = 0;
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    rendererRef.current = renderer;
    renderer.setSize(550, 550);
    containerRef.current.appendChild(renderer.domElement);
    
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    lightsRef.current.push(ambientLight);
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
    directionalLight.position.set(5, 10, 7.5);
    scene.add(directionalLight);
    lightsRef.current.push(directionalLight);
    
    const pineCone = new THREE.Group();
    pineConeRef.current = pineCone;
    
    // Create glass-like translucent scales - detachment made visible through transparency
    const shape = new THREE.Shape();
    shape.moveTo(0, 0);
    shape.lineTo(0.7, 0.7);
    shape.lineTo(0.5, 1.4);
    shape.lineTo(0, 1.7);
    shape.lineTo(-0.5, 1.4);
    shape.lineTo(-0.7, 0.7);
    shape.closePath();
    
    const extrudeSettings = {
      depth: 0.05,
      bevelEnabled: true,
      bevelSegments: 4, // Reduced from 8
      steps: 1,
      bevelSize: 0.02,
      bevelThickness: 0.02
    };
    
    const scaleGeometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    geometries.push(scaleGeometry);
    
    // Create materials once
    const glassMaterial = new THREE.MeshPhysicalMaterial({ 
      color: '#e0ded8',
      transparent: true,
      opacity: 0.15,
      roughness: 0.1,
      metalness: 0.0,
      transmission: 0.6,
      thickness: 0.1,
      side: THREE.DoubleSide
    });
    materials.push(glassMaterial);
    
    const wireframeMaterial = new THREE.LineBasicMaterial({ 
      color: '#666666',
      transparent: true,
      opacity: 0.3
    });
    materials.push(wireframeMaterial);
    
    // Create edge geometry once
    const edgesGeometry = new THREE.EdgesGeometry(scaleGeometry);
    geometries.push(edgesGeometry);
    
    const layers = 38;
    const scalesPerLayer = 8;
    const totalScales = layers * scalesPerLayer;
    
    // Use InstancedMesh for better performance
    const instancedMesh = new THREE.InstancedMesh(scaleGeometry, glassMaterial, totalScales);
    instancedMeshes.push(instancedMesh);
    
    // Create a separate instanced mesh for wireframes using LineSegments geometry
    const wireframePositions: number[] = [];
    const wireframeColors: number[] = [];
    
    let scaleIndex = 0;
    const matrix = new THREE.Matrix4();
    const position = new THREE.Vector3();
    const rotation = new THREE.Euler();
    const quaternion = new THREE.Quaternion();
    const scale = new THREE.Vector3();
    
    for (let layer = 0; layer < layers; layer++) {
      const yPosition = (layer / layers) * 18 - 9 - 0.9;
      let layerRadius;
      
      if (layer < 10) {
        layerRadius = Math.sin((layer / 10) * Math.PI * 0.5) * 2;
      } else {
        layerRadius = 2 + Math.sin(((layer - 10) / (layers - 10)) * Math.PI) * 2.5;
      }
      
      const taper = 1 - (layer / layers) * 0.3;
      
      for (let i = 0; i < scalesPerLayer; i++) {
        const angle = (i / scalesPerLayer) * Math.PI * 2 + (layer * 0.25);
        
        // Set position
        position.set(
          Math.cos(angle) * layerRadius * taper,
          yPosition,
          Math.sin(angle) * layerRadius * taper
        );
        
        // Set rotation
        rotation.set(Math.PI / 3, angle, 0);
        quaternion.setFromEuler(rotation);
        
        // Set scale
        scale.set(0.8, 0.8, 0.8);
        
        // Compose matrix
        matrix.compose(position, quaternion, scale);
        instancedMesh.setMatrixAt(scaleIndex, matrix);
        
        scaleIndex++;
      }
    }
    
    instancedMesh.instanceMatrix.needsUpdate = true;
    pineCone.add(instancedMesh);
    
    // Create wireframe lines separately for better performance
    const wireframeGroup = new THREE.Group();
    for (let layer = 0; layer < layers; layer++) {
      const yPosition = (layer / layers) * 18 - 9 - 0.9;
      let layerRadius;
      
      if (layer < 10) {
        layerRadius = Math.sin((layer / 10) * Math.PI * 0.5) * 2;
      } else {
        layerRadius = 2 + Math.sin(((layer - 10) / (layers - 10)) * Math.PI) * 2.5;
      }
      
      const taper = 1 - (layer / layers) * 0.3;
      
      for (let i = 0; i < scalesPerLayer; i++) {
        const angle = (i / scalesPerLayer) * Math.PI * 2 + (layer * 0.25);
        
        const wireframe = new THREE.LineSegments(edgesGeometry, wireframeMaterial);
        wireframe.rotation.x = Math.PI / 3;
        wireframe.rotation.y = angle;
        wireframe.position.x = Math.cos(angle) * layerRadius * taper;
        wireframe.position.z = Math.sin(angle) * layerRadius * taper;
        wireframe.position.y = yPosition;
        wireframe.scale.set(0.8, 0.8, 0.8);
        
        lineSegments.push(wireframe);
        wireframeGroup.add(wireframe);
      }
    }
    
    pineCone.add(wireframeGroup);
    
    scene.add(pineCone);
    
    let time = 0;
    let animationFrameId: number;
    
    function animate() {      
      animationFrameId = requestAnimationFrame(animate);
      
      time += 0.005;
      
      pineCone.rotation.y = time * 0.3;
      pineCone.rotation.x = Math.sin(time * 0.5) * 0.05;
      pineCone.rotation.z = Math.cos(time * 0.7) * 0.03;
      
      const breathe = 1 + Math.sin(time * 0.5) * 0.02;
      pineCone.scale.set(breathe, breathe, breathe);
      
      renderer.render(scene, camera);
    }
    
    animate();
    
    return () => {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      if (sceneRef.current) {
        lightsRef.current.forEach(light => {
          sceneRef.current!.remove(light);
        });
        
        if (pineConeRef.current) {
          sceneRef.current.remove(pineConeRef.current);
        }
      }
      
      resourcesRef.current.scaleGroups.forEach(group => {
        if (pineConeRef.current) {
          pineConeRef.current.remove(group);
        }
        while (group.children.length > 0) {
          group.remove(group.children[0]);
        }
      });
      
      resourcesRef.current.meshes.forEach(mesh => {
        if (mesh.parent) {
          mesh.parent.remove(mesh);
        }
      });
      
      resourcesRef.current.lineSegments.forEach(line => {
        if (line.parent) {
          line.parent.remove(line);
        }
      });
      
      resourcesRef.current.instancedMeshes.forEach(instancedMesh => {
        if (instancedMesh.parent) {
          instancedMesh.parent.remove(instancedMesh);
        }
        instancedMesh.dispose();
      });
      
      resourcesRef.current.geometries.forEach(geometry => {
        geometry.dispose();
      });
      
      resourcesRef.current.materials.forEach(material => {
        material.dispose();
      });
      
      if (rendererRef.current) {
        rendererRef.current.dispose();
        
        if (containerRef.current && rendererRef.current.domElement) {
          containerRef.current.removeChild(rendererRef.current.domElement);
        }
      }
      
      sceneRef.current = null;
      rendererRef.current = null;
      cameraRef.current = null;
      pineConeRef.current = null;
      lightsRef.current = [];
      resourcesRef.current = {
        geometries: [],
        materials: [],
        meshes: [],
        lineSegments: [],
        scaleGroups: [],
        instancedMeshes: []
      };
    };
  }, []);

  return (
    <div className="w-full h-screen flex justify-center items-center bg-[#F0EEE6]">
      <div 
        ref={containerRef}
        className="w-[550px] h-[550px]"
      />
    </div>
  );
};

export default PineconeDelicate;
```

```javascript
import React, { useState, useEffect, useRef, useMemo, useCallback } from 'react';

// themes: water as highest good, finding low places, grace without force
// visualization: ASCII characters flow like water, seeking their natural level without effort

// Custom hook for requestAnimationFrame
const useAnimationFrame = (callback: (deltaTime: number) => void, isRunning = true) => {
  const requestRef = useRef<number | null>(null);
  const previousTimeRef = useRef<number | null>(null);
  
  const animate = useCallback((time: number) => {
    if (previousTimeRef.current !== null) {
      const deltaTime = time - previousTimeRef.current;
      callback(deltaTime);
    }
    previousTimeRef.current = time;
    requestRef.current = requestAnimationFrame(animate);
  }, [callback]);
  
  useEffect(() => {
    if (isRunning) {
      requestRef.current = requestAnimationFrame(animate);
    }
    
    return () => {
      if (requestRef.current !== null) {
        cancelAnimationFrame(requestRef.current);
        requestRef.current = null;
      }
      previousTimeRef.current = null;
    };
  }, [animate, isRunning]);
};

const WaterAscii: React.FC = () => {
  const [frame, setFrame] = useState(0);
  const containerRef = useRef<HTMLDivElement>(null);
  const characters = '~≈≋⋿⊰⊱◟◝';
  const rows = 25;
  const cols = 52; // Adjusted for better fit in container
  
  // Pre-calculate constants
  const centerPos = { x: 0.5, y: 0.5 };
  const charactersLength = characters.length;
  const charLengthDivide4 = charactersLength / 4;
  const piTimes2 = Math.PI * 2;
  
  // Track time for animation updates
  const lastUpdateRef = useRef<number>(0);

  // Animation frame callback
  const updateAnimation = useCallback((deltaTime: number) => {
    // Update only every ~100ms for performance
    lastUpdateRef.current += deltaTime;
    if (lastUpdateRef.current > 166) { // ~166ms for 0.6x original speed (slowed another 25%)
      setFrame(f => f + 1);
      lastUpdateRef.current = 0;
    }
  }, []);

  // Use animation frame instead of setInterval
  useAnimationFrame(updateAnimation);

  useEffect(() => {
    return () => {
      lastUpdateRef.current = 0;
    };
  }, []);

  // Generate ASCII art - like water finding its natural path
  const generateAscii = useCallback(() => {
    
    const rowsArray = [];
    const frameDiv4 = frame / 6.7;  // 0.6x speed (4 -> 6.7, additional 25% reduction)
    const frameDiv5 = frame / 8.3;  // 0.6x speed (5 -> 8.3, additional 25% reduction)
    const frameDiv8 = frame / 13.3; // 0.6x speed (8 -> 13.3, additional 25% reduction)
    
    for (let y = 0; y < rows; y++) {
      const yDivRows = y / rows;
      const yDiv5 = y / 5;
      const yDiv3 = y / 3;
      let rowString = '';
      let rowOpacity = 1;
      
      for (let x = 0; x < cols; x++) {
        const xDivCols = x / cols;
        const xDiv3 = x / 3;
        const xDiv4 = x / 4;
        
        // Calculate distance from center (fixed point)
        const dx = xDivCols - centerPos.x;
        const dy = yDivRows - centerPos.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const distTimes10 = dist * 10;
        const distTimes5 = dist * 5;

        // Create wave pattern - grace flowing without force
        const wave = Math.sin(xDiv3 + yDiv5 + frameDiv4 + distTimes10) + 
                    Math.cos(xDiv4 - yDiv3 - frameDiv5) +
                    Math.sin(frameDiv8 + xDivCols * piTimes2);

        // Choose character based on wave value and distance
        const charValue = (wave + 2) * charLengthDivide4 + distTimes5;
        const charIndex = Math.floor(Math.abs(charValue)) % charactersLength;
        
        // Calculate opacity - characters seek lower places like water
        const opacity = Math.max(0.2, Math.min(0.8, 1 - dist + Math.sin(wave) / 3));
        
        // Set row opacity to average of all opacity values in the row (approximation)
        if (x === 0) rowOpacity = opacity;
        else rowOpacity = (rowOpacity + opacity) / 2;
        
        rowString += characters[charIndex];
      }
      
      rowsArray.push({ text: rowString, opacity: rowOpacity });
    }
    return rowsArray;
  }, [frame, rows, cols, charactersLength, charLengthDivide4, piTimes2, centerPos.x, centerPos.y, characters]);

  // Calculate ASCII art on frame changes
  const ascii = useMemo(() => generateAscii(), [generateAscii]);

  // Memoize styles to prevent recalculation
  const containerStyle = useMemo(() => ({ 
    margin: 0,
    background: '#F0EEE6',
    overflow: 'hidden',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    height: '100%'
  }), []);

  const innerContainerStyle = useMemo(() => ({
    padding: '30px',
    position: 'relative' as const,
    width: '100%',
    height: '100%',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
  }), []);

  const preStyle = useMemo(() => ({
    fontFamily: 'monospace',
    fontSize: '10px',
    lineHeight: '1',
    cursor: 'default',
    userSelect: 'none' as const,
    margin: 0,
    padding: '20px'
  }), []);

  return (
    <div style={containerStyle}>
      <div 
        ref={containerRef}
        style={innerContainerStyle}
      >
        <pre style={preStyle}>
          {ascii.map((row, i) => (
            <div 
              key={i} 
              style={{ 
                opacity: row.opacity, 
                margin: 0,
                lineHeight: '1' 
              }}
            >
              {row.text}
            </div>
          ))}
        </pre>
      </div>
    </div>
  );
};

export default WaterAscii;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: excess leads to loss, detachment after completion, the way of heaven
// visualization: Particles flow naturally downward, neither clinging nor overflowing

const CanyonMultiLayerFlows = () => {
  const canvasRef = useRef(null);
  const animationFrameRef = useRef(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width = 550;
    const height = canvas.height = 550;
    const centerX = width / 2;
    const centerY = height / 2;
    
    const PARTICLE_COUNT = 20000;  // Reduced particle count for softer look
    const WALL_LAYERS = 8;
    const particles = [];
    
    // Create particles - balanced between fullness and emptiness
    for (let i = 0; i < PARTICLE_COUNT; i++) {
      // Determine wall side (-1 or 1) and layer
      const side = Math.random() < 0.5 ? -1 : 1;
      const layer = Math.floor(Math.random() * WALL_LAYERS);
      const y = Math.random() * height;
      
      // Create multiple wave functions for complex undulations
      const wavePhase1 = y * 0.008;
      const wavePhase2 = y * 0.03;
      const wavePhase3 = y * 0.05;
      
      const baseWave = Math.sin(wavePhase1) * 50;
      const secondaryWave = Math.sin(wavePhase2 * 2 + layer * 0.5) * 25;
      const tertiaryWave = Math.sin(wavePhase3 * 3 + layer * 1.2) * 12;
      
      const combinedWave = baseWave + secondaryWave + tertiaryWave;
      const layerDepth = layer * 15;
      const wallThickness = 20 + layer * 8;
      
      const baseX = centerX + side * (80 + combinedWave + layerDepth);
      const offsetX = (Math.random() - 0.5) * wallThickness;
      
      particles.push({
        x: baseX + offsetX,
        y: y,
        z: (layer - WALL_LAYERS/2) * 20 + (Math.random() - 0.5) * 15,
        side: side,
        layer: layer,
        initialY: y,
        drift: Math.random() * Math.PI * 2,
        speed: 0.1 + layer * 0.02,
        brightness: 0.7 + Math.random() * 0.3
      });
    }
    
    let time = 0;
    
    function animate() {
      time += 0.016;
      
      // Clear with subtle persistence
      ctx.fillStyle = 'rgba(240, 238, 230, 0.05)';  // Increased fade for softer transitions
      ctx.fillRect(0, 0, width, height);
      
      // Sort particles by z-depth for proper layering
      particles.sort((a, b) => a.z - b.z);
      
      particles.forEach(particle => {
        // Calculate complex wave position
        const wavePhase1 = particle.y * 0.008 + time * 0.05;
        const wavePhase2 = particle.y * 0.03 + time * 0.1 + particle.layer * 0.5;
        const wavePhase3 = particle.y * 0.05 + time * 0.15 + particle.layer * 1.2;
        
        const baseWave = Math.sin(wavePhase1) * 50;
        const secondaryWave = Math.sin(wavePhase2 * 2) * 25;
        const tertiaryWave = Math.sin(wavePhase3 * 3) * 12;
        
        const combinedWave = baseWave + secondaryWave + tertiaryWave;
        const layerDepth = particle.layer * 15;
        const wallThickness = 20 + particle.layer * 8;
        
        // Calculate target position with layer offset
        const targetX = centerX + particle.side * (80 + combinedWave + layerDepth);
        const layerDrift = Math.sin(particle.drift + time * 0.5 + particle.layer * 0.3) * wallThickness * 0.5;
        
        // Smooth movement
        particle.x = particle.x * 0.92 + (targetX + layerDrift) * 0.08;
        particle.y += particle.speed;
        
        // Add depth oscillation
        particle.z += Math.sin(time * 0.4 + particle.drift + particle.layer * 0.8) * 0.2;
        
        // Reset at bottom - detachment after completion
        if (particle.y > height + 30) {
          particle.y = -30;
          particle.drift = Math.random() * Math.PI * 2;
        }
        
        // Draw with layer-based effects - following heaven's way of moderation
        const depthFactor = (particle.z + WALL_LAYERS * 10) / (WALL_LAYERS * 20);
        const opacity = 0.25 + depthFactor * 0.15;
        const size = 0.3 + depthFactor * 0.3;  // Base size 0.3, scaling 0.3 to reach max of 0.6
        const brightness = 120 + particle.layer * 3 + particle.brightness * 15;  // Much lighter gray
        
        if (opacity > 0 && size > 0) {
          // Layer-based glow
          if (particle.layer < 3) {
            ctx.beginPath();
            ctx.arc(particle.x, particle.y, size * 1.5, 0, Math.PI * 2);  // Reduced glow radius multiplier from 2 to 1.5
            ctx.fillStyle = `rgba(${brightness}, ${brightness}, ${brightness}, ${opacity * 0.1})`;
            ctx.fill();
          }
          
          // Main particle
          ctx.beginPath();
          ctx.arc(particle.x, particle.y, size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(${brightness}, ${brightness}, ${brightness}, ${opacity})`;
          ctx.fill();
        }
      });
      
      animationFrameRef.current = requestAnimationFrame(animate);
    }
    
    animate();
    
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
        animationFrameRef.current = null;
      }
      if (canvas && ctx) {
        ctx.clearRect(0, 0, width, height);
      }
      particles.length = 0;
    };
  }, []);
  
  return (
    <div style={{
      width: '550px',
      height: '550px',
      margin: 'auto',
      backgroundColor: '#F0EEE6',
      overflow: 'hidden'
    }}>
      <canvas
        ref={canvasRef}
        style={{
          display: 'block',
          width: '550px',
          height: '550px'
        }}
      />
    </div>
  );
};

export default CanyonMultiLayerFlows;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: present awareness, leading without control, doing without expectation
// visualization: A meditative circle that breathes and flows while remaining centered in stillness

const WavyYinYangNoDots = () => {
  const canvasRef = useRef(null);
  const animationFrameRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const centerX = width / 2;
    const centerY = height / 2;
    const maxRadius = width * 0.45;
    
    let time = 0;
    
    const draw = () => {
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, width, height);
      
      // Draw wavy concentric lines - present in each moment of transformation
      for (let r = 5; r < maxRadius; r += 3) {
        ctx.beginPath();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 0.6;
        
        for (let angle = 0; angle < Math.PI * 2; angle += 0.02) {
          // Animate the wave with time
          const wave = Math.sin(angle * 8 + r * 0.1 + time) * 2;
          const x = centerX + (r + wave) * Math.cos(angle);
          const y = centerY + (r + wave) * Math.sin(angle);
          
          // Create yin-yang boundary - leading without controlling its flow
          const isYin = (angle > Math.PI) ? 
            (Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - (centerY + maxRadius/4), 2)) < maxRadius/4) :
            (Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - (centerY - maxRadius/4), 2)) > maxRadius/4);
          
          if (isYin) {
            ctx.strokeStyle = 'rgba(0,0,0,0.3)';
            ctx.lineTo(x, y);
          } else {
            ctx.strokeStyle = '#000';
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
      }
      
      // Continue without expectation, each frame arising naturally
      time += 0.015;
      animationFrameRef.current = requestAnimationFrame(draw);
    };
    
    draw();
    
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
        animationFrameRef.current = null;
      }
      if (canvas && ctx) {
        ctx.clearRect(0, 0, width, height);
      }
    };
  }, []);

  return (
    <div style={{ 
      width: '550px',
      height: '550px',
      backgroundColor: '#F0EEE6',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center'
    }}>
      <canvas 
        ref={canvasRef} 
        width={550} 
        height={550} 
      />
    </div>
  );
};

export default WavyYinYangNoDots;
```

```javascript
import React, { useEffect, useRef } from 'react';
import * as THREE from 'three';

// themes: emptiness creates utility, space enables function, usefulness through void
// visualization: Three structures defined by their empty spaces - a wheel's hub, a vessel's cavity, a room's openings

const VoidArchitecture = () => {
  const mountRef = useRef(null);

  useEffect(() => {
    const container = mountRef.current;
    if (!container) return;

    // Get container dimensions
    const width = container.clientWidth;
    const height = container.clientHeight;
    const dpr = window.devicePixelRatio || 1;

    // Set up scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });

    // Improve sharpness for high DPI screens
    renderer.setPixelRatio(Math.min(dpr, 2)); // Cap at 2 for performance
    renderer.setSize(width, height);
    renderer.setClearColor(0xF0EEE6);

    container.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040);
    const directionalLight = new THREE.DirectionalLight(0x808080, 1);
    directionalLight.position.set(1, 1, 1);
    scene.add(ambientLight);
    scene.add(directionalLight);

    // Materials
    const material = new THREE.LineBasicMaterial({ 
      color: 0x333333,
      transparent: true,
      opacity: 0.6
    });

    // Create wheel structure ("Thirty spokes join the hub")
    const createWheel = () => {
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const spokes = 30;
      const radius = 8;
      const hubRadius = 1;
      
      // Create hub
      for (let i = 0; i < spokes; i++) {
        const angle = (i / spokes) * Math.PI * 2;
        const nextAngle = ((i + 1) / spokes) * Math.PI * 2;
        
        // Hub circle
        vertices.push(
          Math.cos(angle) * hubRadius, 0, Math.sin(angle) * hubRadius,
          Math.cos(nextAngle) * hubRadius, 0, Math.sin(nextAngle) * hubRadius
        );
        
        // Spokes
        vertices.push(
          Math.cos(angle) * hubRadius, 0, Math.sin(angle) * hubRadius,
          Math.cos(angle) * radius, 0, Math.sin(angle) * radius
        );
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      return new THREE.LineSegments(geometry, material);
    };

    // Create vessel ("Clay forms a vessel")
    const createVessel = () => {
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const layers = 20;
      const pointsPerLayer = 16;
      
      for (let i = 0; i <= layers; i++) {
        const y = i - layers/2;
        // Create vessel shape
        const radius = 3 * Math.sin(Math.PI * (i/layers));
        
        for (let j = 0; j < pointsPerLayer; j++) {
          const angle1 = (j/pointsPerLayer) * Math.PI * 2;
          const angle2 = ((j+1)/pointsPerLayer) * Math.PI * 2;
          
          vertices.push(
            Math.cos(angle1) * radius, y, Math.sin(angle1) * radius,
            Math.cos(angle2) * radius, y, Math.sin(angle2) * radius
          );

          // Vertical lines
          if (i < layers) {
            vertices.push(
              Math.cos(angle1) * radius, y, Math.sin(angle1) * radius,
              Math.cos(angle1) * radius, y + 1, Math.sin(angle1) * radius
            );
          }
        }
      }

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      return new THREE.LineSegments(geometry, material);
    };

    // Create room structure ("We build walls with windows and doors")
    const createRoom = () => {
      const geometry = new THREE.BufferGeometry();
      const vertices = [];
      const size = 6;
      const height = 8;
      
      // Base frame
      const basePoints = [
        [-size, 0, -size],
        [size, 0, -size],
        [size, 0, size],
        [-size, 0, size],
        [-size, height, -size],
        [size, height, -size],
        [size, height, size],
        [-size, height, size]
      ];

      // Connect base points
      for (let i = 0; i < 4; i++) {
        // Bottom square
        vertices.push(
          ...basePoints[i],
          ...basePoints[(i + 1) % 4]
        );
        // Top square
        vertices.push(
          ...basePoints[i + 4],
          ...basePoints[((i + 1) % 4) + 4]
        );
        // Vertical lines
        vertices.push(
          ...basePoints[i],
          ...basePoints[i + 4]
        );
      }

      // Add door frame
      const doorWidth = 2;
      const doorHeight = 4;
      vertices.push(
        -doorWidth/2, 0, -size,
        -doorWidth/2, doorHeight, -size,
        doorWidth/2, 0, -size,
        doorWidth/2, doorHeight, -size,
        -doorWidth/2, doorHeight, -size,
        doorWidth/2, doorHeight, -size
      );

      // Add windows
      const windowSize = 1.5;
      const windowHeight = 5;
      const addWindow = (x, z) => {
        vertices.push(
          x - windowSize, windowHeight - windowSize, z,
          x + windowSize, windowHeight - windowSize, z,
          x + windowSize, windowHeight + windowSize, z,
          x - windowSize, windowHeight + windowSize, z,
          x - windowSize, windowHeight - windowSize, z
        );
      };

      // Add windows to sides
      addWindow(-size, 0);
      addWindow(size, 0);

      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      return new THREE.LineSegments(geometry, material);
    };

    const wheel = createWheel();
    const vessel = createVessel();
    const room = createRoom();

    // Position elements
    wheel.position.set(-12, 0, 0);
    vessel.position.set(12, 0, 0);
    room.position.set(0, -4, 0);

    scene.add(wheel);
    scene.add(vessel);
    scene.add(room);

    // Position camera
    camera.position.set(15, 15, 25);
    camera.lookAt(0, 0, 0);

    // Animation
    let frameId;
    const animate = () => {
      frameId = requestAnimationFrame(animate);

      // Gentle rotation
      wheel.rotation.y += 0.002;
      vessel.rotation.y += 0.001;
      room.rotation.y += 0.0005;

      renderer.render(scene, camera);
    };
    animate();

    // Handle resize
    const handleResize = () => {
      const width = container.clientWidth;
      const height = container.clientHeight;
      const dpr = window.devicePixelRatio || 1;
      
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
      renderer.setPixelRatio(Math.min(dpr, 2)); // Update pixel ratio on resize
      renderer.setSize(width, height);
    };
    window.addEventListener('resize', handleResize);

    // Cleanup function
    return () => {
      window.removeEventListener('resize', handleResize);
      cancelAnimationFrame(frameId);
      
      // Clean up Three.js resources
      if (renderer) {
        renderer.dispose();
        if (container.contains(renderer.domElement)) {
          container.removeChild(renderer.domElement);
        }
      }
      
      // Clean up geometry materials
      scene.traverse((object) => {
        if (object instanceof THREE.Mesh) {
          if (object.geometry) object.geometry.dispose();
          if (object.material) {
            if (Array.isArray(object.material)) {
              object.material.forEach(material => material.dispose());
            } else {
              object.material.dispose();
            }
          }
        }
      });
    };
  }, []);

  return (
    <div 
      ref={mountRef}
      style={{ 
        margin: 0,
        background: '#F0EEE6',
        overflow: 'hidden',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        height: '100vh',
        width: '100vw',
        position: 'relative'
      }}
    />
  );
};

export default VoidArchitecture;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: inner over outer, simplicity over sensation, open heart over thought
// visualization: A form that transforms from complex to simple, revealing inner essence beneath surface appearance

const Metamorphosis = () => {
  const canvasRef = useRef(null);
  const animationFrameRef = useRef(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Configuration
    const numLines = 120;
    const lineSegments = 180;
    const lineAlpha = 0.5;
    const lineWidth = 0.6;
    const morphSpeed = 0.0005;
    const rotateSpeed = 0.00025;
    
    // Start after initial pause
    let time = 2000;
    
    // Form definitions - moving from outer complexity to inner simplicity
    const forms = [
      // Form 1: Draped cloth-like shape
      (u, v, t) => {
        const theta = u * Math.PI * 2;
        const phi = v * Math.PI;
        
        let r = 120 + 30 * Math.sin(phi * 4 + theta * 2);
        r += 20 * Math.sin(phi * 6) * Math.cos(theta * 3);
        
        let x = r * Math.sin(phi) * Math.cos(theta);
        let y = r * Math.sin(phi) * Math.sin(theta);
        let z = r * Math.cos(phi) + 20 * Math.sin(theta * 5 + phi * 3);
        
        return { x, y, z };
      },
      
      // Form 2: More angular folded shape
      (u, v, t) => {
        const theta = u * Math.PI * 2;
        const phi = v * Math.PI;
        
        let r = 150 + 20 * Math.cos(phi * 8);
        r *= 0.8 + 0.2 * Math.abs(Math.cos(theta * 2));
        
        let x = r * Math.sin(phi) * Math.cos(theta);
        let y = r * Math.sin(phi) * Math.sin(theta);
        let z = r * Math.cos(phi) * (0.8 + 0.3 * Math.sin(theta * 4));
        
        return { x, y, z };
      },
      
      // Form 3: Organic bulbous shape
      (u, v, t) => {
        const theta = u * Math.PI * 2;
        const phi = v * Math.PI;
        
        let r = 120;
        r += 50 * Math.sin(phi * 3) * Math.sin(theta * 2.5);
        r += 30 * Math.cos(phi * 5 + theta);
        
        let x = r * Math.sin(phi) * Math.cos(theta);
        let y = r * Math.sin(phi) * Math.sin(theta);
        let z = r * Math.cos(phi);
        
        // Create some hollow areas
        const hollow = Math.max(0, Math.sin(phi * 2 + theta * 3) - 0.7);
        r *= 1 - hollow * 0.8;
        
        return { x, y, z };
      }
    ];
    
    // Interpolate between forms - letting go of surface to reveal essence
    const interpolateForms = (formA, formB, u, v, t, blend) => {
      const pointA = formA(u, v, t);
      const pointB = formB(u, v, t);
      
      return {
        x: pointA.x * (1 - blend) + pointB.x * blend,
        y: pointA.y * (1 - blend) + pointB.y * blend,
        z: pointA.z * (1 - blend) + pointB.z * blend
      };
    };
    
    // Get the current form - opening to transformation with an open heart
    const getCurrentForm = (u, v, t) => {
      // Calculate which two forms to blend between
      const totalForms = forms.length;
      const cycleTime = 600; // Time to complete one full cycle
      const position = (t % (cycleTime * totalForms)) / cycleTime;
      const formIndex = Math.floor(position);
      const nextFormIndex = (formIndex + 1) % totalForms;
      
      // Calculate blend with pause and easing
      let rawBlend = position - formIndex;
      
      // No pause between transitions
      const pauseTime = 0;
      const transitionTime = 1 - (pauseTime * 2); // Remaining time for the transition
      
      let blend;
      if (rawBlend < pauseTime) {
        // Initial pause
        blend = 0;
      } else if (rawBlend > (1 - pauseTime)) {
        // End pause
        blend = 1;
      } else {
        // Transition with easing
        const normalizedTime = (rawBlend - pauseTime) / transitionTime;
        // Ease in-out cubic
        blend = normalizedTime < 0.5
          ? 4 * normalizedTime * normalizedTime * normalizedTime
          : 1 - Math.pow(-2 * normalizedTime + 2, 3) / 2;
      }
      
      return interpolateForms(
        forms[formIndex], 
        forms[nextFormIndex], 
        u, v, t, blend
      );
    };
    
    // Animation loop
    const animate = () => {
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, width, height);
      
      // Calculate rotation based on time
      const rotateX = Math.sin(time * rotateSpeed) * 0.5;
      const rotateY = Math.cos(time * rotateSpeed * 0.7) * 0.3;
      const rotateZ = time * rotateSpeed * 0.1;
      
      // Draw horizontal contour lines
      for (let i = 0; i < numLines; i++) {
        const v = i / (numLines - 1);
        
        ctx.beginPath();
        ctx.strokeStyle = `rgba(51, 51, 51, ${lineAlpha})`;
        ctx.lineWidth = lineWidth;
        
        let lastPointVisible = false;
        let lastPoint = null;
        
        for (let j = 0; j <= lineSegments; j++) {
          const u = j / lineSegments;
          
          // Get the current form
          const point = getCurrentForm(u, v, time);
          
          // Apply rotation
          const rotatedX = point.x * Math.cos(rotateZ) - point.y * Math.sin(rotateZ);
          const rotatedY = point.x * Math.sin(rotateZ) + point.y * Math.cos(rotateZ);
          const rotatedZ = point.z;
          
          // Project to screen
          const scale = 1.5 + rotatedZ * 0.001;
          const projX = width / 2 + rotatedX * scale;
          const projY = height / 2 + rotatedY * scale;
          
          // Check if point should be visible (simple back-face culling)
          const pointVisible = rotatedZ > -50;
          
          if (j === 0) {
            if (pointVisible) {
              ctx.moveTo(projX, projY);
              lastPointVisible = true;
              lastPoint = { x: projX, y: projY };
            }
          } else {
            if (pointVisible && lastPointVisible) {
              ctx.lineTo(projX, projY);
            } else if (pointVisible && !lastPointVisible) {
              ctx.moveTo(projX, projY);
            }
          }
          
          lastPointVisible = pointVisible;
          lastPoint = { x: projX, y: projY };
        }
        
        ctx.stroke();
      }
      
      // Draw vertical contour lines (fewer)
      for (let i = 0; i < numLines * 0.3; i++) {
        const u = i / (numLines * 0.3 - 1);
        
        ctx.beginPath();
        ctx.strokeStyle = `rgba(51, 51, 51, ${lineAlpha * 0.7})`;
        ctx.lineWidth = lineWidth * 0.7;
        
        let lastPointVisible = false;
        let lastPoint = null;
        
        for (let j = 0; j <= lineSegments * 0.5; j++) {
          const v = j / (lineSegments * 0.5);
          
          // Get the current form
          const point = getCurrentForm(u, v, time);
          
          // Apply rotation
          const rotatedX = point.x * Math.cos(rotateZ) - point.y * Math.sin(rotateZ);
          const rotatedY = point.x * Math.sin(rotateZ) + point.y * Math.cos(rotateZ);
          const rotatedZ = point.z;
          
          // Project to screen
          const scale = 1.5 + rotatedZ * 0.001;
          const projX = width / 2 + rotatedX * scale;
          const projY = height / 2 + rotatedY * scale;
          
          // Check if point should be visible
          const pointVisible = rotatedZ > -50;
          
          if (j === 0) {
            if (pointVisible) {
              ctx.moveTo(projX, projY);
              lastPointVisible = true;
              lastPoint = { x: projX, y: projY };
            }
          } else {
            if (pointVisible && lastPointVisible) {
              ctx.lineTo(projX, projY);
            } else if (pointVisible && !lastPointVisible) {
              ctx.moveTo(projX, projY);
            }
          }
          
          lastPointVisible = pointVisible;
          lastPoint = { x: projX, y: projY };
        }
        
        ctx.stroke();
      }
      
      time += 0.5;
      animationFrameRef.current = requestAnimationFrame(animate);
    };
    
    animate();
    
    // Cleanup
    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
        animationFrameRef.current = null;
      }
      if (canvas && ctx) {
        ctx.clearRect(0, 0, width, height);
      }
    };
  }, []);
  
  return (
    <div className="flex items-center justify-center bg-[#F0EEE6] w-full h-full">
      <canvas ref={canvasRef} width={550} height={550} />
    </div>
  );
};

export default Metamorphosis;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: success equals failure, hope equals fear, finding balance in self
// visualization: A double helix where opposing forces dance in perfect equilibrium

const Artwork33 = () => {
  const canvasRef = useRef(null);
  const animationFrameRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const width = canvas.width = 800;
    const height = canvas.height = 600;

    // Core variables
    let time = 0;
    const particles = [];
    let helixPoints = [];
    const numParticles = 60; // Fewer particles
    const TWO_PI = Math.PI * 2;

    // Helper functions
    const random = (min, max) => {
      if (max === undefined) {
        max = min;
        min = 0;
      }
      return Math.random() * (max - min) + min;
    };

    const map = (value, start1, stop1, start2, stop2) => {
      return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
    };

    const dist = (x1, y1, z1, x2, y2, z2) => {
      const dx = x2 - x1;
      const dy = y2 - y1;
      const dz = z2 - z1;
      return Math.sqrt(dx * dx + dy * dy + dz * dz);
    };

    // HelixParticle - each point balanced between opposing forces
    class HelixParticle {
      constructor(initialPhase) {
        this.phase = initialPhase || random(TWO_PI);
        this.radius = random(90, 110);
        this.yOffset = random(-300, 300);
        this.ySpeed = random(0.3, 0.6) * (random() > 0.5 ? 1 : -1);
        this.rotationSpeed = random(0.005, 0.0075);
        this.size = random(3, 6); // Slightly larger points
        this.opacity = random(120, 180);
        this.strength = random(0.8, 1);
      }

      update() {
        // Update position - success and failure are one movement
        this.phase += this.rotationSpeed * this.strength;
        this.yOffset += this.ySpeed;

        // Reset position if it goes off screen
        if (this.yOffset > 350) this.yOffset = -350;
        if (this.yOffset < -350) this.yOffset = 350;

        // Calculate 3D position
        const x = width / 2 + Math.cos(this.phase) * this.radius;
        const y = height / 2 + this.yOffset;
        const z = Math.sin(this.phase) * this.radius;

        // Store position for drawing and connections
        return { x, y, z, strength: this.strength, size: this.size, opacity: this.opacity };
      }
    }

    // Create helix particles - fewer points
    for (let i = 0; i < numParticles; i++) {
      const initialPhase = (i / numParticles) * TWO_PI * 3; // Create 3 full rotations
      particles.push(new HelixParticle(initialPhase));
    }

    // Frame rate control variables
    const targetFPS = 30;
    const frameInterval = 1000 / targetFPS;
    let lastFrameTime = 0;

    const animate = (currentTime) => {
      // Initialize lastFrameTime on first frame
      if (!lastFrameTime) {
        lastFrameTime = currentTime;
        animationFrameRef.current = requestAnimationFrame(animate);
        return;
      }

      const deltaTime = currentTime - lastFrameTime;
      
      // Only render a new frame when enough time has passed (frame rate limiting)
      if (deltaTime >= frameInterval) {
        // Calculate remainder to prevent drift
        const remainder = deltaTime % frameInterval;
        
        // Update lastFrameTime with the time that's been processed
        lastFrameTime = currentTime - remainder;
        
        // Clear background
        ctx.fillStyle = '#F0EEE6';
        ctx.fillRect(0, 0, width, height);

        time += 0.02;

        // Update helix points
        helixPoints = particles.map(particle => particle.update());

        // Find balance between foreground and background, like hope and fear
        helixPoints.sort((a, b) => a.z - b.z);

        // Draw stronger connections between helix points
        ctx.lineWidth = 1.2; // Thicker lines

        // Connect helix points to create a strand structure
        for (let i = 0; i < helixPoints.length; i++) {
          const hp1 = helixPoints[i];

          // Connect to nearby points
          for (let j = 0; j < helixPoints.length; j++) {
            if (i !== j) {
              const hp2 = helixPoints[j];
              const d = dist(hp1.x, hp1.y, hp1.z, hp2.x, hp2.y, hp2.z);

              // Create more connections with a larger distance threshold
              if (d < 120) {
                // Calculate opacity based on distance and z-position (depth)
                const opacity = map(d, 0, 120, 40, 10) * 
                              map(Math.min(hp1.z, hp2.z), -110, 110, 0.3, 1);

                ctx.strokeStyle = `rgba(20, 20, 20, ${opacity / 255})`;
                ctx.beginPath();
                ctx.moveTo(hp1.x, hp1.y);
                ctx.lineTo(hp2.x, hp2.y);
                ctx.stroke();
              }
            }
          }
        }

        // Draw helix points with size based on z-position for 3D effect
        for (let i = 0; i < helixPoints.length; i++) {
          const hp = helixPoints[i];
          // Calculate size and opacity based on z-position (depth)
          const sizeMultiplier = map(hp.z, -110, 110, 0.6, 1.3);
          const adjustedOpacity = map(hp.z, -110, 110, hp.opacity * 0.4, hp.opacity);

          ctx.fillStyle = `rgba(10, 10, 10, ${adjustedOpacity / 255})`;
          ctx.beginPath();
          ctx.arc(hp.x, hp.y, (hp.size * sizeMultiplier) / 2, 0, TWO_PI);
          ctx.fill();
        }

        // Create spinal connections - stronger central structure
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.118)'; // 30/255 ≈ 0.118
        ctx.lineWidth = 2;

        // Sort by y position for the spine
        const sortedByY = [...helixPoints].sort((a, b) => a.y - b.y);

        // Draw spine connecting points with similar y positions
        for (let i = 0; i < sortedByY.length - 1; i++) {
          const p1 = sortedByY[i];
          const p2 = sortedByY[i + 1];

          // Only connect if they're close in y position
          if (Math.abs(p1.y - p2.y) < 30) {
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
          }
        }
      }

      // Request next frame
      animationFrameRef.current = requestAnimationFrame(animate);
    };

    // Start the animation immediately with proper frame timing
    animationFrameRef.current = requestAnimationFrame(animate);

    return () => {
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
        animationFrameRef.current = null;
      }
      if (canvas && ctx) {
        ctx.clearRect(0, 0, width, height);
      }
    };
  }, []);

  return (
    <div className="w-full min-h-screen bg-[#F0EEE6] flex flex-col items-center justify-center">
      <div className="border-0 overflow-hidden">
        <canvas ref={canvasRef} width={800} height={600} />
      </div>
    </div>
  );
};

export default Artwork33;
```

```javascript
import { useRef, useEffect } from 'react';

// themes: the formless and intangible, merging into oneness, return to nothingness
// visualization: Waves of varying opacity merge and dissolve, revealing the formless nature beneath form

const LayeredSineWaves = () => {
  const canvasRef = useRef(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Parameters
    const layers = 80;
    const points = 200;
    const waveAmplitude = 40;
    let time = 0;
    let animationId = null;
    
    function draw() {
      ctx.clearRect(0, 0, width, height);
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, width, height);
      
      time += 0.01;
      
      // Draw each layer - forms emerging from the formless
      for (let layer = 0; layer < layers; layer++) {
        const layerPosition = (layer / layers) * height * 0.8 + height * 0.1;
        const layerFrequency = 0.5 + layer * 0.03;
        const layerPhase = time * 0.2 + layer * 0.05;
        const layerAmplitude = waveAmplitude * (0.5 + 0.5 * Math.sin(layer * 0.1 + time * 0.3));
        
        // Set opacity based on layer position and time
        const baseOpacity = 0.2 + 0.6 * Math.pow(Math.sin((layer / layers) * Math.PI), 2);
        const timeEffect = 0.2 * Math.sin(time * 0.4 + layer * 0.1);
        const opacity = Math.min(0.9, Math.max(0.1, baseOpacity + timeEffect));
        
        ctx.beginPath();
        // Use grayscale instead of red
        ctx.strokeStyle = `rgba(50, 50, 50, ${opacity})`;
        ctx.lineWidth = 0.6;
        
        // Generate points along the wave
        for (let i = 0; i <= points; i++) {
          const x = (i / points) * width;
          
          // Create complex wave with multiple sine components
          let y = layerPosition;
          
          // Primary wave
          y += layerAmplitude * Math.sin(x * 0.01 * layerFrequency + layerPhase);
          
          // Secondary waves for complexity
          y += layerAmplitude * 0.3 * Math.sin(x * 0.02 * layerFrequency + layerPhase * 1.5);
          y += layerAmplitude * 0.2 * Math.sin(x * 0.04 * layerFrequency - layerPhase * 0.7);
          
          // Tertiary high-frequency detail
          y += layerAmplitude * 0.1 * Math.sin(x * 0.08 * layerFrequency + layerPhase * 2.3);
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        ctx.stroke();
      }
      
      // Draw connecting lines - all merging into oneness
      for (let i = 0; i < width; i += 20) {
        if (Math.random() < 0.4) { // Only draw some vertical lines
          ctx.beginPath();
          
          const opacity = 0.1 + 0.2 * Math.sin(i * 0.05 + time);
          // Use grayscale instead of red
          ctx.strokeStyle = `rgba(50, 50, 50, ${opacity})`;
          ctx.lineWidth = 0.3;
          
          // Vary the line height
          const startY = height * 0.1 + Math.random() * height * 0.2;
          const endY = height * 0.7 + Math.random() * height * 0.2;
          
          ctx.moveTo(i, startY);
          ctx.lineTo(i, endY);
          ctx.stroke();
        }
      }
      
      animationId = requestAnimationFrame(draw);
    }
    
    // Animation loop
    animationId = requestAnimationFrame(draw);
    
    return () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
    };
  }, []);
  
  return (
    <div className="flex justify-center items-center h-full w-full bg-[#F0EEE6]">
      <canvas 
        ref={canvasRef} 
        width={550} 
        height={550} 
        className="shadow-lg"
      />
    </div>
  );
};

export default LayeredSineWaves;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: profound watchfulness, remaining still, presence in the moment
// visualization: Waves ripple outward from still points, creating patterns of watchful awareness

const WaveInterferenceV6 = () => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = 550;
    const height = 550;
    canvas.width = width;
    canvas.height = height;

    // Higher resolution for finer detail
    const resolution = 2;
    const gridWidth = Math.floor(width / resolution);
    const gridHeight = Math.floor(height / resolution);

    // Define still points of watchful awareness
    const sources = [
      { x: width/2, y: height/2 },
      { x: width/4, y: height/4 },
      { x: 3*width/4, y: height/4 },
      { x: width/4, y: 3*height/4 },
      { x: 3*width/4, y: 3*height/4 },
    ];

    const wavelength = 35; // Longer wavelength for gentler waves
    let time = 0;
    
    // Pre-create canvas for offscreen rendering
    const offscreenCanvas = document.createElement('canvas');
    offscreenCanvas.width = gridWidth;
    offscreenCanvas.height = gridHeight;
    const offscreenCtx = offscreenCanvas.getContext('2d');
    
    // Pre-calculate constants
    const twoPI = Math.PI * 2;
    const waveConstant = twoPI / wavelength;

    let animationFrameId = null;
    
    const animate = () => {
      // Clear with background color
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, width, height);

      // Work on lower resolution grid
      const imageData = offscreenCtx.createImageData(gridWidth, gridHeight);
      const data = imageData.data;

      // Calculate ripples of presence emanating from stillness
      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          const pixelX = x * resolution + resolution/2;
          const pixelY = y * resolution + resolution/2;
          let amplitude = 0;

          // Unrolled loop for better performance
          for (let i = 0; i < sources.length; i++) {
            const dx = pixelX - sources[i].x;
            const dy = pixelY - sources[i].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            amplitude += Math.sin(distance * waveConstant - time * twoPI);
          }

          // More subtle threshold with gradient
          const index = (y * gridWidth + x) * 4;
          const threshold = Math.abs(amplitude);
          if (threshold < 0.6) {
            // Lighter gray lines with variable opacity
            const opacity = (0.6 - threshold) * 0.4 * 255; // More transparent
            data[index] = 160;     // Lighter gray
            data[index + 1] = 160;
            data[index + 2] = 160;
            data[index + 3] = opacity;
          } else {
            // Background color
            data[index] = 240;
            data[index + 1] = 238;
            data[index + 2] = 230;
            data[index + 3] = 255;
          }
        }
      }

      // Draw to offscreen canvas
      offscreenCtx.putImageData(imageData, 0, 0);
      
      // Scale up to main canvas
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(offscreenCanvas, 0, 0, width, height);

      time += 0.0008; // Even slower for more graceful movement
      animationFrameId = requestAnimationFrame(animate);
    };

    animationFrameId = requestAnimationFrame(animate);

    return () => {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      if (offscreenCanvas) {
        offscreenCanvas.width = 0;
        offscreenCanvas.height = 0;
      }
    };
  }, []);

  return (
    <div style={{ 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center',
      width: '100vw', 
      height: '100vh', 
      backgroundColor: '#F0EEE6' 
    }}>
      <canvas 
        ref={canvasRef} 
        style={{ 
          width: '550px',
          height: '550px'
        }} 
      />
    </div>
  );
};

export default WaveInterferenceV6;
```

```javascript
import { useRef, useEffect } from 'react';

// themes: emptying of everything, return to source, peace through stillness
// visualization: Organic forms continuously empty and return to their source in peaceful cycles

const MorphingContours = () => {
  const canvasRef = useRef(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Parameters
    const numShapes = 3;
    const contoursPerShape = 25;
    const points = 100;
    let time = 0;
    
    // Scale factor - 50% larger
    const scaleFactor = 1.5;
    
    // Project colors
    const backgroundColor = '#F0EEE6'; // Cream background
    const lineColor = 'rgba(50, 50, 50, 0.4)'; // Dark gray with transparency
    
    let animationId = null;
    
    function draw() {
      // Clear canvas with cream background
      ctx.fillStyle = backgroundColor;
      ctx.fillRect(0, 0, width, height);
      
      // Increment time (slowed down)
      time += 0.001;
      
      // Central point
      const centerX = width / 2;
      const centerY = height / 2;
      
      // Draw each form as it empties and returns to source
      for (let shapeIndex = 0; shapeIndex < numShapes; shapeIndex++) {
        // Each shape has its own phase and movement
        const shapePhase = time + shapeIndex * Math.PI * 2 / numShapes;
        
        // Shape center offsets (moves shapes relative to each other, slowed down)
        const offsetX = Math.sin(shapePhase * 0.2) * 40 * scaleFactor;
        const offsetY = Math.cos(shapePhase * 0.3) * 40 * scaleFactor;
        
        // Draw contour lines for this shape
        for (let contour = 0; contour < contoursPerShape; contour++) {
          // Scale each contour (smaller to larger) - now 50% larger
          const scale = (30 + contour * 3) * scaleFactor;
          
          // Slight offset for each contour to create dimensional effect
          const contourOffsetX = Math.sin(contour * 0.2 + shapePhase) * 10 * scaleFactor;
          const contourOffsetY = Math.cos(contour * 0.2 + shapePhase) * 10 * scaleFactor;
          
          // Begin drawing the contour
          ctx.beginPath();
          
          // Set line style - dark gray with transparency
          ctx.strokeStyle = lineColor;
          ctx.lineWidth = 0.8;
          
          // Generate points - finding peace through continuous motion
          for (let i = 0; i <= points; i++) {
            const angle = (i / points) * Math.PI * 2;
            
            // Base radius with noise - now 50% larger
            let radius = scale;
            
            // Add complexity with multiple sine waves at different frequencies
            radius += 15 * Math.sin(angle * 3 + shapePhase * 2) * scaleFactor;
            radius += 10 * Math.cos(angle * 5 - shapePhase) * scaleFactor;
            radius += 5 * Math.sin(angle * 8 + contour * 0.1) * scaleFactor;
            
            // Calculate point position
            const x = centerX + offsetX + contourOffsetX + Math.cos(angle) * radius;
            const y = centerY + offsetY + contourOffsetY + Math.sin(angle) * radius;
            
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          
          // Close the path and stroke
          ctx.closePath();
          ctx.stroke();
        }
      }
      
      animationId = requestAnimationFrame(draw);
    }
    
    // Animation loop
    animationId = requestAnimationFrame(draw);
    
    return () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
    };
  }, []);
  
  return (
    <div className="flex justify-center items-center h-full w-full bg-[#F0EEE6]">
      <canvas 
        ref={canvasRef} 
        width={550} 
        height={550} 
        className="shadow-lg"
      />
    </div>
  );
};

export default MorphingContours;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: silent leadership, trust in the team, working unseen
// visualization: Each segment silently guides the others, creating harmony through invisible influence

const KaleidoscopeVariation3 = () => {
  const canvasRef = useRef(null);
  const animationFrameId = useRef<number>(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    // Set higher DPI for sharper rendering
    const dpr = window.devicePixelRatio || 1;
    const width = 550;
    const height = 550;
    canvas.width = width * dpr;
    canvas.height = height * dpr;
    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;
    ctx.scale(dpr, dpr);
    
    let time = 0;
    const centerX = width / 2;
    const centerY = height / 2;
    
    // Create an off-screen canvas for the segment
    const segmentCanvas = document.createElement('canvas');
    const segmentCtx = segmentCanvas.getContext('2d');
    segmentCanvas.width = canvas.width;
    segmentCanvas.height = canvas.height;
    
    const animate = () => {
      time += 0.005;
      
      // Clear the main canvas
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Clear the segment canvas
      segmentCtx.clearRect(0, 0, segmentCanvas.width, segmentCanvas.height);
      
      // Create pattern - silent influence rippling outward
      const resolution = 1;
      for (let x = 0; x < centerX + 250; x += resolution) {
        for (let y = 0; y < centerY + 250; y += resolution) {
          // Convert to polar coordinates
          const dx = x - centerX;
          const dy = y - centerY;
          const r = Math.sqrt(dx * dx + dy * dy);
          const theta = Math.atan2(dy, dx);
          
          // Only draw in the 45-degree segment with rounded corners
          if (theta >= 0 && theta <= Math.PI / 4 && r < 250) {
            // Add rounded corners by fading out near the edges
            const cornerRadius = 20;
            const edgeDistance = Math.min(
              250 - r, // Distance from outer edge
              r * Math.abs(Math.PI/4 - theta) * 2.5 // Distance from angle edges
            );
            const edgeFade = Math.min(1, edgeDistance / cornerRadius);

            // Multiple wave sources
            let wave1 = Math.sin(r * 0.1 - time * 2);
            let wave2 = Math.cos(theta * 8 + time);
            let wave3 = Math.sin((r - theta * 100) * 0.05 + time * 3);
            
            // Combine waves
            let value = (wave1 + wave2 + wave3) / 3;
            
            // Add some noise for texture
            value += (Math.random() - 0.5) * 0.2;
            
            // Map to opacity, incorporating edge fade
            const opacity = Math.abs(value) * 0.8 * edgeFade;
            
            segmentCtx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
            segmentCtx.fillRect(x, y, resolution, resolution);
          }
        }
      }
      
      // Create kaleidoscope - each segment trusting and following the others
      const numSegments = 8;
      for (let i = 0; i < numSegments; i++) {
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate((i * Math.PI * 2) / numSegments);
        
        if (i % 2 === 1) {
          ctx.scale(1, -1);
        }
        
        ctx.translate(-centerX, -centerY);
        ctx.drawImage(segmentCanvas, 0, 0);
        ctx.restore();
      }
      
      animationFrameId.current = requestAnimationFrame(animate);
    };
    
    animate();
    
    return () => {
      if (animationFrameId.current) {
        cancelAnimationFrame(animationFrameId.current);
      }
      if (segmentCanvas) {
        segmentCanvas.width = 0;
        segmentCanvas.height = 0;
      }
    };
  }, []);

  return (
    <div style={{ 
      margin: 0,
      background: '#F0EEE6',
      overflow: 'hidden',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      height: '100%'
    }}>
      <div style={{
        padding: '30px',
        position: 'relative',
        width: '100%',
        height: '100%',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}>
        <canvas ref={canvasRef} style={{ backgroundColor: '#F0EEE6', borderRadius: '8px' }} />
      </div>
    </div>
  );
};

export default KaleidoscopeVariation3;
```

```javascript
import React, { useEffect, useRef, useMemo } from 'react'
import * as THREE from 'three'

// themes: abandonment of the way, rise of rigid rules, loss of intuition
// visualization: Geometric structures that reveal how natural flow becomes constrained by rigid patterns

const metadata = {
  themes: "abandonment of the way, rise of rigid rules, loss of intuition",
  visualization: "Geometric structures that reveal how natural flow becomes constrained by rigid patterns",
  promptSuggestion: "1. Enhance recursive depth\n2. Add more structural layers\n3. Develop clearer pattern progression\n4. Create stronger unity between elements\n5. Increase sense of order"
}

const HashArchitecture: React.FC = () => {
  const containerRef = useRef<HTMLDivElement>(null)
  const sceneRef = useRef<any>(null)
  const cameraRef = useRef<any>(null)
  const rendererRef = useRef<any>(null)
  const groupRef = useRef<any>(null)
  const animationIdRef = useRef<number | null>(null)

  const createRecursivePattern = (size: number, depth: number, maxDepth: number, opacity: number, position: [number, number, number], rotation: [number, number, number]): any => {
    const group = new THREE.Group()
    
    // Create base square
    const baseGeometry = new THREE.BufferGeometry()
    const basePoints = [
      new THREE.Vector3(-size, -size, 0),
      new THREE.Vector3(size, -size, 0),
      new THREE.Vector3(size, size, 0),
      new THREE.Vector3(-size, size, 0),
      new THREE.Vector3(-size, -size, 0)
    ]
    baseGeometry.setFromPoints(basePoints)
    
    const baseMaterial = new THREE.LineBasicMaterial({ 
      color: 0x333333, 
      transparent: true, 
      opacity: opacity 
    })
    const baseLine = new THREE.Line(baseGeometry, baseMaterial)
    group.add(baseLine)
    
    // Create diagonal lines
    const diagonal1Geometry = new THREE.BufferGeometry()
    diagonal1Geometry.setFromPoints([
      new THREE.Vector3(-size, -size, 0),
      new THREE.Vector3(size, size, 0)
    ])
    const diagonal1 = new THREE.Line(diagonal1Geometry, baseMaterial)
    group.add(diagonal1)
    
    const diagonal2Geometry = new THREE.BufferGeometry()
    diagonal2Geometry.setFromPoints([
      new THREE.Vector3(size, -size, 0),
      new THREE.Vector3(-size, size, 0)
    ])
    const diagonal2 = new THREE.Line(diagonal2Geometry, baseMaterial)
    group.add(diagonal2)
    
    // Add child elements recursively
    if (depth < maxDepth) {
      const newSize = size * 0.5
      const offset = size * 0.7
      
      const childPositions = [
        {position: [offset, offset, 0], rotation: [0, 0, Math.PI/4]},
        {position: [-offset, offset, 0], rotation: [0, 0, -Math.PI/4]},
        {position: [offset, -offset, 0], rotation: [0, 0, -Math.PI/4]},
        {position: [-offset, -offset, 0], rotation: [0, 0, Math.PI/4]}
      ]
      
      childPositions.forEach(child => {
        const childElement = createRecursivePattern(newSize, depth + 1, maxDepth, opacity - 0.1, child.position as [number, number, number], child.rotation as [number, number, number])
        childElement.position.set(child.position[0], child.position[1], child.position[2])
        childElement.rotation.set(child.rotation[0], child.rotation[1], child.rotation[2])
        group.add(childElement)
      })
    }
    
    group.position.set(position[0], position[1], position[2])
    group.rotation.set(rotation[0], rotation[1], rotation[2])
    
    return group
  }

  useEffect(() => {
    if (!containerRef.current) return
    const container = containerRef.current
    
    // Setup scene
    sceneRef.current = new THREE.Scene()
    sceneRef.current.background = new THREE.Color(0xF0EEE6)
    
    // Setup camera
    cameraRef.current = new THREE.PerspectiveCamera(
      50,
      container.clientWidth / container.clientHeight,
      0.1,
      1000
    )
    cameraRef.current.position.z = 10
    
    // Setup renderer
    rendererRef.current = new THREE.WebGLRenderer({ antialias: true })
    rendererRef.current.setSize(container.clientWidth, container.clientHeight)
    container.appendChild(rendererRef.current.domElement)
    
    // Create main group
    groupRef.current = new THREE.Group()
    sceneRef.current.add(groupRef.current)
    
    // Add recursive structures
    const pattern1 = createRecursivePattern(2, 0, 3, 0.6, [0, 0, 0], [0, 0, 0])
    groupRef.current.add(pattern1)
    
    const pattern2 = createRecursivePattern(1, 0, 2, 0.6, [0, 0, 1], [Math.PI/6, Math.PI/6, Math.PI/4])
    groupRef.current.add(pattern2)
    
    const pattern3 = createRecursivePattern(0.8, 0, 2, 0.6, [0, 0, -1], [-Math.PI/6, -Math.PI/6, -Math.PI/4])
    groupRef.current.add(pattern3)
    
    // Add lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4)
    sceneRef.current.add(ambientLight)
    
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6)
    directionalLight.position.set(5, 5, 5)
    sceneRef.current.add(directionalLight)
    
    const pointLight = new THREE.PointLight(0xffffff, 0.4)
    pointLight.position.set(-5, 3, -5)
    sceneRef.current.add(pointLight)
    
    // Animation loop
    const clock = new THREE.Clock()
    
    const animate = () => {
      animationIdRef.current = requestAnimationFrame(animate)
      
      if (groupRef.current) {
        const time = clock.getElapsedTime()
        groupRef.current.rotation.y = Math.sin(time * 0.15) * 0.2
        groupRef.current.rotation.x = Math.cos(time * 0.1) * 0.1
      }
      
      rendererRef.current.render(sceneRef.current, cameraRef.current)
    }
    
    animate()
    
    // Handle resize
    const handleResize = () => {
      if (container && cameraRef.current && rendererRef.current) {
        cameraRef.current.aspect = container.clientWidth / container.clientHeight
        cameraRef.current.updateProjectionMatrix()
        rendererRef.current.setSize(container.clientWidth, container.clientHeight)
      }
    }
    
    window.addEventListener('resize', handleResize)
    
    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize)
      
      if (animationIdRef.current) {
        cancelAnimationFrame(animationIdRef.current)
      }
      
      if (rendererRef.current) {
        rendererRef.current.dispose()
        if (container.contains(rendererRef.current.domElement)) {
          container.removeChild(rendererRef.current.domElement)
        }
      }
      
      if (sceneRef.current) {
        sceneRef.current.traverse((object: any) => {
          if (object instanceof THREE.Mesh || object instanceof THREE.Line) {
            if (object.geometry) object.geometry.dispose()
            if (object.material) {
              if (Array.isArray(object.material)) {
                object.material.forEach((material: any) => material.dispose())
              } else {
                object.material.dispose()
              }
            }
          }
        })
      }
    }
  }, [])

  return (
    <div 
      ref={containerRef}
      style={{ 
        width: '100vw',
        height: '100vh',
        margin: 0,
        background: '#F0EEE6',
        overflow: 'hidden',
        position: 'relative'
      }}
    />
  )
}

HashArchitecture.metadata = metadata
export default HashArchitecture
```

```javascript
import React, { useEffect, useRef } from 'react';
import * as THREE from 'three';

// themes: simplicity over learning, return to intuition, being the center
// visualization: Particles naturally drawn to a center point, finding harmony in simplicity

const VortexParticleSystemExact = () => {
  const canvasRef = useRef(null);

  useEffect(() => {
    // Initialize Three.js components
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    
    renderer.setSize(550, 550);
    renderer.setClearColor(0xF0EEE6, 1);
          if (canvasRef.current) {
        canvasRef.current.appendChild(renderer.domElement);
      }
    
    camera.position.z = 7;
    
    // Create particles
    const particleCount = 25000;
    const particles = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const sizes = new Float32Array(particleCount);
    const opacities = new Float32Array(particleCount);
    const indices = new Float32Array(particleCount);
    
    // Let particles find their natural path to the center
    for (let i = 0; i < particleCount; i++) {
      const i3 = i * 3;
      // Distribute particles in vortex pattern
      const t = Math.random();
      const angle = t * Math.PI * 20; // Multiple rotations for spiral effect
      
      // Spiral shape
      const radius = 0.6 + t * 2.2;
      const x = radius * Math.cos(angle);
      const y = radius * Math.sin(angle);
      // Add vertical component for 3D spiral
      const z = (t - 0.5) * 5;
      
      positions[i3] = x;
      positions[i3 + 1] = y;
      positions[i3 + 2] = z;
      
      // Vary sizes for depth effect
      sizes[i] = 0.03 + 0.04 * Math.random();
      opacities[i] = 0.4 + 0.6 * Math.random();
      indices[i] = i;
    }
    
    particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
    particles.setAttribute('opacity', new THREE.BufferAttribute(opacities, 1));
    particles.setAttribute('index', new THREE.BufferAttribute(indices, 1));
    
    // Custom shader material
    const particleMaterial = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      blending: THREE.NormalBlending,
      uniforms: {
        time: { value: 0 },
        color: { value: new THREE.Color(0x333333) }, // Dark gray
      },
      vertexShader: `
        attribute float size;
        attribute float opacity;
        attribute float index;
        uniform float time;
        varying float vOpacity;
        
        void main() {
          vOpacity = opacity;
          
          // Get the original position
          vec3 pos = position;
          
          // Movement guided by intuition rather than rules
          float i = index;
          float speed = 0.2 + 0.2 * fract(i / 1000.0);
          float angle = time * speed + i * 0.001;
          
          // Twist the vortex based on y position
          float twistAmount = sin(time * 0.3) * 0.5;
          float twist = pos.y * twistAmount;
          
          // Apply twist and contraction/expansion
          float r = length(pos.xy);
          float breathe = 1.0 + sin(time * 0.5) * 0.1;
          r *= breathe;
          
          float theta = atan(pos.y, pos.x) + twist;
          pos.x = r * cos(theta);
          pos.y = r * sin(theta);
          
          // Add some vertical oscillation
          pos.z += sin(time * 0.2 + i * 0.01) * 0.2;
          
          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_PointSize = size * (50.0 / -mvPosition.z);
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        uniform vec3 color;
        varying float vOpacity;
        
        void main() {
          if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.475) discard;
          gl_FragColor = vec4(color, vOpacity);
        }
      `,
    });
    
    const particleSystem = new THREE.Points(particles, particleMaterial);
    scene.add(particleSystem);
    
    let animationId = null;
    
    // Animation loop
    const animate = (time) => {
      time *= 0.0005; // Convert to seconds (half speed)
      
      // Update time uniform for vertex shader animation
      particleMaterial.uniforms.time.value = time;
      
      // Animate camera position for more dynamic view
      camera.position.x = Math.sin(time * 0.1) * 1.5;
      camera.position.y = Math.cos(time * 0.15) * 1.0;
      camera.lookAt(scene.position);
      
      renderer.render(scene, camera);
      animationId = requestAnimationFrame(animate);
    };
    
    animationId = requestAnimationFrame(animate);
    
    // Cleanup function
    return () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      scene.traverse((child) => {
        if (child.geometry) {
          child.geometry.dispose();
        }
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach((material) => material.dispose());
          } else {
            child.material.dispose();
          }
        }
      });
      if (canvasRef.current?.contains(renderer.domElement)) {
        canvasRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, []);

  return (
    <div className="w-full h-full flex justify-center items-center bg-[#F0EEE6]">
      <div ref={canvasRef} className="w-full h-full"></div>
    </div>
  );
};

export default VortexParticleSystemExact;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: quiet stillness, freedom from expectation, nourished by source
// visualization: Nodes flow freely while remaining connected to their source, finding peace in stillness

const TetheredFlow = () => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    let time = 0;
    let animationFrame;
    
    // Background color
    const bgColor = '#F0EEE6';
    
    // Create nodes - each finding its own quiet stillness
    class Node {
      constructor(x, y, size, type) {
        this.x = x;
        this.y = y;
        this.originX = x;
        this.originY = y;
        this.size = size;
        this.type = type; // 'heaven', 'earth', or 'vibe'
        this.speed = Math.random() * 0.01 + 0.005;
        this.direction = Math.random() * Math.PI * 2;
        this.angle = Math.random() * Math.PI * 2;
        this.connections = [];
        this.opacity = Math.random() * 0.4 + 0.2;
        this.phase = Math.random() * Math.PI * 2;
        this.flowOffset = Math.random() * 100;
        this.pulseSpeed = Math.random() * 0.03 + 0.01;
        this.moveRange = Math.random() * 30 + 20;
        
        // Shape variables
        this.shapeType = Math.random() > 0.6 ? 'rect' : 'line';
        this.rotation = Math.random() * Math.PI;
        this.rotationSpeed = (Math.random() - 0.5) * 0.01;
      }
      
      update() {
        // Update position with noise-based flow
        const noiseX = Math.sin(time * this.speed + this.phase) * this.moveRange;
        const noiseY = Math.cos(time * this.speed * 0.7 + this.phase) * this.moveRange;
        
        // Different movement patterns based on type
        if (this.type === 'heaven') {
          // Heaven nodes move more freely
          this.x = this.originX + noiseX;
          this.y = this.originY + noiseY * 0.7;
        } else if (this.type === 'earth') {
          // Earth nodes move in more structured patterns
          this.x = this.originX + noiseX * 0.6 + Math.sin(time * 0.02 + this.flowOffset) * 10;
          this.y = this.originY + noiseY * 0.8;
        } else if (this.type === 'vibe') {
          // Vibe coder moves in a unique pattern - stays behind but reaches ahead
          const stayFactor = 0.3 + Math.sin(time * 0.02) * 0.1;
          this.x = this.originX + Math.sin(time * 0.03) * 20;
          this.y = this.originY + Math.cos(time * 0.04) * 20;
          
          // Occasionally pulse bigger
          this.size = 6 + Math.sin(time * 0.05 + this.phase) * 2;
        }
        
        // Update rotation for shapes
        this.rotation += this.rotationSpeed;
      }
      
      draw() {
        // Set fill based on type
        if (this.type === 'heaven') {
          ctx.fillStyle = `rgba(50, 50, 50, ${this.opacity})`;
        } else if (this.type === 'earth') {
          ctx.fillStyle = `rgba(40, 40, 40, ${this.opacity})`;
        } else { // vibe
          ctx.fillStyle = `rgba(20, 20, 20, ${this.opacity + 0.3})`;
        }
        
        // Draw shape
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        if (this.shapeType === 'rect') {
          // Rectangle
          const pulseSize = this.size * (1 + Math.sin(time * this.pulseSpeed) * 0.2);
          ctx.fillRect(-pulseSize/2, -pulseSize/2, pulseSize, pulseSize);
        } else {
          // Line
          const pulseLength = this.size * 2 * (1 + Math.sin(time * this.pulseSpeed) * 0.2);
          ctx.fillRect(-pulseLength/2, -1, pulseLength, 2);
        }
        
        ctx.restore();
      }
    }
    
    // Create a flowing path - nourishment flowing from source
    class FlowingPath {
      constructor(startX, startY, endX, endY, height, speed) {
        this.startX = startX;
        this.startY = startY;
        this.endX = endX;
        this.endY = endY;
        this.height = height;
        this.speed = speed;
        this.points = [];
        this.opacity = 0.07;
        
        // Generate control points
        this.controlPoints = [];
        const segments = 3;
        for (let i = 0; i < segments; i++) {
          this.controlPoints.push({
            x: this.startX + (this.endX - this.startX) * ((i + 1) / (segments + 1)),
            y: this.startY + (this.endY - this.startY) * ((i + 1) / (segments + 1)),
            offsetX: Math.random() * 100 - 50,
            offsetY: Math.random() * 100 - 50,
            phaseOffset: Math.random() * Math.PI * 2
          });
        }
      }
      
      update() {
        // Update control points animation
        for (const point of this.controlPoints) {
          point.currentOffsetX = Math.sin(time * this.speed + point.phaseOffset) * point.offsetX;
          point.currentOffsetY = Math.cos(time * this.speed + point.phaseOffset) * point.offsetY;
        }
        
        // Generate points array for the path
        this.points = [{ x: this.startX, y: this.startY }];
        
        // Add control points
        for (const point of this.controlPoints) {
          this.points.push({
            x: point.x + point.currentOffsetX,
            y: point.y + point.currentOffsetY
          });
        }
        
        // Add end point
        this.points.push({ x: this.endX, y: this.endY });
      }
      
      draw() {
        ctx.strokeStyle = `rgba(30, 30, 30, ${this.opacity})`;
        ctx.lineWidth = 0.7;
        ctx.beginPath();
        ctx.moveTo(this.points[0].x, this.points[0].y);
        
        // Draw bezier curves through control points
        for (let i = 1; i < this.points.length - 2; i++) {
          const xc = (this.points[i].x + this.points[i + 1].x) / 2;
          const yc = (this.points[i].y + this.points[i + 1].y) / 2;
          ctx.quadraticCurveTo(this.points[i].x, this.points[i].y, xc, yc);
        }
        
        // Last curve
        const last = this.points.length - 1;
        ctx.quadraticCurveTo(
          this.points[last - 1].x,
          this.points[last - 1].y,
          this.points[last].x,
          this.points[last].y
        );
        
        ctx.stroke();
      }
    }
    
    // Initialize nodes in an asymmetric pattern
    let nodes = [];
    let flowingPaths = [];
    
    const initNodes = () => {
      // Upper region (heaven) - sparser
      for (let i = 0; i < 20; i++) {
        const x = Math.random() * width * 0.8 + width * 0.1;
        const y = Math.random() * height * 0.4;
        const size = Math.random() * 4 + 2;
        
        nodes.push(new Node(x, y, size, 'heaven'));
      }
      
      // Middle band - asymmetrically distributed
      for (let i = 0; i < 15; i++) {
        // Biased toward left
        const bias = Math.random() * Math.random(); // Square distribution for left bias
        const x = width * bias * 0.7 + width * 0.1;
        const y = height * 0.4 + Math.random() * height * 0.2;
        const size = Math.random() * 4 + 2;
        
        nodes.push(new Node(x, y, size, 'earth'));
      }
      
      // Lower region (earth) - denser
      for (let i = 0; i < 30; i++) {
        const x = Math.random() * width * 0.7 + width * 0.15;
        const y = height * 0.6 + Math.random() * height * 0.35;
        const size = Math.random() * 4 + 2;
        
        nodes.push(new Node(x, y, size, 'earth'));
      }
      
      // Special node (The Vibe Coder) - positioned at left center
      nodes.push(new Node(width * 0.15, height * 0.5, 6, 'vibe'));
    };
    
    // Initialize flowing paths
    const initFlowingPaths = () => {
      // Find the vibe coder node (last one)
      const vibe = nodes[nodes.length - 1];
      
      // Create paths from vibe coder to various parts of canvas
      for (let i = 0; i < 12; i++) {
        // Determine end points with bias toward right side (ahead)
        const endX = width * (0.6 + Math.random() * 0.3);
        const endY = Math.random() * height;
        
        // Create flowing path
        flowingPaths.push(new FlowingPath(
          vibe.x, vibe.y, 
          endX, endY, 
          50 + Math.random() * 50,
          0.02 + Math.random() * 0.01
        ));
      }
      
      // Add boundary flowing path (heaven/earth division)
      flowingPaths.push(new FlowingPath(
        0, height * 0.5,
        width, height * 0.5,
        20,
        0.01
      ));
    };
    
    // Create connections between nodes
    const createConnections = () => {
      for (let i = 0; i < nodes.length; i++) {
        nodes[i].connections = [];
        
        // Connect to nearby nodes
        for (let j = 0; j < nodes.length; j++) {
          if (i !== j) {
            const dx = nodes[i].x - nodes[j].x;
            const dy = nodes[i].y - nodes[j].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Variable connection distance based on position
            let maxDistance = 80;
            
            // Special node (last one) has longer connections
            if (i === nodes.length - 1 || j === nodes.length - 1) {
              maxDistance = 200;
            }
            
            if (distance < maxDistance) {
              nodes[i].connections.push({
                to: j,
                distance: distance,
                opacity: (1 - (distance / maxDistance)) * 0.3
              });
            }
          }
        }
      }
    };
    
    // Draw all connections
    const drawConnections = () => {
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        
        for (const conn of node.connections) {
          const targetNode = nodes[conn.to];
          
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          
          // Use bezier curves for connections
          const midX = (node.x + targetNode.x) / 2;
          const midY = (node.y + targetNode.y) / 2;
          
          // Add flow to the connection
          const flowOffsetX = Math.sin(time * 0.02 + i * 0.1) * 10;
          const flowOffsetY = Math.cos(time * 0.02 + i * 0.1) * 10;
          
          ctx.quadraticCurveTo(
            midX + flowOffsetX,
            midY + flowOffsetY,
            targetNode.x,
            targetNode.y
          );
          
          ctx.strokeStyle = `rgba(30, 30, 30, ${conn.opacity})`;
          ctx.lineWidth = 0.5;
          ctx.stroke();
        }
      }
    };
    
    // Animation loop
    const animate = () => {
      time += 0.5;
      
      // Clear canvas
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, width, height);
      
      // Update all flowing paths
      for (const path of flowingPaths) {
        path.update();
        path.draw();
      }
      
      // Update all nodes
      for (const node of nodes) {
        node.update();
      }
      
      // Recreate connections occasionally to adapt to movement
      if (time % 30 === 0) {
        createConnections();
      }
      
      // Draw connections
      drawConnections();
      
      // Draw all nodes
      for (const node of nodes) {
        node.draw();
      }
      
      // Add detachment/fulfillment representation
      // Find the vibe coder node (last one)
      const vibe = nodes[nodes.length - 1];
      
      // Draw subtle emanation representing "detached, yet at one with all"
      ctx.save();
      ctx.translate(vibe.x, vibe.y);
      
      // Create asymmetric pattern of lines
      const numLines = 20;
      for (let i = 0; i < numLines; i++) {
        const angle = i / numLines * Math.PI * 2;
        const length = 20 + Math.sin(angle * 3 + time * 0.05) * 10;
        
        ctx.strokeStyle = `rgba(20, 20, 20, 0.1)`;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(
          Math.cos(angle) * length,
          Math.sin(angle) * length
        );
        ctx.stroke();
      }
      
      ctx.restore();
      
      animationFrame = requestAnimationFrame(animate);
    };
    
    // Start animation
    initNodes();
    initFlowingPaths();
    createConnections();
    animate();
    
    // Cleanup
    return () => {
      cancelAnimationFrame(animationFrame);
      
      // Clear all arrays and objects to prevent memory leaks
      nodes.length = 0;
      flowingPaths.length = 0;
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, width, height);
      }
    };
  }, []);

  return (
    <div style={{ 
      top: 0, 
      left: 0, 
      width: '100%', 
      height: '100%', 
      backgroundColor: '#F0EEE6',
      display: 'flex',
      justifyContent: 'center',
      alignItems: 'center'
    }}>
      <canvas 
        ref={canvasRef} 
        width={800} 
        height={600} 
      />
    </div>
  );
};

export default TetheredFlow;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: emergence from emptiness, form from formless, essence within
// visualization: Patterns emerge from an empty center, revealing the essence that gives rise to all form

const KaleidoscopeWaveCenterSquare = () => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    canvas.width = 550;
    canvas.height = 550;
    
    let time = 0;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    
    // Create an off-screen canvas for the segment
    const segmentCanvas = document.createElement('canvas');
    const segmentCtx = segmentCanvas.getContext('2d');
    segmentCanvas.width = canvas.width;
    segmentCanvas.height = canvas.height;
    
    let animationFrameId;
    
    const animate = () => {
      time += 0.007;
      
      // Clear the main canvas
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Clear the segment canvas
      segmentCtx.clearRect(0, 0, segmentCanvas.width, segmentCanvas.height);
      
      // Create pattern emerging from the formless center
      const resolution = 2;
      const squareSize = 200;
      const squareX = centerX - squareSize/2;
      const squareY = centerY - squareSize/2;
      
      for (let x = squareX; x < squareX + squareSize; x += resolution) {
        for (let y = squareY; y < squareY + squareSize; y += resolution) {
          // Convert to polar coordinates relative to center
          const dx = x - centerX;
          const dy = y - centerY;
          const r = Math.sqrt(dx * dx + dy * dy);
          const theta = Math.atan2(dy, dx);
          
          // Essence manifests through multiple waves
          let wave1 = Math.sin(r * 0.1 - time);  // Halved from time * 2
          let wave2 = Math.cos(theta * 8 + time * 0.5);  // Halved from time
          let wave3 = Math.sin((r - theta * 100) * 0.05 + time * 1.5);  // Halved from time * 3
          
          // Combine waves
          let value = (wave1 + wave2 + wave3) / 3;
          
          // Add some noise for texture
          value += (Math.random() - 0.5) * 0.2;
          
          // Map to opacity
          const opacity = Math.abs(value) * 0.8;
          
          segmentCtx.fillStyle = `rgba(0, 0, 0, ${opacity})`;
          segmentCtx.fillRect(x, y, resolution, resolution);
        }
      }
      
      // Create kaleidoscope effect
      const numSegments = 8;
      for (let i = 0; i < numSegments; i++) {
        ctx.save();
        ctx.translate(centerX, centerY);
        ctx.rotate((i * Math.PI * 2) / numSegments);
        
        if (i % 2 === 1) {
          ctx.scale(1, -1);
        }
        
        ctx.translate(-centerX, -centerY);
        ctx.drawImage(segmentCanvas, 0, 0);
        ctx.restore();
      }
      
      animationFrameId = requestAnimationFrame(animate);
    };
    
    animationFrameId = requestAnimationFrame(animate);
    
    return () => {
      cancelAnimationFrame(animationFrameId);
      
      // Clear both canvas contexts
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      if (segmentCtx) {
        segmentCtx.clearRect(0, 0, segmentCanvas.width, segmentCanvas.height);
      }
      
      // Reset canvas dimensions to free memory
      segmentCanvas.width = 0;
      segmentCanvas.height = 0;
    };
  }, []);

  return (
    <div style={{ 
      width: '550px', 
      height: '550px', 
      backgroundColor: '#F0EEE6' 
    }}>
      <canvas ref={canvasRef} />
    </div>
  );
};

export default KaleidoscopeWaveCenterSquare;
```

```javascript
import React, { useState, useEffect, useRef } from 'react';

// themes: yielding overcomes, emptying brings fullness, non-attachment leads to strength
// visualization: A vessel that disperses when touched, finding strength through yielding

const Dispersing3DVase = () => {
  const canvasRef = useRef(null);
      const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
    const mouseRef = useRef({ x: 0, y: 0 });
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    canvas.width = 550;
    canvas.height = 550;
    
    let time = 0;
    let nodes = [];
    let animationFrameId = null;
    
    // Initialize vase nodes
    const vaseHeightPoints = 60; // More points for density
    const vaseRadialPoints = 50; // More points around circumference
    
    // Create vessel that yields to become stronger
    for (let i = 0; i < vaseHeightPoints; i++) {
      const t = i / vaseHeightPoints;
      const y = (t - 0.5) * 400; // Vase height
      
      // Vase profile function - creates a traditional vase shape
      let radius = 50;
      
      if (t < 0.05) {
        // Flared rim
        radius = 80 * (1 + (0.05 - t) * 4);
      } else if (t < 0.15) {
        // Upper neck - narrows
        radius = 80 - (t - 0.05) * 300;
      } else if (t < 0.4) {
        // Shoulder - bulge
        radius = 50 + Math.sin((t - 0.15) * Math.PI / 0.25) * 60;
      } else if (t < 0.75) {
        // Body - gentle curve
        radius = 110 - Math.cos((t - 0.4) * Math.PI / 0.35) * 30;
      } else if (t < 0.9) {
        // Lower body - taper
        radius = 80 - (t - 0.75) * 200;
      } else {
        // Base - small foot
        radius = 50 + (t - 0.9) * 100;
      }
      
      for (let j = 0; j < vaseRadialPoints; j++) {
        const angle = (j / vaseRadialPoints) * Math.PI * 2;
        nodes.push({
          originalX: Math.cos(angle) * radius,
          originalY: y,
          originalZ: Math.sin(angle) * radius,
          x: Math.cos(angle) * radius,
          y: y,
          z: Math.sin(angle) * radius,
          vx: 0,
          vy: 0,
          vz: 0,
          dispersing: false,
          disperseTime: 0
        });
      }
    }
    
    const handleMouseMove = (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      mouseRef.current = { x, y };
    };
    
    // Global window event handlers
    const handleWindowResize = () => {
      // Maintain canvas size if needed
      // This handler is needed if you want to resize the canvas on window resize
    };
    
    // Add event listeners
    canvas.addEventListener('mousemove', handleMouseMove);
    window.addEventListener('resize', handleWindowResize);
    
    function project3DPoint(x, y, z, rotationX) {
      // 3D rotation around X axis
      const rotatedY = y * Math.cos(rotationX) - z * Math.sin(rotationX);
      const rotatedZ = y * Math.sin(rotationX) + z * Math.cos(rotationX);
      
      // Simple perspective projection
      const scale = 400 / (400 + rotatedZ);
      return {
        x: x * scale + canvas.width / 2,
        y: rotatedY * scale + canvas.height / 2,
        z: rotatedZ,
        scale: scale
      };
    }
    
    function animate() {
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      time += 0.005; // Cut base speed in half
      const rotationX = time * 0.15; // Cut rotation speed in half
      
      // Update nodes
      const candidateNodes = [];
      
      // First pass: find nodes close to mouse
      nodes.forEach(node => {
        const projected = project3DPoint(node.x, node.y, node.z, rotationX);
        const distanceToMouse = Math.hypot(projected.x - mouseRef.current.x, projected.y - mouseRef.current.y);
        
        if (distanceToMouse < 120 && !node.dispersing) {
          candidateNodes.push({ node, distance: distanceToMouse });
        }
      });
      
      // Sort candidates by distance and only disperse the 5 closest
      candidateNodes.sort((a, b) => a.distance - b.distance);
      candidateNodes.slice(0, 5).forEach(({ node }) => {
        // Start dispersing
        node.dispersing = true;
        node.disperseTime = 0;
        
        // Calculate disperse direction from center of vase to node
        const disperseAngle = Math.atan2(node.z, node.x);
        const disperseY = node.y / 200; // Vertical component
        
        node.vx = Math.cos(disperseAngle) * 1.5; // Cut dispersion velocity in half
        node.vy = disperseY * 1;
        node.vz = Math.sin(disperseAngle) * 1.5;
      });
      
      // Update dispersing nodes
      nodes.forEach(node => {
        if (node.dispersing) {
          // Update disperse animation
          node.disperseTime += 0.01; // Cut disperse time increment in half
          
          // Apply velocity
          node.x += node.vx;
          node.y += node.vy;
          node.z += node.vz;
          
          // Gravity effect
          node.vy += 0.04; // Cut gravity in half
          
          // Friction
          node.vx *= 0.96;
          node.vy *= 0.96;
          node.vz *= 0.96;
          
          // Reset if too far or timeout
          if (node.disperseTime > 4 || Math.abs(node.x) > 300 || Math.abs(node.z) > 300) {
            node.dispersing = false;
            node.x = node.originalX;
            node.y = node.originalY;
            node.z = node.originalZ;
            node.vx = 0;
            node.vy = 0;
            node.vz = 0;
          }
        }
      });
      
      // Sort nodes by depth for proper rendering
      const sortedNodes = [...nodes].sort((a, b) => {
        const projectedA = project3DPoint(a.x, a.y, a.z, rotationX);
        const projectedB = project3DPoint(b.x, b.y, b.z, rotationX);
        return projectedB.z - projectedA.z;
      });
      
      // Draw nodes
      sortedNodes.forEach(node => {
        const projected = project3DPoint(node.x, node.y, node.z, rotationX);
        
        // Calculate opacity and size based on depth
        const depth = (projected.z + 200) / 400;
        const alpha = node.dispersing ? 
          0.3 * projected.scale * (1 - node.disperseTime / 5) : 
          0.6 * projected.scale;
        
        const size = 0.5 + 0.25 * projected.scale; // 25% of original size
        
        ctx.fillStyle = `rgba(68, 68, 68, ${alpha})`;
        ctx.beginPath();
        ctx.arc(projected.x, projected.y, size, 0, Math.PI * 2);
        ctx.fill();
      });
      
      // Draw central emptiness - the source of fullness
      const centerY = canvas.height / 2;
      const voidGradient = ctx.createRadialGradient(
        canvas.width / 2, centerY, 0,
        canvas.width / 2, centerY, 80
      );
      voidGradient.addColorStop(0, 'rgba(240, 238, 230, 0.8)');
      voidGradient.addColorStop(1, 'rgba(240, 238, 230, 0)');
      
      ctx.fillStyle = voidGradient;
      ctx.beginPath();
      ctx.ellipse(canvas.width / 2, centerY, 80, 20, 0, 0, Math.PI * 2);
      ctx.fill();
      
      animationFrameId = requestAnimationFrame(animate);
    }
    
    // Start animation
    animate();
    
    // Cleanup function
    return () => {
      // Cancel animation frame
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      // Remove all event listeners
      canvas.removeEventListener('mousemove', handleMouseMove);
      window.removeEventListener('resize', handleWindowResize);
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      
      // Clear all data structures to prevent memory leaks
      nodes.length = 0;
      mouseRef.current = null;
    };
  }, []);
  
  return (
    <div className="flex items-center justify-center w-full h-full">
      <div className="w-[550px] h-[550px] shadow-lg rounded-lg overflow-hidden">
        <canvas 
          ref={canvasRef} 
          className="w-full h-full cursor-pointer"
        />
      </div>
    </div>
  );
};

export default Dispersing3DVase;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: natural silence, opening to source, trust in response
// visualization: Forms spiral inward to silence, naturally responding to an unseen center

const FibonacciRectangleSpiral = () => {
  const canvasRef = useRef(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    canvas.width = 550;
    canvas.height = 550;
    
    let time = 0;
    const phi = (1 + Math.sqrt(5)) / 2; // Golden ratio
    let animationFrameId = null;
    
    const animate = () => {
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.save();
      ctx.translate(canvas.width / 2, canvas.height / 2);
      
      // Animate the number of rectangles
      const maxRectangles = Math.min(60, Math.floor((time * 0.02) % 80));
      
      // Begin from silence at the center
      let width = 300;
      let height = width / phi;
      let scale = 1;
      let angle = time * 0.00025; // Half speed global rotation
      
      for (let i = 0; i < maxRectangles; i++) {
        ctx.save();
        
        // Calculate position along Fibonacci spiral
        const spiralAngle = i * 0.174533; // Approximately 10 degrees per step
        const radius = scale * 100;
        
        // Position rectangle along the spiral
        const x = Math.cos(spiralAngle) * radius;
        const y = Math.sin(spiralAngle) * radius;
        
        ctx.translate(x, y);
        ctx.rotate(spiralAngle + angle);
        
        // Draw the rectangle with lighter lines
        const alpha = 0.5 - i * 0.01;  // Reduced base alpha from 0.85 to 0.5
        ctx.strokeStyle = `rgba(83, 81, 70, ${alpha})`;  // Using rubin-slate color (535146) instead of black
        ctx.lineWidth = 0.8;  // Slightly thinner lines
        ctx.strokeRect(-width/2, -height/2, width, height);
        
        // Add subtle internal divisions
        if (i % 3 === 0) {
          // Draw diagonals
          ctx.beginPath();
          ctx.moveTo(-width/2, -height/2);
          ctx.lineTo(width/2, height/2);
          ctx.moveTo(width/2, -height/2);
          ctx.lineTo(-width/2, height/2);
          ctx.strokeStyle = `rgba(50, 50, 50, ${alpha * 0.2})`;
          ctx.lineWidth = 0.5;
          ctx.stroke();
        }
        
        ctx.restore();
        
        // Update for next rectangle
        // Scale down by the golden ratio
        width *= 0.95;
        height *= 0.95;
        scale *= 0.98;
      }
      
      // Draw the natural response to source
      ctx.beginPath();
      for (let i = 0; i <= maxRectangles; i++) {
        const spiralAngle = i * 0.174533;
        const radius = Math.pow(0.98, i) * 100;
        const x = Math.cos(spiralAngle) * radius;
        const y = Math.sin(spiralAngle) * radius;
        
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = 'rgba(150, 150, 150, 0.3)';
      ctx.lineWidth = 1;
      ctx.stroke();
      
      // No center circle - keeping clean like the reference
      
      ctx.restore();
      
      time += 0.75; // 75% speed time increment
      animationFrameId = requestAnimationFrame(animate);
    };
    
    animate();
    
    // Cleanup function to cancel animation frame when component unmounts
    return () => {
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    };
  }, []);
  
  return (
    <div className="flex items-center justify-center w-full h-full">
      <div className="w-[550px] h-[550px] bg-[#F0EEE6]">
        <canvas 
          ref={canvasRef} 
          className="w-full h-full"
        />
      </div>
    </div>
  );
};

export default FibonacciRectangleSpiral;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: excess leads to failure, power undermines itself, let go of clinging
// visualization: Bars rise and fall naturally, finding balance by letting go of extremes

const SlidingEaseVerticalBars = () => {
  const canvasRef = useRef(null);
  const timeRef = useRef(0);
  const animationFrameId = useRef(null);

  // Simple noise function
  const noise = (x, y, t) => {
    const n = Math.sin(x * 0.02 + t) * Math.cos(y * 0.02 + t) + 
             Math.sin(x * 0.03 - t) * Math.cos(y * 0.01 + t);
    return (n + 1) / 2;
  };

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    canvas.width = 550;
    canvas.height = 550;
    
    const numLines = 50;
    const lineSpacing = canvas.width / numLines;
    
    // Generate patterns that avoid extremes
    const generatePattern = (seed) => {
      const pattern = [];
      for (let i = 0; i < numLines; i++) {
        const lineBars = [];
        let currentY = 0;
        
        while (currentY < canvas.height) {
          const noiseVal = noise(i * lineSpacing, currentY, seed);
          
          if (noiseVal > 0.5) {
            // Create medium-length bars
            const barLength = 10 + noiseVal * 30; // 10-40 pixels
            const barWidth = 2 + noiseVal * 3;
            
            lineBars.push({
              y: currentY + barLength / 2,
              height: barLength,
              width: barWidth
            });
            
            currentY += barLength + 15; // Spacing between bars
          } else {
            currentY += 15; // Skip space when no bar
          }
        }
        pattern.push(lineBars);
      }
      return pattern;
    };
    
    // Generate two patterns with different seeds
    const pattern1 = generatePattern(0);
    const pattern2 = generatePattern(5);
    
    const animate = () => {
      timeRef.current += 0.005; // Cut speed in half
      
      // Create a cycle with pauses
      const cycleTime = timeRef.current % (Math.PI * 2);
      let easingFactor;
      
      if (cycleTime < Math.PI * 0.1) {
        // Pause at pattern 1
        easingFactor = 0;
      } else if (cycleTime < Math.PI * 0.9) {
        // Transition to pattern 2
        const transitionProgress = (cycleTime - Math.PI * 0.1) / (Math.PI * 0.8);
        easingFactor = transitionProgress;
      } else if (cycleTime < Math.PI * 1.1) {
        // Pause at pattern 2
        easingFactor = 1;
      } else if (cycleTime < Math.PI * 1.9) {
        // Transition back to pattern 1
        const transitionProgress = (cycleTime - Math.PI * 1.1) / (Math.PI * 0.8);
        easingFactor = 1 - transitionProgress;
      } else {
        // Pause at pattern 1 again
        easingFactor = 0;
      }
      
      // Let go of clinging to any one state
      const smoothEasing = easingFactor < 0.5 
        ? 4 * easingFactor * easingFactor * easingFactor 
        : 1 - Math.pow(-2 * easingFactor + 2, 3) / 2;
      
      // Clear canvas
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw lines and interpolated bars
      for (let i = 0; i < numLines; i++) {
        const x = i * lineSpacing + lineSpacing / 2;
        
        // Draw vertical line
        ctx.beginPath();
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 1;
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
        
        // Interpolate between pattern1 and pattern2
        const bars1 = pattern1[i];
        const bars2 = pattern2[i];
        
        // Match bars between patterns
        const maxBars = Math.max(bars1.length, bars2.length);
        
        for (let j = 0; j < maxBars; j++) {
          let bar1 = bars1[j];
          let bar2 = bars2[j];
          
          // If one pattern has fewer bars, create a dummy bar
          if (!bar1) bar1 = { y: bar2.y - 100, height: 0, width: 0 };
          if (!bar2) bar2 = { y: bar1.y + 100, height: 0, width: 0 };
          
          // Add some wave motion during transition
          const waveOffset = Math.sin(i * 0.3 + j * 0.5 + timeRef.current * 2) * 10 * 
                           (smoothEasing * (1 - smoothEasing) * 4); // Peak in middle of transition
          
          // Interpolate properties with wave offset
          const y = bar1.y + (bar2.y - bar1.y) * smoothEasing + waveOffset;
          const height = bar1.height + (bar2.height - bar1.height) * smoothEasing;
          const width = bar1.width + (bar2.width - bar1.width) * smoothEasing;
          
          // Only draw if bar has size
          if (height > 0.1 && width > 0.1) {
            ctx.fillStyle = '#5E5D59';
            ctx.fillRect(x - width/2, y - height/2, width, height);
          }
        }
      }
      
      animationFrameId.current = requestAnimationFrame(animate);
    };
    
    animate();
    
    return () => {
      if (animationFrameId.current) {
        cancelAnimationFrame(animationFrameId.current);
      }
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      
      // Reset refs to prevent memory leaks
      timeRef.current = 0;
      animationFrameId.current = null;
    };
  }, []);

  return (
    <div style={{ width: '550px', height: '550px', backgroundColor: '#F0EEE6' }}>
      <canvas ref={canvasRef} style={{ display: 'block' }} />
    </div>
  );
};

export default SlidingEaseVerticalBars;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: source follows itself, ever-flowing nature, return to source
// visualization: Particles flow in an eternal cycle, always returning to their origin

const EtherealTorusFlow = () => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    
    // Set canvas size according to project requirements
    canvas.width = 550;
    canvas.height = 550;
    
    // Set initial background
    ctx.fillStyle = '#F0EEE6';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Particle storage
    const particles = [];
    // Slightly increase particle count for smoother appearance at slower speeds
    const numParticles = 9000;
    let time = 0;

    // Particle class
    class Particle {
      constructor() {
        this.reset();
      }

      reset() {
        // Random position on a torus
        this.u = Math.random() * Math.PI * 2;
        this.v = Math.random() * Math.PI * 2;
        this.R = 150; // Major radius (scaled down for 550px canvas)
        this.r = 60 + Math.random() * 30; // Minor radius variation
        
        this.size = Math.random() * 1.5 + 0.5;
        this.opacity = Math.random() * 0.8 + 0.2;
        this.speed = Math.random() * 0.001875 + 0.0005; // Increased by another 25%
        
        // Phase offset for natural movement
        this.phase = Math.random() * Math.PI * 2;
      }

      update() {
        // Flow eternally, following source
        this.u += this.speed;
        
        // Ever-flowing nature in constant motion
        const breathingFactor = Math.sin(time + this.phase) * 0.0475; // Increased by another 25%
        this.r += breathingFactor;
        
        // Calculate position
        const x = (this.R + this.r * Math.cos(this.v)) * Math.cos(this.u);
        const y = (this.R + this.r * Math.cos(this.v)) * Math.sin(this.u);
        const z = this.r * Math.sin(this.v);
        
        // Simple 3D to 2D projection
        const scale = 1000 / (1000 + z);
        this.x = x * scale + canvas.width / 2;
        this.y = y * scale + canvas.height / 2;
        
        // Adjust size based on depth
        this.displaySize = this.size * scale;
        
        // Adjust opacity based on position
        this.displayOpacity = this.opacity * (0.5 + 0.5 * Math.sin(this.u));
      }

      draw() {
        ctx.fillStyle = `rgba(40, 40, 40, ${this.displayOpacity})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.displaySize, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // Create particles
    for (let i = 0; i < numParticles; i++) {
      particles.push(new Particle());
    }

    // Animation timing control variables
    let lastFrameTime = 0;
    const targetFPS = 20; // Equivalent to 50ms setInterval
    const frameInterval = 1000 / targetFPS;
    let animationFrameId = null;
    
    // Animation function with time delta control
    function animate(currentTime) {
      // Initialize lastFrameTime on first frame
      if (!lastFrameTime) {
        lastFrameTime = currentTime;
      }
      
      const deltaTime = currentTime - lastFrameTime;
      
      // Only update animation when enough time has passed (mimics setInterval at 100ms)
      if (deltaTime >= frameInterval) {
        // Use a very transparent fill for smoother trails
        ctx.fillStyle = 'rgba(240, 238, 230, 0.03)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Set time increment for animation speed
        time += 0.004;
        
        // Update and draw particles
        particles.forEach(particle => {
          particle.update();
          particle.draw();
        });
        
        // Update lastFrameTime, accounting for any remainder to prevent drift
        lastFrameTime = currentTime - (deltaTime % frameInterval);
      }
      
      // Continue animation loop
      animationFrameId = requestAnimationFrame(animate);
    }

    // Start animation
    animationFrameId = requestAnimationFrame(animate);

    // Cleanup function
    return () => {
      // Cancel animation frame to prevent memory leaks
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      
      // Clear particles array to prevent memory leaks
      particles.length = 0;
    };
  }, []);

  return (
    <div style={{ 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center',
      backgroundColor: '#F0EEE6',
      width: '100vw',
      height: '100vh'
    }}>
      <div style={{
        width: '550px',
        height: '550px',
        border: '1px solid rgba(0, 0, 0, 0.1)',
        boxShadow: '0 0 20px rgba(0, 0, 0, 0.05)',
        borderRadius: '8px',
        overflow: 'hidden'
      }}>
        <canvas ref={canvasRef} />
      </div>
    </div>
  );
};

export default EtherealTorusFlow;
```

```javascript
import React, { useRef, useEffect } from 'react'
import * as THREE from 'three'

const metadata = {
  themes: "Source, Radiance, Forgiveness",
  visualization: "Particles radiating from a central source in gentle waves",
  promptSuggestion: "1. Add subtle radiance variations\n2. Create source-centered waves\n3. Vary emanation patterns naturally\n4. Introduce gentle pulse rhythms\n5. Make radiance follow natural flows"
}

const ParticleCylinder = () => {
  const containerRef = useRef(null)
  
  useEffect(() => {
    if (!containerRef.current) return
    const container = containerRef.current
    
    // Setup scene, camera, and renderer
    const scene = new THREE.Scene()
    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000)
    const renderer = new THREE.WebGLRenderer({ antialias: true })
    
    renderer.setSize(container.clientWidth, container.clientHeight)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
    renderer.setClearColor(0xF0EEE6)
    container.appendChild(renderer.domElement)
    
    // Set camera position
    camera.position.z = 6.25
    
    // Create particle material
    const particleMaterial = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        opacity: { value: 0.4 }
      },
      vertexShader: `
        uniform float time;
        attribute float size;
        attribute vec3 customColor;
        varying vec3 vColor;
        
        float rand(vec2 co) {
          return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }
        
        void main() {
          vColor = customColor;
          vec3 pos = position;
          
          // Calculate radial distance and angle
          float radius = length(pos.xz);
          float angle = atan(pos.z, pos.x);
          float height = pos.y;
          
          // Source pulse
          float pulse = sin(time * 2.0) * 0.2 + 0.8;
          
          // Radial waves emanating from center
          float wave = sin(radius * 3.0 - time * 3.0) * 0.2;
          
          // Vertical oscillation based on radius
          float verticalWave = cos(radius * 2.0 - time * 1.5) * 0.3;
          
          // Spiral rotation
          float rotationSpeed = 0.05 / (radius + 1.0);
          float newAngle = angle + time * rotationSpeed;
          
          // Apply transformations
          vec3 newPos;
          newPos.x = cos(newAngle) * (radius + wave) * pulse;
          newPos.z = sin(newAngle) * (radius + wave) * pulse;
          newPos.y = height + verticalWave;
          
          // Scale for canvas size
          newPos *= 2.34375;
          
          pos = newPos;
          
          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_PointSize = size * (100.0 / -mvPosition.z); // Set to exactly 100
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        uniform float opacity;
        varying vec3 vColor;
        void main() {
          float dist = length(gl_PointCoord - vec2(0.5));
          if (dist > 0.5) discard;
          float alpha = (1.0 - smoothstep(0.45, 0.5, dist)) * opacity;
          gl_FragColor = vec4(vColor, alpha);
        }
      `,
      transparent: true,
      depthWrite: false
    })
    
    // Generate particles
    const count = 37500
    const positions = new Float32Array(count * 3)
    const colors = new Float32Array(count * 3)
    const sizes = new Float32Array(count)
    
    for (let i = 0; i < count; i++) {
      // Create concentric rings with height variation
      const t = i / count
      const radius = Math.pow(t, 0.5) // Square root distribution for density
      const angle = t * Math.PI * 30 // Many rotations for spiral effect
      const height = (Math.random() - 0.5) * 2
      
      positions[i * 3] = Math.cos(angle) * radius
      positions[i * 3 + 1] = height
      positions[i * 3 + 2] = Math.sin(angle) * radius

      // Rich grays with darker center
      const centerDist = Math.sqrt(radius)
      const baseShade = 0.02 + centerDist * 0.13
      const variation = Math.random() * 0.05
      const shade = baseShade + variation
      colors[i * 3] = shade
      colors[i * 3 + 1] = shade
      colors[i * 3 + 2] = shade

      // Larger particles near center
      sizes[i] = (1.0 - centerDist) * 0.164 + 0.133
    }
    
    // Create geometry and points
    const geometry = new THREE.BufferGeometry()
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))
    geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3))
    geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1))
    
    const points = new THREE.Points(geometry, particleMaterial)
    scene.add(points)
    
    // Animation loop
    const clock = new THREE.Clock()
    let animationFrameId
    
    const animate = () => {
      animationFrameId = requestAnimationFrame(animate)
      
      const time = clock.getElapsedTime() * 0.4
      
      particleMaterial.uniforms.time.value = time
      
      renderer.render(scene, camera)
    }
    
    animate()
    
    // Handle resize
    const handleResize = () => {
      const width = container.clientWidth
      const height = container.clientHeight
      
      camera.aspect = width / height
      camera.updateProjectionMatrix()
      renderer.setSize(width, height)
    }
    
    window.addEventListener('resize', handleResize)
    
    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize)
      cancelAnimationFrame(animationFrameId)
      
      if (renderer) {
        renderer.dispose()
        if (container.contains(renderer.domElement)) {
          container.removeChild(renderer.domElement)
        }
      }
      
      if (geometry) geometry.dispose()
      if (particleMaterial) particleMaterial.dispose()
    }
  }, [])
  
  return (
    <div 
      ref={containerRef}
      style={{ 
        margin: 0,
        background: '#F0EEE6',
        overflow: 'hidden',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        height: '100vh',
        width: '100vw',
        position: 'relative'
      }}
    />
  )
}

ParticleCylinder.metadata = metadata
export default ParticleCylinder
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: following intuition, no fixed path, open mind leads forward
// visualization: Points freely follow an unpredictable leader, finding their way through openness

const BouncingPointCloud = () => {
  const canvasRef = useRef(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Setup
    ctx.fillStyle = '#F0EEE6'; // cream background
    ctx.fillRect(0, 0, width, height);
    
    // Leader following its intuition
    const ball = {
      x: width / 2,
      y: height / 2,
      radius: 120, // Fixed size
      vx: (Math.random() * 2 - 1) * 2,
      vy: (Math.random() * 2 - 1) * 2
    };
    
    // Particle system
    const numPoints = 25000;
    const points = [];
    let time = 0;
    
    // Calculate field value at a point (modified to use single ball)
    const calculateField = (x, y) => {
      const dx = x - ball.x;
      const dy = y - ball.y;
      const distSq = dx * dx + dy * dy;
      return ball.radius * ball.radius / distSq;
    };
    
    // Generate initial points
    for (let i = 0; i < numPoints; i++) {
      const x = Math.random() * width;
      const y = Math.random() * height;
      const field = calculateField(x, y);
      
      points.push({
        x,
        y,
        z: Math.random() * 2 - 1, // Depth for 3D effect
        size: 0.5 + Math.random() * 1.5,
        field,
        active: field > 1,
        targetX: x,
        targetY: y,
        originalX: x,
        originalY: y,
        phase: Math.random() * Math.PI * 2
      });
    }
    
    // Animation timing control variables
    let lastFrameTime = 0;
    const targetFPS = 18; // Equivalent to 55.56ms interval (18fps)
    const frameInterval = 1000 / targetFPS;
    let animationFrameId = null;
    
    // Animation function with time delta control
    const animate = (currentTime) => {
      // Initialize lastFrameTime on first frame
      if (!lastFrameTime) {
        lastFrameTime = currentTime;
      }
      
      const deltaTime = currentTime - lastFrameTime;
      
      // Only update animation when enough time has passed
      if (deltaTime >= frameInterval) {
        ctx.fillStyle = '#F0EEE6';
        ctx.fillRect(0, 0, width, height);
        
        time += 0.0005; // Set to 10% of original speed
        
        // Update ball position
        ball.x += ball.vx;
        ball.y += ball.vy;
        
        // Bounce off edges with slight randomness
        if (ball.x - ball.radius < 0) {
          ball.x = ball.radius;
          ball.vx = Math.abs(ball.vx) * (0.9 + Math.random() * 0.2);
          ball.vy += (Math.random() * 2 - 1) * 0.5; // Add some randomness to y velocity
        }
        if (ball.x + ball.radius > width) {
          ball.x = width - ball.radius;
          ball.vx = -Math.abs(ball.vx) * (0.9 + Math.random() * 0.2);
          ball.vy += (Math.random() * 2 - 1) * 0.5;
        }
        if (ball.y - ball.radius < 0) {
          ball.y = ball.radius;
          ball.vy = Math.abs(ball.vy) * (0.9 + Math.random() * 0.2);
          ball.vx += (Math.random() * 2 - 1) * 0.5;
        }
        if (ball.y + ball.radius > height) {
          ball.y = height - ball.radius;
          ball.vy = -Math.abs(ball.vy) * (0.9 + Math.random() * 0.2);
          ball.vx += (Math.random() * 2 - 1) * 0.5;
        }
        
        // Ensure minimum velocity
        const minSpeed = 0.75;
        const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
        if (currentSpeed < minSpeed) {
          ball.vx = (ball.vx / currentSpeed) * minSpeed;
          ball.vy = (ball.vy / currentSpeed) * minSpeed;
        }
        
        // Cap maximum velocity
        const maxSpeed = 1.5;
        const speedFactor = Math.min(1, maxSpeed / currentSpeed);
        ball.vx *= speedFactor;
        ball.vy *= speedFactor;
        
        // Update and draw points
        for (const point of points) {
          // Calculate new field value
          const field = calculateField(point.x, point.y);
          const prevActive = point.active;
          point.active = field > 1;
          
          // Handle transition between states
          if (point.active !== prevActive) {
            // If becoming active, set target near current position
            if (point.active) {
              const angle = Math.random() * Math.PI * 2;
              const dist = 5 + Math.random() * 10;
              point.targetX = point.x + Math.cos(angle) * dist;
              point.targetY = point.y + Math.sin(angle) * dist;
            } else {
              // If becoming inactive, slowly return to original position
              point.targetX = point.originalX;
              point.targetY = point.originalY;
            }
          }
          
          // Apply organic movement based on state
          if (point.active) {
            // Points following with open minds
            const angle = Math.atan2(point.y - ball.y, point.x - ball.x);
            const distFromCenter = Math.sqrt(
              (point.x - ball.x) * (point.x - ball.x) + 
              (point.y - ball.y) * (point.y - ball.y)
            );
            
            // Circular flow along ball's edge
            const tangentialAngle = angle + Math.PI / 2;
            const flowSpeed = 0.25 * (1 - distFromCenter / ball.radius);
            
            point.x += Math.cos(tangentialAngle) * flowSpeed;
            point.y += Math.sin(tangentialAngle) * flowSpeed;
            
            // Small radial pulsation
            const radialPulse = Math.sin(time * 2 + point.phase) * 0.2;
            point.x += Math.cos(angle) * radialPulse;
            point.y += Math.sin(angle) * radialPulse;
            
            // Keep points inside the field
            if (calculateField(point.x, point.y) < 1) {
              // If drifted outside, pull back toward ball
              point.x = point.x + (ball.x - point.x) * 0.1;
              point.y = point.y + (ball.y - point.y) * 0.1;
            }
          } else {
            // Points outside the ball: drift or follow
            const distToTarget = Math.sqrt(
              (point.targetX - point.x) * (point.targetX - point.x) + 
              (point.targetY - point.y) * (point.targetY - point.y)
            );
            
            // Either drift toward target, or start following the ball
            if (distToTarget > 100 || Math.random() < 0.001) {
              // Follow the ball with some delay
              const dx = ball.x - point.x;
              const dy = ball.y - point.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              
              if (dist < 200 + Math.random() * 100) {
                point.targetX = ball.x + (Math.random() * 2 - 1) * 100;
                point.targetY = ball.y + (Math.random() * 2 - 1) * 100;
              }
            }
            
            // Move toward target with easing
            point.x += (point.targetX - point.x) * 0.01;
            point.y += (point.targetY - point.y) * 0.01;
          }
          
          // Additional gentle flow for all points
          point.x += Math.sin(time * 0.3 + point.y * 0.01) * 0.1;
          point.y += Math.cos(time * 0.3 + point.x * 0.01) * 0.1;
          
          // Wrap around edges
          if (point.x < 0) point.x = width;
          if (point.x > width) point.x = 0;
          if (point.y < 0) point.y = height;
          if (point.y > height) point.y = 0;
          
          // Calculate alpha based on field strength and activity
          let alpha;
          if (point.active) {
            alpha = Math.min(0.9, 0.3 + field * 0.4);
          } else {
            // Calculate distance to ball
            const dx = point.x - ball.x;
            const dy = point.y - ball.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            // Points closer to ball are more visible
            const proximity = Math.max(0, 1 - dist / (ball.radius * 2.5));
            alpha = 0.05 + proximity * 0.2;
          }
          
          // Draw point
          ctx.fillStyle = `rgba(51, 51, 51, ${alpha})`;
          ctx.beginPath();
          ctx.arc(point.x, point.y, point.size, 0, Math.PI * 2);
          ctx.fill();
        }
      
        // Update lastFrameTime, accounting for any remainder to prevent drift
        lastFrameTime = currentTime - (deltaTime % frameInterval);
      }
      
      // Continue animation loop
      animationFrameId = requestAnimationFrame(animate);
    };
    
    // Start animation
    animationFrameId = requestAnimationFrame(animate);
    
    return () => {
      // Cancel animation frame to prevent memory leaks
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Clear points array to prevent memory leaks
      points.length = 0;
    };
  }, []);
  
  return (
    <div className="flex justify-center items-center w-full h-full bg-gray-100">
      <canvas 
        ref={canvasRef} 
        width={550} 
        height={550} 
        className="shadow-lg"
      />
    </div>
  );
};

export default BouncingPointCloud;
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: balance of opposites, return to wholeness, keep to the block
// visualization: Crystalline forms grow in perfect balance, always returning to their core structure

const CrystallineBiology = () => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    canvas.width = 550;
    canvas.height = 550;

    let time = 0;
    let crystals = [];
    const numCrystals = 4;

    class Crystal {
      constructor(x, y, size) {
        this.x = x;
        this.y = y;
        this.size = size;
        this.segments = [];
        this.angle = 0;
        this.rotationSpeed = 0.001; // Increased from 0.0002 to ensure visible rotation
        this.sides = 6;
        this.baseGrowthPhase = Math.random() * Math.PI * 2;
        this.lastGrowthPhase = 0;
        this.currentGrowthPhase = 0;
        
        this.generateStructure();
      }

      generateStructure() {
        this.segments = [];
        
        // Create balanced structure of opposites
        for (let ring = 0; ring < 5; ring++) {
          const ringRadius = this.size * (0.15 + ring * 0.17);
          const numSegments = this.sides * (ring + 1);
          
          for (let i = 0; i < numSegments; i++) {
            const angle = (i / numSegments) * Math.PI * 2;
            const innerRadius = ring === 0 ? 0 : this.size * (0.15 + (ring - 1) * 0.17);
            
            this.segments.push({
              angle: angle,
              innerRadius: innerRadius,
              outerRadius: ringRadius,
              basePhase: Math.random() * Math.PI * 2,
              currentInnerRadius: innerRadius,
              currentOuterRadius: ringRadius,
              currentAngle: angle,
              branching: ring > 2 && Math.random() < 0.2
            });
          }
        }
      }

      update(time) {
        // Make sure rotation continues even after initial development
        this.angle += this.rotationSpeed * 5; // Increased to ensure visible rotation
        
        // Very smooth, gradual breathing effect
        this.lastGrowthPhase = this.currentGrowthPhase;
        const targetGrowthPhase = Math.sin(time * 0.05 + this.baseGrowthPhase) * 0.15 + 0.85; // Slower oscillation (0.1 -> 0.05)
        this.currentGrowthPhase += (targetGrowthPhase - this.currentGrowthPhase) * 0.005; // Much slower interpolation (0.02 -> 0.005)
        
        // Update segments with extreme smoothing
        this.segments.forEach(segment => {
          const targetInnerRadius = segment.innerRadius * this.currentGrowthPhase;
          const targetOuterRadius = segment.outerRadius * this.currentGrowthPhase;
          const targetAngle = segment.angle + Math.sin(time * 0.15 + segment.basePhase) * 0.005; // Slowed down (0.3 -> 0.15)
          
          // Much slower, more extreme smoothing for initial development
          segment.currentInnerRadius += (targetInnerRadius - segment.currentInnerRadius) * 0.005; // Slowed down (0.02 -> 0.005)
          segment.currentOuterRadius += (targetOuterRadius - segment.currentOuterRadius) * 0.005; // Slowed down (0.02 -> 0.005)
          segment.currentAngle += (targetAngle - segment.currentAngle) * 0.005; // Slowed down (0.02 -> 0.005)
        });
      }

      draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        // Draw delicate geometric base
        ctx.strokeStyle = 'rgba(100, 100, 100, 0.2)';
        ctx.lineWidth = 1;
        
        for (let i = 0; i < this.sides; i++) {
          const angle = (i / this.sides) * Math.PI * 2;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(
            Math.cos(angle) * this.size,
            Math.sin(angle) * this.size
          );
          ctx.stroke();
        }
        
        // Draw segments with consistent styling
        this.segments.forEach(segment => {
          const innerX = Math.cos(segment.currentAngle) * segment.currentInnerRadius;
          const innerY = Math.sin(segment.currentAngle) * segment.currentInnerRadius;
          const outerX = Math.cos(segment.currentAngle) * segment.currentOuterRadius;
          const outerY = Math.sin(segment.currentAngle) * segment.currentOuterRadius;
          
          // Main segment
          ctx.strokeStyle = 'rgba(60, 60, 60, 0.4)';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(innerX, innerY);
          ctx.lineTo(outerX, outerY);
          ctx.stroke();
          
          // Nodes along segment (fewer, more stable)
          const numNodes = 1;
          for (let n = 0; n < numNodes; n++) {
            const t = 0.6; // Fixed position along segment
            const nodeX = innerX + (outerX - innerX) * t;
            const nodeY = innerY + (outerY - innerY) * t;
            const nodeSize = 6;
            
            // Smooth node shape
            const nodePoints = 8;
            ctx.beginPath();
            for (let p = 0; p <= nodePoints; p++) {
              const a = (p / nodePoints) * Math.PI * 2;
              const r = nodeSize * (1 + Math.sin(a * 2 + segment.basePhase) * 0.05);
              const px = nodeX + Math.cos(a) * r;
              const py = nodeY + Math.sin(a) * r;
              
              if (p === 0) ctx.moveTo(px, py);
              else ctx.lineTo(px, py);
            }
            
            ctx.strokeStyle = 'rgba(50, 50, 50, 0.5)';
            ctx.lineWidth = 0.8;
            ctx.stroke();
            
            // Node core
            ctx.beginPath();
            ctx.arc(nodeX, nodeY, nodeSize * 0.25, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(50, 50, 50, 0.3)';
            ctx.lineWidth = 0.6;
            ctx.stroke();
          }
          
          // Stable branching
          if (segment.branching) {
            const branchAngle = segment.currentAngle + 0.2;
            const branchLength = segment.currentOuterRadius * 0.3;
            const branchX = outerX + Math.cos(branchAngle) * branchLength;
            const branchY = outerY + Math.sin(branchAngle) * branchLength;
            
            ctx.strokeStyle = 'rgba(60, 60, 60, 0.3)';
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            ctx.moveTo(outerX, outerY);
            ctx.lineTo(branchX, branchY);
            ctx.stroke();
            
            // Branch terminal
            ctx.beginPath();
            ctx.arc(branchX, branchY, 2.5, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(60, 60, 60, 0.4)';
            ctx.stroke();
          }
        });
        
        // Keep to the block - the stable core within
        const coreSize = this.size * 0.06;
        ctx.strokeStyle = 'rgba(80, 80, 80, 0.5)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, 0, coreSize, 0, Math.PI * 2);
        ctx.stroke();
        
        // Inner core
        ctx.beginPath();
        ctx.arc(0, 0, coreSize * 0.5, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(80, 80, 80, 0.3)';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        ctx.restore();
      }
    }

    // Initialize crystals
    function initCrystals() {
      crystals = [];
      for (let i = 0; i < numCrystals; i++) {
        const x = canvas.width * (0.2 + Math.random() * 0.6);
        const y = canvas.height * (0.2 + Math.random() * 0.6);
        const size = 70 + Math.random() * 30;
        crystals.push(new Crystal(x, y, size));
      }
    }

    initCrystals();

    // Animation timing control variables
    let animationFrameId = null;
    let lastFrameTime = 0;
    const targetFPS = 16.7; // Equivalent to 60ms interval (16.7fps)
    const frameInterval = 1000 / targetFPS;
    
    // Animation function with time delta control
    function animate(currentTime) {
      // Initialize lastFrameTime on first frame
      if (!lastFrameTime) {
        lastFrameTime = currentTime;
      }
      
      const deltaTime = currentTime - lastFrameTime;
      
      // Only update animation when enough time has passed (mimics setInterval at 60ms)
      if (deltaTime >= frameInterval) {
        // Soft background with no transparency for no flashing
        ctx.fillStyle = '#F0EEE6';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        time += 0.005; // Very slow time progression

        // Update and draw crystals
        crystals = crystals.filter(crystal => !crystal.isDead);
        crystals.forEach(crystal => {
          crystal.update(time);
          crystal.draw(ctx);
        });

        // Draw crystal connections - very subtle and stable
        for (let i = 0; i < crystals.length; i++) {
          for (let j = i + 1; j < crystals.length; j++) {
            const crystalA = crystals[i];
            const crystalB = crystals[j];
            
            const distance = Math.sqrt(
              (crystalA.x - crystalB.x) * (crystalA.x - crystalB.x) +
              (crystalA.y - crystalB.y) * (crystalA.y - crystalB.y)
            );
            
            if (distance < 280) {
              const opacity = Math.pow(1 - distance / 280, 2) * 0.1;
              
              ctx.strokeStyle = `rgba(60, 60, 60, ${opacity})`;
              ctx.lineWidth = 0.8;
              ctx.beginPath();
              
              // Straight, stable connection
              ctx.moveTo(crystalA.x, crystalA.y);
              ctx.lineTo(crystalB.x, crystalB.y);
              ctx.stroke();
            }
          }
        }
        
        // Update lastFrameTime, accounting for any remainder to prevent drift
        lastFrameTime = currentTime - (deltaTime % frameInterval);
      }
      
      // Continue animation loop
      animationFrameId = requestAnimationFrame(animate);
    }
    
    // Start animation
    animationFrameId = requestAnimationFrame(animate);

    return () => {
      // Cancel animation frame to prevent memory leaks
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Clear crystals array to prevent memory leaks
      crystals.length = 0;
    };
  }, []);

  return (
    <div style={{ 
      display: 'flex', 
      justifyContent: 'center', 
      alignItems: 'center', 
      height: '100vh', 
      backgroundColor: '#F0EEE6' 
    }}>
      <div style={{ 
        width: '550px', 
        height: '550px', 
        overflow: 'hidden',
        border: '1px solid #ddd',
        borderRadius: '8px'
      }}>
        <canvas ref={canvasRef} />
      </div>
    </div>
  );
};

export default CrystallineBiology;
```

```javascript
import React, { useRef, useEffect } from 'react';
import * as THREE from 'three';

const metadata = {
  themes: "world as sacred, accept things as they are, time for everything",
  visualization: "Branches grow and recede in their own time, accepting their natural cycles",
  promptSuggestion: "1. Enhance fractal complexity\n2. Add more growth patterns\n3. Develop stronger divisions\n4. Create clearer evolution\n5. Increase sense of emergence"
};

// Animation constants
const LINGER_START = 0.6;
const LINGER_END = 0.8;
const DELAY_PER_LEVEL = 0.15;
const GROWTH_MULTIPLIER = 3; // Increased from 2 for faster growth
const CROSS_BRACE_COUNT = 2;
const WAVE_AMPLITUDE = 0.05;

// Smooth easing function
const easeInOut = (t: number): number => {
  return t < 0.5
    ? 2 * t * t
    : -1 + (4 - 2 * t) * t;
};

interface BranchProps {
  start: [number, number, number];
  length: number;
  angle: number;
  depth: number;
  maxDepth: number;
  scale: number;
}

class FractalBranch {
  private lines: THREE.Line[] = [];
  private children: FractalBranch[] = [];
  private group: THREE.Group;
  private disposed: boolean = false;

  constructor(
    private props: BranchProps,
    private parent: THREE.Group
  ) {
    this.group = new THREE.Group();
    this.parent.add(this.group);
  }

  update(phase: number): void {
    if (this.disposed) return;

    const { start, length, angle, depth, maxDepth, scale } = this.props;
    const [sx, sy, sz] = start;

    // Calculate growth factor with smooth transitions but no decay
    const atMaxDepth = depth === maxDepth;
    
    let growthFactor;
    // Modified to remove decay phase - branches remain extended once grown
    if (phase >= 0.9) {
      // Always maintain full extension once grown
      growthFactor = 1;
    } else if (atMaxDepth && phase > LINGER_START) {
      growthFactor = 1;
    } else {
      // Slower, more deliberate growth
      const growthPhase = Math.min(1, Math.max(0, (phase - depth * DELAY_PER_LEVEL) * GROWTH_MULTIPLIER));
      growthFactor = easeInOut(growthPhase);
    }

    const actualLength = length * growthFactor;
    const ex = sx + Math.cos(angle) * actualLength;
    const ey = sy + Math.sin(angle) * actualLength;
    const ez = sz;

    // Create or update lines
    if (this.lines.length === 0) {
      // Create main branch line
      const mainGeometry = new THREE.BufferGeometry();
      const mainPoints = new Float32Array([sx, sy, sz, ex, ey, ez]);
      mainGeometry.setAttribute('position', new THREE.BufferAttribute(mainPoints, 3));
      const mainMaterial = new THREE.LineBasicMaterial({ 
        color: 0x333333,
        transparent: true,
        opacity: 0.4,
        linewidth: 0.5
      });
      const mainLine = new THREE.Line(mainGeometry, mainMaterial);
      this.group.add(mainLine);
      this.lines.push(mainLine);

      // Add cross braces
      if (growthFactor > 0.3) {
        const crossLength = length * (0.2 + Math.sin(phase * Math.PI * 2) * 0.05);
        const crossAngle1 = angle + Math.PI/2;
        const crossAngle2 = angle - Math.PI/2;
        
        for (let i = 0; i < CROSS_BRACE_COUNT; i++) {
          const t = (i + 1) / 4;
          const px = sx + (ex - sx) * t;
          const py = sy + (ey - sy) * t;
          const pz = sz + (ez - sz) * t;
          
          const wave = Math.sin(t * Math.PI * 2 + phase * Math.PI * 4) * WAVE_AMPLITUDE;
          
          const crossGeometry = new THREE.BufferGeometry();
          const crossPoints = new Float32Array([
            px + Math.cos(crossAngle1) * crossLength * (t + wave),
            py + Math.sin(crossAngle1) * crossLength * (t + wave),
            pz,
            px + Math.cos(crossAngle2) * crossLength * (t + wave),
            py + Math.sin(crossAngle2) * crossLength * (t + wave),
            pz
          ]);
          crossGeometry.setAttribute('position', new THREE.BufferAttribute(crossPoints, 3));
          const crossMaterial = new THREE.LineBasicMaterial({ 
            color: 0x333333,
            transparent: true,
            opacity: 0.4,
            linewidth: 0.5
          });
          const crossLine = new THREE.Line(crossGeometry, crossMaterial);
          this.group.add(crossLine);
          this.lines.push(crossLine);
        }
      }
    } else {
      // Update existing main branch
      const mainLine = this.lines[0];
      const positions = mainLine.geometry.attributes.position.array as Float32Array;
      positions[3] = ex;
      positions[4] = ey;
      positions[5] = ez;
      mainLine.geometry.attributes.position.needsUpdate = true;

      // Update cross braces
      if (this.lines.length > 1 && growthFactor > 0.3) {
        const crossLength = length * (0.2 + Math.sin(phase * Math.PI * 2) * 0.05);
        
        for (let i = 0; i < CROSS_BRACE_COUNT; i++) {
          const lineIndex = i + 1;
          if (lineIndex < this.lines.length) {
            const crossLine = this.lines[lineIndex];
            const positions = crossLine.geometry.attributes.position.array as Float32Array;
            const t = (i + 1) / 4;
            const px = sx + (ex - sx) * t;
            const py = sy + (ey - sy) * t;
            const pz = sz + (ez - sz) * t;
            
            const wave = Math.sin(t * Math.PI * 2 + phase * Math.PI * 4) * WAVE_AMPLITUDE;
            const crossAngle1 = angle + Math.PI/2;
            const crossAngle2 = angle - Math.PI/2;
            
            positions[0] = px + Math.cos(crossAngle1) * crossLength * (t + wave);
            positions[1] = py + Math.sin(crossAngle1) * crossLength * (t + wave);
            positions[2] = pz;
            positions[3] = px + Math.cos(crossAngle2) * crossLength * (t + wave);
            positions[4] = py + Math.sin(crossAngle2) * crossLength * (t + wave);
            positions[5] = pz;
            
            crossLine.geometry.attributes.position.needsUpdate = true;
          }
        }
      }
    }

    // Accept each branch's time to grow, but don't modify structure after full growth
    if (depth < maxDepth && 
        !(phase >= 0.8 && depth > 0) && 
        phase >= depth * 0.15 &&
        phase < 0.95) { // Don't create or modify branches after growth complete
      
      const numBranches = 3 + (depth < 2 ? 1 : 0);
      
      // Create new branches if needed
      if (this.children.length === 0) {
        for (let i = 0; i < numBranches; i++) {
          const t = (i + 1) / (numBranches + 1);
          const spread = 0.8 + (depth * 0.1);
          const branchAngle = angle + (t - 0.5) * Math.PI * spread;
          
          const branchProps: BranchProps = {
            start: [
              sx + (ex - sx) * t,
              sy + (ey - sy) * t,
              sz + (ez - sz) * t
            ],
            length: length * (0.6 - depth * 0.05),
            angle: branchAngle,
            depth: depth + 1,
            maxDepth,
            scale: scale * 0.8
          };
          
          this.children.push(new FractalBranch(branchProps, this.group));
        }
      } else {
        // Update existing branch positions
        for (let i = 0; i < this.children.length; i++) {
          const t = (i + 1) / (numBranches + 1);
          this.children[i].props.start = [
            sx + (ex - sx) * t,
            sy + (ey - sy) * t,
            sz + (ez - sz) * t
          ];
        }
      }
    }

    // Update all children
    this.children.forEach(child => child.update(phase));

    // No cleanup needed since we're reversing instead of disposing
  }

  dispose(): void {
    if (this.disposed) return;
    this.disposed = true;

    // Dispose children first
    this.children.forEach(child => child.dispose());
    this.children = [];

    // Dispose lines
    this.lines.forEach(line => {
      this.group.remove(line);
      line.geometry.dispose();
      (line.material as THREE.Material).dispose();
    });
    this.lines = [];

    // Remove from parent
    this.parent.remove(this.group);
  }
}

class FractalSystem {
  private branches: FractalBranch[] = [];
  private group: THREE.Group;

  constructor(parentGroup: THREE.Group) {
    this.group = new THREE.Group();
    parentGroup.add(this.group);
    this.initialize();
  }

  // Initialize the sacred pattern
  private initialize(): void {
    const count = 6;
    const scale = 2;
    
    for (let i = 0; i < count; i++) {
      const angle = (i / count) * Math.PI * 2;
      const branchProps: BranchProps = {
        start: [
          Math.cos(angle) * scale * 0.2,
          Math.sin(angle) * scale * 0.2,
          0
        ],
        length: scale,
        angle: angle + Math.PI/2,
        depth: 0,
        maxDepth: 7,
        scale: scale
      };
      
      this.branches.push(new FractalBranch(branchProps, this.group));
    }
  }

  update(time: number): void {
    this.branches.forEach(branch => branch.update(time));
  }

  dispose(): void {
    this.branches.forEach(branch => branch.dispose());
    this.branches = [];
    this.group.parent?.remove(this.group);
  }
}

const Artwork55v1: React.FC = () => {
  const containerRef = useRef<HTMLDivElement>(null);
  const cleanupRef = useRef<() => void>(null);

  useEffect(() => {
    if (!containerRef.current) return;

    // Setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75,
      containerRef.current.clientWidth / containerRef.current.clientHeight,
      0.1,
      1000
    );
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    renderer.setClearColor(new THREE.Color('rgb(240, 238, 231)'));
    containerRef.current.appendChild(renderer.domElement);

    // Position camera
    camera.position.z = 5;

    // Create main group
    const mainGroup = new THREE.Group();
    scene.add(mainGroup);

    // Add lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(5, 5, 5);
    scene.add(directionalLight);

    const pointLight = new THREE.PointLight(0xffffff, 0.4);
    pointLight.position.set(-5, 3, -5);
    scene.add(pointLight);

    // Create fractal system
    const fractalSystem = new FractalSystem(mainGroup);

    // Animation timing control
    const clock = new THREE.Clock();
    let animationFrameId: number | null = null;
    let lastFrameTime = 0;
    
    // Slow down the overall animation
    const CYCLE_LENGTH = 60; // 60 seconds total cycle
    const GROWTH_PHASE_LENGTH = 25; // First 25 seconds for growth
    const FRAME_RATE = 20; // 20 fps for smoother motion
    const frameInterval = 1000 / FRAME_RATE; // milliseconds between frames
    
    // Animation function with time delta control
    const animate = (currentTime: number) => {
      // Initialize lastFrameTime on first frame
      if (!lastFrameTime) {
        lastFrameTime = currentTime;
      }
      
      const deltaTime = currentTime - lastFrameTime;
      
      // Only update animation when enough time has passed (mimics setInterval at 15fps)
      if (deltaTime >= frameInterval) {
        const elapsedTime = clock.getElapsedTime();
        const cycleTime = elapsedTime % CYCLE_LENGTH;
        
        // Simple two-phase animation:
        // 1. Growth phase
        // 2. Spin phase
        
        // Determine which phase we're in
        const isGrowthComplete = cycleTime >= GROWTH_PHASE_LENGTH;
        
        // Set time value for fractal update
        // (always 1.0 after growth phase to keep branches fully extended)
        const time = isGrowthComplete ? 1.0 : (cycleTime / GROWTH_PHASE_LENGTH);
        
        // Update fractal
        fractalSystem.update(time);
        
        // Handle rotation based on phase
        if (isGrowthComplete) {
          // SPIN PHASE: Simple constant rotation around z-axis (in-plane rotation)
          const spinStartTime = elapsedTime - GROWTH_PHASE_LENGTH;
          const verySlowRotationSpeed = 0.025; // Increased rotation speed
          mainGroup.rotation.z = spinStartTime * verySlowRotationSpeed;
          
          // Keep x and y rotation fixed to maintain the same plane
          mainGroup.rotation.x = 0;
          mainGroup.rotation.y = 0; 
        } else {
          // GROWTH PHASE: No rotation during growth
          mainGroup.rotation.x = 0;
          mainGroup.rotation.y = 0;
          mainGroup.rotation.z = 0;
        }
        
        renderer.render(scene, camera);
        
        // Update lastFrameTime, accounting for any remainder to prevent drift
        lastFrameTime = currentTime - (deltaTime % frameInterval);
      }
      
      // Continue animation loop
      animationFrameId = requestAnimationFrame(animate);
    };

    // Start animation
    animationFrameId = requestAnimationFrame(animate);

    // Handle resize
    const handleResize = () => {
      if (!containerRef.current) return;
      
      camera.aspect = containerRef.current.clientWidth / containerRef.current.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    };

    window.addEventListener('resize', handleResize);

    // Store cleanup function
    cleanupRef.current = () => {
      window.removeEventListener('resize', handleResize);
      
      // Cancel animation frame to prevent memory leaks
      if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      
      // Dispose of Three.js resources
      fractalSystem.dispose();
      
      // Dispose of geometries and materials
      scene.traverse((object) => {
        if (object instanceof THREE.Mesh) {
          object.geometry.dispose();
          if (Array.isArray(object.material)) {
            object.material.forEach(material => material.dispose());
          } else {
            object.material.dispose();
          }
        } else if (object instanceof THREE.Line) {
          object.geometry.dispose();
          (object.material as THREE.Material).dispose();
        }
      });
      
      // Clear the scene
      scene.clear();
      
      // Dispose of lights
      ambientLight.dispose();
      directionalLight.dispose();
      pointLight.dispose();
      
      // Dispose of renderer and force context loss
      renderer.dispose();
      renderer.forceContextLoss();
      
      // Remove renderer from DOM
      if (containerRef.current && renderer.domElement.parentNode) {
        containerRef.current.removeChild(renderer.domElement);
      }
      
      // Clear ref
      cleanupRef.current = null;
    };

    // Cleanup on unmount
    return () => {
      if (cleanupRef.current) {
        cleanupRef.current();
      }
    };
  }, []);

  return <div ref={containerRef} style={{ width: '100%', height: '100vh' }} />;
};

(Artwork55v1 as any).metadata = metadata;
export default Artwork55v1;
```

```javascript
import { useEffect, useRef } from 'react';

// themes: lead without force, achieve without boasting, nature's unceasing momentum
// visualization: Forms guide each other through gentle influence, moving with nature's flow

const DimensionalResonance = () => {
  const canvasRef = useRef(null);
  
  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    let animationFrameId;
    let time = 0;
    
    // Configuration for three-dimensional layers - REDUCED BY HALF
    const LAYER_COUNT = 5; // Reduced from 10 to 5
    const layers = [];
    
    // Size scale factor (12.5% larger than original)
    const sizeFactor = 1.125; 
    
    // Movement enhancement factor - REDUCED to be closer to original
    const movementFactor = 1.1; // Reduced from 1.8 to 1.1
    
    // Rotation enhancement factor
    const rotationFactor = 1.8; // Enhanced rotation specifically
    
    // Base forms (adjusted for new size)
    const baseForms = [
      { 
        centerX: 225 * sizeFactor, 
        centerY: 200 * sizeFactor, 
        radiusX: 100 * sizeFactor, 
        radiusY: 100 * sizeFactor, 
        rotation: 0, 
        phase: 0 
      },
      { 
        centerX: 350 * sizeFactor, 
        centerY: 175 * sizeFactor, 
        radiusX: 90 * sizeFactor, 
        radiusY: 100 * sizeFactor, 
        rotation: Math.PI / 6, 
        phase: 2 
      },
      { 
        centerX: 275 * sizeFactor, 
        centerY: 325 * sizeFactor, 
        radiusX: 100 * sizeFactor, 
        radiusY: 90 * sizeFactor, 
        rotation: -Math.PI / 4, 
        phase: 4 
      }
    ];
    
    const setupCanvas = () => {
      canvas.width = 550;
      canvas.height = 550;
      
      // Recenter the forms to fit in the canvas
      const centerAdjustX = (550 / 2) - (275 * sizeFactor);
      const centerAdjustY = (550 / 2) - (225 * sizeFactor);
      
      baseForms.forEach(form => {
        form.centerX += centerAdjustX;
        form.centerY += centerAdjustY;
      });
      
      // Each layer leads without forcing, following nature's way
      for (let i = 0; i < LAYER_COUNT; i++) {
        const depth = i / (LAYER_COUNT - 1); // 0 to 1
        const layerForms = baseForms.map(baseForm => {
          // Create variations based on depth
          const scale = 0.8 + depth * 0.4; // Deeper layers are smaller
          return {
            ...baseForm,
            centerX: baseForm.centerX + (depth - 0.5) * 30 * sizeFactor, // Offset deeper layers for parallax
            centerY: baseForm.centerY + (depth - 0.5) * 20 * sizeFactor,
            radiusX: baseForm.radiusX * scale,
            radiusY: baseForm.radiusY * scale,
            rotation: baseForm.rotation + depth * Math.PI * 0.1, // Slight rotation offset
            depth: depth,
            lineCount: Math.floor(30 - depth * 15), 
            lineWidth: 0.5 + depth * 0.7, 
            opacity: 0.2 + depth * 0.8, // Deeper layers are more opaque
            speed: (0.5 + depth * 1.5) * movementFactor // Reduced movement factor
          };
        });
        
        layers.push({
          depth: depth,
          forms: layerForms
        });
      }
    };
    
    const drawSpiralForm = (form, lineCount) => {
      const { centerX, centerY, radiusX, radiusY, rotation, depth, lineWidth, opacity, speed } = form;
      
      // Move with nature's unceasing momentum
      const breathFactor = Math.sin(time * 0.2 * speed + form.phase) * 0.15 * movementFactor + 1;
      const currentRadiusX = radiusX * breathFactor;
      const currentRadiusY = radiusY * breathFactor;
      
      // Enhanced back-and-forth rotation
      const oscillatingRotation = Math.sin(time * 0.15) * 0.2 * rotationFactor;
      const currentRotation = rotation + oscillatingRotation;
      
      for (let i = 0; i < lineCount; i++) {
        const scale = i / lineCount;
        const currentScale = scale * 0.9; // Leave a small hole in the middle
        
        ctx.beginPath();
        
        for (let angle = 0; angle <= Math.PI * 2; angle += 0.05) {
          const spiralOffset = angle * 0.2;
          const r = currentScale + Math.sin(angle * 10 + time * 0.1 * speed + form.phase) * 0.01 * movementFactor;
          
          // Calculate spiral wave effect - reduced amplitude
          const waveX = Math.sin(angle * 5 + time * 0.1 * speed) * radiusX * 0.05 * scale * movementFactor;
          const waveY = Math.cos(angle * 5 + time * 0.1 * speed) * radiusY * 0.05 * scale * movementFactor;
          
          // Calculate position with enhanced back-and-forth rotation
          const rX = currentRadiusX * r * Math.cos(angle + spiralOffset + currentRotation + time * 0.02 * speed);
          const rY = currentRadiusY * r * Math.sin(angle + spiralOffset + currentRotation + time * 0.02 * speed);
          
          const x = centerX + rX + waveX;
          const y = centerY + rY + waveY;
          
          if (angle === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        ctx.closePath();
        
        // Adjust opacity based on scale
        const lineOpacity = opacity * (0.2 + scale * 0.8);
        // Using dark gray for project colors
        ctx.strokeStyle = `rgba(50, 50, 50, ${lineOpacity})`;
        ctx.lineWidth = lineWidth;
        ctx.stroke();
      }
    };
    
    const render = () => {
      // Project cream color background
      ctx.fillStyle = '#F0EEE6';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw layers from back to front
      for (let i = 0; i < layers.length; i++) {
        const layer = layers[i];
        
        // Draw each form in the layer
        for (const form of layer.forms) {
          drawSpiralForm(form, form.lineCount);
        }
      }
      
      // Animate over time
      time += 0.005;
      animationFrameId = requestAnimationFrame(render);
    };
    
    setupCanvas();
    render();
    
    return () => {
      cancelAnimationFrame(animationFrameId);
      
      // Clear canvas context
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      
      // Clear layers array to prevent memory leaks
      layers.length = 0;
    }
  }, []);
  
  return (
    <div className="w-full h-full flex items-center justify-center bg-[#F0EEE6]">
      <canvas
        ref={canvasRef}
        className="max-w-full max-h-full shadow-lg"
      />
    </div>
  );
};

export default DimensionalResonance;
```

```javascript
// Poem 31 themes: Structure, Simplicity, Flow
// Visualization: Wireframe Möbius strip with smooth animation


import React, { useRef, useEffect } from 'react'
import * as THREE from 'three'

const metadata = {
  themes: "Structure, Simplicity, Flow",
  visualization: "Wireframe Möbius strip with smooth animation",
  promptSuggestion: "1. Adjust the twist rate\n2. Change the ribbon dimensions\n3. Alter the motion dynamics\n4. Add more wireframe density\n5. Change the rotation speed"
}

const ShinyLoop: React.FC = () => {
  const containerRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    if (!containerRef.current) return
    const container = containerRef.current
    
    const numPoints = 300
    const ribbonWidth = 0.5
    const SPRING_STRENGTH = 0.03
    const DAMPING = 0.99
    const MOMENTUM = 0.95
    const GRAB_INFLUENCE = 3.0
    
    let mouse = { x: 0, y: 0, z: 0 }
    let target = { x: 0, y: 0, z: 0 }
    let velocity = { x: 0, y: 0, z: 0 }
    let isGrabbed = false
    let grabPoint = 0

    // Create ribbon geometry
    const createGeometry = () => {
      const geometry = new THREE.BufferGeometry()
      const positions = new Float32Array(numPoints * 2 * 3)
      const normals = new Float32Array(numPoints * 2 * 3)
      const indices = []

      // Create triangles
      for (let i = 0; i < numPoints - 1; i++) {
        indices.push(i * 2, i * 2 + 1, (i + 1) * 2)
        indices.push(i * 2 + 1, (i + 1) * 2 + 1, (i + 1) * 2)
      }

      // Close the loop for Möbius strip
      indices.push((numPoints - 1) * 2, (numPoints - 1) * 2 + 1, 0)
      indices.push((numPoints - 1) * 2 + 1, 1, 0)

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))
      geometry.setAttribute('normal', new THREE.BufferAttribute(normals, 3))
      geometry.setIndex(indices)

      return geometry
    }

    // Create wireframe material
    const createMaterial = () => {
      return new THREE.MeshBasicMaterial({
        color: 0x000000,
        wireframe: true,
        wireframeLinewidth: 1,
        side: THREE.DoubleSide
      })
    }

    const width = container.clientWidth
    const height = container.clientHeight
    const dpr = window.devicePixelRatio || 1

    // Setup scene
    const scene = new THREE.Scene()
    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000)
    const renderer = new THREE.WebGLRenderer({ antialias: true })
    
    renderer.setPixelRatio(Math.min(dpr, 2))
    renderer.setSize(width, height)
    renderer.setClearColor(0xF0EEE6)
    container.appendChild(renderer.domElement)

    // Create geometry and material
    const geometry = createGeometry()
    const material = createMaterial()
    const mesh = new THREE.Mesh(geometry, material)
    
    const groupRef = new THREE.Group()
    groupRef.add(mesh)
    scene.add(groupRef)

    // Position camera
    camera.position.set(0, 0, 4)
    camera.lookAt(0, 0, 0)

    // Mouse interaction handlers
    const handlePointerDown = (event: MouseEvent) => {
      const rect = renderer.domElement.getBoundingClientRect()
      const x = ((event.clientX - rect.left) / rect.width) * 2 - 1
      const y = -((event.clientY - rect.top) / rect.height) * 2 + 1
      
      mouse.x = x * 3
      mouse.y = y * 3
      
      isGrabbed = true
    }

    const handlePointerMove = (event: MouseEvent) => {
      const rect = renderer.domElement.getBoundingClientRect()
      const x = ((event.clientX - rect.left) / rect.width) * 2 - 1
      const y = -((event.clientY - rect.top) / rect.height) * 2 + 1
      
      mouse.x = x * 3
      mouse.y = y * 3
    }

    const handlePointerUp = () => {
      isGrabbed = false
    }

    renderer.domElement.addEventListener('mousedown', handlePointerDown)
    renderer.domElement.addEventListener('mousemove', handlePointerMove)
    renderer.domElement.addEventListener('mouseup', handlePointerUp)
    renderer.domElement.addEventListener('mouseleave', handlePointerUp)

    // Animation loop
    let time = 0
    let animationFrameId: number
    
    const animate = () => {
      animationFrameId = requestAnimationFrame(animate)
      
      time += 0.0015
      
      // Update physics target
      if (isGrabbed) {
        target.x += (mouse.x - target.x) * 0.3
        target.y += (mouse.y - target.y) * 0.3
        target.z += (mouse.z - target.z) * 0.3
      }
      
      const positions = mesh.geometry.attributes.position.array
      const normals = mesh.geometry.attributes.normal.array
      
      for (let i = 0; i < numPoints; i++) {
        const t = i / (numPoints - 1)
        const angle = t * Math.PI * 2
        
        // Calculate influence from grabbed point
        let influence = 0
        if (isGrabbed) {
          const distFromGrab = Math.abs(t - grabPoint)
          influence = Math.max(0, 1 - distFromGrab * GRAB_INFLUENCE)
          influence = Math.pow(influence, 2)
        }
        
        // Base radius with breathing effect (25% larger)
        const baseRadius = 1.875 + Math.sin(time * 0.5 + t * Math.PI * 2) * 0.125
        const radius = baseRadius * (1 - influence * 0.3)
        
        // Calculate base position
        let baseX = Math.cos(angle) * radius
        let baseY = Math.sin(angle) * radius
        let baseZ = 0
        
        // Apply grab influence
        if (influence > 0) {
          const targetOffsetX = (target.x - baseX) * influence
          const targetOffsetY = (target.y - baseY) * influence
          const targetOffsetZ = (target.z - baseZ) * influence
          
          baseX += targetOffsetX + velocity.x * influence
          baseY += targetOffsetY + velocity.y * influence
          baseZ += targetOffsetZ + velocity.z * influence
        }
        
        // Calculate twist
        const twist = t * Math.PI + time * 0.2 * (1 - influence * 0.5)
        
        // Add wave
        const wave = Math.sin(angle * 3 + time * 2) * 0.1
        const waveX = Math.cos(angle + Math.PI/2) * wave
        const waveY = Math.sin(angle + Math.PI/2) * wave
        const waveZ = Math.sin(angle * 2 + time) * 0.2
        
        // Calculate tangent vector
        const tangentX = -Math.sin(angle)
        const tangentY = Math.cos(angle)
        const tangentZ = 0
        
        // Calculate normal vector with twist
        const normalX = Math.cos(angle + twist)
        const normalY = Math.sin(angle + twist)
        const normalZ = Math.sin(twist)
        
        // Calculate binormal
        const binormalX = tangentY * normalZ - tangentZ * normalY
        const binormalY = tangentZ * normalX - tangentX * normalZ
        const binormalZ = tangentX * normalY - tangentY * normalX
        
        // Width variation
        const width = ribbonWidth * (1.0 + Math.sin(twist * 2) * 0.1)
        
        // Set positions
        const idx = i * 6
        positions[idx] = baseX + waveX + binormalX * width
        positions[idx + 1] = baseY + waveY + binormalY * width
        positions[idx + 2] = baseZ + waveZ + binormalZ * width
        positions[idx + 3] = baseX + waveX - binormalX * width
        positions[idx + 4] = baseY + waveY - binormalY * width
        positions[idx + 5] = baseZ + waveZ - binormalZ * width
        
        // Set normals
        normals[idx] = normalX
        normals[idx + 1] = normalY
        normals[idx + 2] = normalZ
        normals[idx + 3] = -normalX
        normals[idx + 4] = -normalY
        normals[idx + 5] = -normalZ
      }
      
      mesh.geometry.attributes.position.needsUpdate = true
      mesh.geometry.attributes.normal.needsUpdate = true
      
      renderer.render(scene, camera)
    }
    
    animate()

    // Handle resize
    const handleResize = () => {
      const width = container.clientWidth
      const height = container.clientHeight
      const dpr = window.devicePixelRatio || 1
      
      camera.aspect = width / height
      camera.updateProjectionMatrix()
      renderer.setPixelRatio(Math.min(dpr, 2))
      renderer.setSize(width, height)
    }
    
    window.addEventListener('resize', handleResize)

    // Cleanup
    return () => {
      window.removeEventListener('resize', handleResize)
      
      renderer.domElement.removeEventListener('mousedown', handlePointerDown)
      renderer.domElement.removeEventListener('mousemove', handlePointerMove)
      renderer.domElement.removeEventListener('mouseup', handlePointerUp)
      renderer.domElement.removeEventListener('mouseleave', handlePointerUp)
      
      cancelAnimationFrame(animationFrameId)
      
      if (renderer) {
        renderer.dispose()
        if (container.contains(renderer.domElement)) {
          container.removeChild(renderer.domElement)
        }
      }
      
      if (geometry) geometry.dispose()
      if (material) material.dispose()
    }
  }, [])

  return (
    <div 
      ref={containerRef}
      style={{ 
        margin: 0,
        background: '#F0EEE6',
        overflow: 'hidden',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        height: '100vh',
        width: '100vw',
        position: 'relative'
      }}
    />
  )
}

ShinyLoop.metadata = metadata
export default ShinyLoop
```

```javascript
import React, { useEffect, useRef } from 'react';

// themes: source remains unrefined, natural following, return to river
// visualization: Waves flow naturally from an unrefined source, always returning home

const WaveVariationSparse = () => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d', { alpha: false });
    const width = 550;
    const height = 550;
    canvas.width = width;
    canvas.height = height;

    const resolution = 4;
    const rows = Math.floor(height / resolution);
    const cols = Math.floor(width / resolution);
    
    // Much fewer sources for sparse pattern
    const sources = [];
    const numSpirals = 1; // Just one spiral
    const pointsPerSpiral = 5; // Very few points
    
    // Create unrefined source points that flow like a river
    for (let i = 0; i < pointsPerSpiral; i++) {
      const t = i / pointsPerSpiral;
      const angle = t * 2 * Math.PI * 1.5; // Just 1.5 turns
      const radius = 100 + t * 150; // More compact spiral
      
      sources.push({
        x: width/2 + Math.cos(angle) * radius,
        y: height/2 + Math.sin(angle) * radius,
        wavelength: 60 + t * 30, // Much longer wavelengths
        phase: angle,
        amplitude: 1.0
      });
    }
    
    // Just one center point
    sources.push({
      x: width/2,
      y: height/2,
      wavelength: 80,
      phase: 0,
      amplitude: 1.5
    });

    // Animation timing control variables
    let time = 0;
    let animationFrameId = null;
    let lastFrameTime = 0;
    const targetFPS = 20; // 20 fps for smooth animation with controlled timing
    const frameInterval = 1000 / targetFPS;
    const field = new Float32Array(rows * cols);
    
    const bufferCanvas = document.createElement('canvas');
    bufferCanvas.width = width;
    bufferCanvas.height = height;
    const bufferCtx = bufferCanvas.getContext('2d', { alpha: false });

    const animate = (currentTime) => {
      // Initialize lastFrameTime on first frame
      if (!lastFrameTime) {
        lastFrameTime = currentTime;
      }
      
      const deltaTime = currentTime - lastFrameTime;
      
      // Only update animation when enough time has passed
      if (deltaTime >= frameInterval) {
        // Calculate remainder to prevent drift
        const remainder = deltaTime % frameInterval;
        
        // Update lastFrameTime with the time that's been processed
        lastFrameTime = currentTime - remainder;
        
        bufferCtx.fillStyle = '#F0EEE6';
        bufferCtx.fillRect(0, 0, width, height);

      // Let waves naturally follow their path home
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < cols; j++) {
          const x = j * resolution;
          const y = i * resolution;
          let amplitude = 0;

          for (let s = 0; s < sources.length; s++) {
            const source = sources[s];
            const dx = x - source.x;
            const dy = y - source.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Sharper falloff for more defined negative space
            const falloff = Math.exp(-distance / 250);
            
            amplitude += source.amplitude * falloff * 
              Math.sin((distance / source.wavelength - time) * 2 * Math.PI + source.phase);
          }

          field[i * cols + j] = amplitude;
        }
      }

      bufferCtx.strokeStyle = '#333';
      bufferCtx.lineWidth = 1.2;
      bufferCtx.beginPath();
      
      // Just two contour levels for minimal lines
      const levels = [-0.2, 0.2];
      
      for (const level of levels) {
        for (let i = 0; i < rows - 1; i++) {
          for (let j = 0; j < cols - 1; j++) {
            const idx = i * cols + j;
            const x = j * resolution;
            const y = i * resolution;
            
            const v00 = field[idx] > level;
            const v10 = field[idx + 1] > level;
            const v11 = field[idx + cols + 1] > level;
            const v01 = field[idx + cols] > level;
            
            if (v00 !== v10) {
              bufferCtx.moveTo(x + resolution / 2, y);
              bufferCtx.lineTo(x + resolution, y + resolution / 2);
            }
            if (v10 !== v11) {
              bufferCtx.moveTo(x + resolution, y + resolution / 2);
              bufferCtx.lineTo(x + resolution / 2, y + resolution);
            }
            if (v11 !== v01) {
              bufferCtx.moveTo(x + resolution / 2, y + resolution);
              bufferCtx.lineTo(x, y + resolution / 2);
            }
            if (v01 !== v00) {
              bufferCtx.moveTo(x, y + resolution / 2);
              bufferCtx.lineTo(x + resolution / 2, y);
            }
          }
        }
      }
      
      bufferCtx.stroke();
      ctx.drawImage(bufferCanvas, 0, 0);

        time += 0.00075; // Halved for even slower meditative effect
      }
      
      animationFrameId = requestAnimationFrame(animate);
    };

    animationFrameId = requestAnimationFrame(animate);

    return () => {
      // Cancel animation frame to prevent memory leaks
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
      }
      
      // Clear main canvas
      if (ctx) {
        ctx.clearRect(0, 0, width, height);
      }
      
      // Clear buffer canvas
      if (bufferCtx) {
        bufferCtx.clearRect(0, 0, width, height);
      }
      
      // Clear arrays to prevent memory leaks
      sources.length = 0;
    };
  }, []);

  return (
    <div style={{ 
      margin: 0,
      background: '#F0EEE6',
      overflow: 'hidden',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      height: '100%',
      width: '100%'
    }}>
      <div style={{
        padding: '30px',
        position: 'relative',
        width: '100%',
        height: '100%',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}>
        <canvas 
          ref={canvasRef} 
          style={{ 
            display: 'block',
            width: '550px',
            height: '550px'
          }} 
        />
      </div>
    </div>
  );
};

export default WaveVariationSparse;